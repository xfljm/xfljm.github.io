<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础-5-Java8新特性-Java8新特性</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.编译器可以自动推断元素类型，所以下面可以选择不标注e的类型为String</span></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; System.out.println( e ) );</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( ( String e ) -&gt; System.out.println( e ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.更复杂的语句块可以使用&#123;&#125;</span></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( e -&gt; &#123;</span><br><span class="line">    System.out.print( e );</span><br><span class="line">    System.out.print( e );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.如果引用类成员和局部变量，则会将这些变量隐式转换为final的</span></span><br><span class="line">String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br><span class="line"><span class="comment">//上面的等价于下面方式</span></span><br><span class="line"><span class="keyword">final</span> String separator = <span class="string">","</span>;</span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).forEach( </span><br><span class="line">    ( String e ) -&gt; System.out.print( e + separator ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.如果Lambda表达式中的语句块只有一行，则可以不用使用return语句</span></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br><span class="line"><span class="comment">// 等价于下面</span></span><br><span class="line">Arrays.asList( <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"d"</span> ).sort( ( e1, e2 ) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> result = e1.compareTo( e2 );</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.函数式接口 比如Runable和Callable。通常这类接口标明注解@FunctionalInterface</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-默认方法和静态方法"><a href="#2-默认方法和静态方法" class="headerlink" title="2. 默认方法和静态方法"></a>2. 默认方法和静态方法</h2><p>首先看看默认方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口中可以存在一个默认方法。默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow default methods, the implementer may or </span></span><br><span class="line">    <span class="comment">// may not implement (override) them.</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Default implementation"</span>; </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接继承默认方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写默认方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OverridableImpl</span> <span class="keyword">implements</span> <span class="title">Defaulable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">notRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Overridden implementation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在看看静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面方法整合了默认方法和静态方法使用场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::<span class="keyword">new</span> );</span><br><span class="line">    System.out.println( defaulable.notRequired() ); <span class="comment">//Default implementation</span></span><br><span class="line">        </span><br><span class="line">    defaulable = DefaulableFactory.create( OverridableImpl::<span class="keyword">new</span> );</span><br><span class="line">    System.out.println( defaulable.notRequired() ); <span class="comment">// Overridden implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h2><p>方法引用是为了进一步简化lambda表达式，通过类<strong>名或者实例名与方法名的组合来直接访问到类或者实例已经存在的方法或者构造方法</strong>。方法引用使用<strong>::</strong>来定义，<strong>::</strong>的前半部分表示类名或者实例名，后半部分表示方法名，如果是构造方法就使用<code>NEW</code>来表示。</p>
<p>方法引用在Java8中使用方式相当灵活，总的来说，一共有以下几种形式：</p>
<ul>
<li>静态方法引用：ClassName::methodName;</li>
<li>实例上的实例方法引用：instanceName::methodName;</li>
<li>超类上的实例方法引用：supper::methodName;</li>
<li>类的实例方法引用：ClassName:methodName;</li>
<li>构造方法引用Class:new;</li>
<li>数组构造方法引用::TypeName[]::new</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 四种类型的方法引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">create</span><span class="params">( <span class="keyword">final</span> Supplier&lt; Car &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">( <span class="keyword">final</span> Car car )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Collided "</span> + car.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式3    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">( <span class="keyword">final</span> Car another )</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Following the "</span> + another.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        System.out.println( <span class="string">"Repaired "</span> + <span class="keyword">this</span>.toString() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面分别展示调用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方法引用的类型是构造器引用，语法是Class::new，或者更一般的形式：Class&lt;T&gt;::new。注意：这个构造器没有参数。</span></span><br><span class="line"><span class="keyword">final</span> Car car = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line"><span class="keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法引用的类型是静态方法引用，语法是Class::static_method。注意：这个方法接受一个Car类型的参数。</span></span><br><span class="line">cars.forEach( Car::collide );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方法引用的类型是某个类的成员方法的引用，语法是Class::method，注意，这个方法没有定义入参：</span></span><br><span class="line">cars.forEach( Car::repair );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种方法引用的类型是某个实例对象的成员方法的引用，语法是instance::method。注意：这个方法接受一个Car类型的参数：</span></span><br><span class="line"><span class="keyword">final</span> Car police = Car.create( Car::<span class="keyword">new</span> );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure>



<h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4. Stream API"></a>4. Stream API</h2><p>Java8中有一种新的数据处理方式，那就是流Stream，结合lambda表达式能够更加简洁高效的处理数据。Stream使用一种类似于SQL语句从数据库查询数据的直观方式，对数据进行如筛选、排序以及聚合等多种操作。</p>
<h3 id="4-1-什么是流Stream"><a href="#4-1-什么是流Stream" class="headerlink" title="4.1 什么是流Stream"></a>4.1 什么是流Stream</h3><p>Stream是一个来自数据源的元素队列并支持聚合操作，更像是一个更高版本的Iterator,原始版本的Iterator，只能一个个遍历元素并完成相应操作。而使用Stream，只需要指定什么操作，如“过滤长度大于10的字符串”等操作，Stream会内部遍历并完成指定操作。</p>
<p>Stream中的元素在管道中经过中间操作（intermediate operation）的处理后，最后由最终操作（terminal operation）得到最终的结果。</p>
<ul>
<li>数据源：是Stream的来源，可以是集合、数组、I/O channel等转换而成的Stream；</li>
<li>基本操作：类似于SQL语句一样的操作，比如filter,map,reduce,find,match,sort等操作。</li>
</ul>
<p>当我们操作一个流时，实际上会包含这样的执行过程：</p>
<p><strong>获取数据源--&gt;转换成Stream--&gt;执行操作，返回一个新的Stream--&gt;再以新的Stream继续执行操作---&gt;直至最后操作输出最终结果</strong>。</p>
<h3 id="4-2-生成Stream的方式"><a href="#4-2-生成Stream的方式" class="headerlink" title="4.2 生成Stream的方式"></a>4.2 生成Stream的方式</h3><p>生成Stream的方式主要有这样几种：</p>
<ol>
<li><p>从接口Collection中和Arrays：</p>
<ul>
<li>Collection.stream();</li>
<li>Collection.parallelStream(); //相较于串行流，并行流能够大大提升执行效率</li>
<li>Arrays.stream(T array);</li>
</ul>
</li>
<li><p>Stream中的静态方法：</p>
<ul>
<li>Stream.of()；</li>
<li>generate(Supplier s);</li>
<li>iterate(T seed, UnaryOperator f);</li>
<li>empty();</li>
</ul>
</li>
<li><p>其他方法</p>
<ul>
<li>Random.ints()</li>
<li>BitSet.stream()</li>
<li>Pattern.splitAsStream(java.lang.CharSequence)</li>
<li>JarFile.stream()</li>
<li>BufferedReader.lines()</li>
</ul>
</li>
</ol>
<p>下面对前面常见的两种方式给出示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.使用Collection中的方法和Arrays</span></span><br><span class="line">        String[] strArr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(strArr);</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(strArr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 使用Stream中提供的静态方法</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(strArr);</span><br><span class="line">        Stream&lt;Double&gt; stream3 = Stream.generate(Math::random);</span><br><span class="line">        Stream&lt;Object&gt; stream4 = Stream.empty();</span><br><span class="line">        Stream.iterate(<span class="number">1</span>, i -&gt; i++);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Stream的操作"><a href="#4-3-Stream的操作" class="headerlink" title="4.3 Stream的操作"></a>4.3 Stream的操作</h3><p>常见的Stream操作有这样几种：</p>
<ol>
<li>Intermediate（中间操作）:中间操作是指对流中数据元素做出相应转换或操作后依然返回为一个流Stream，仍然可以供下一次流操作使用。常用的有：map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip。</li>
<li>Termial（结束操作）：是指最终对Stream做出聚合操作，输出结果。</li>
</ol>
<p><strong>中间操作</strong></p>
<blockquote>
<p>filter：对Stream中元素进行过滤</p>
</blockquote>
<p>过滤元素为空的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = stream.filter(str -&gt; str.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>map：对Stream中元素按照指定规则映射成另一个元素</p>
</blockquote>
<p>将每一个元素都添加字符串“_map”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stream.map(str -&gt; str + <span class="string">"_map"</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>map方法是一对一的关系，将stream中的每一个元素按照映射规则成另外一个元素，而如果是一对多的关系的话就需要使用flatmap方法。</p>
<blockquote>
<p>concat：对流进行合并操作</p>
</blockquote>
<p>concat方法将两个Stream连接在一起，合成一个Stream。若两个输入的Stream都时排序的，则新Stream也是排序的；若输入的Stream中任何一个是并行的，则新的Stream也是并行的；若关闭新的Stream时，原两个输入的Stream都将执行关闭处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.concat(Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)).</span><br><span class="line">	forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>distinct：对流进行去重操作</p>
</blockquote>
<p>去除流中重复的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        stream.distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>limit：限制流中元素的个数</p>
</blockquote>
<p>截取流中前两个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        stream.limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>skip：跳过流中前几个元素</p>
</blockquote>
<p>丢掉流中前两个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        stream.skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">输出结果：</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>peek：对流中每一个元素依次进行操作，类似于forEach操作</p>
</blockquote>
<p>JDK中给出的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">            .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">输出结果：</span><br><span class="line">Filtered value: three</span><br><span class="line">Mapped value: THREE</span><br><span class="line">Filtered value: four</span><br><span class="line">Mapped value: FOUR</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sorted：对流中元素进行排序，可以通过sorted(Comparator&lt;? super T&gt; comparator)自定义比较规则</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        stream.sorted(Integer::compareTo).forEach(System.out::println);</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>match：检查流中元素是否匹配指定的匹配规则</p>
</blockquote>
<p>Stream 有三个 match 方法，从语义上说：</p>
<ul>
<li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true；</li>
<li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true；</li>
<li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true。</li>
</ul>
<p>如检查Stream中每个元素是否都大于5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> match = stream.allMatch(integer -&gt; integer &gt; <span class="number">5</span>);</span><br><span class="line">System.out.println(match);</span><br><span class="line">输出结果：</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>



<h2 id="5-Date-Time-API"><a href="#5-Date-Time-API" class="headerlink" title="5. Date Time API"></a>5. Date Time API</h2><p>Java 8引入了<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjcp.org%2Fen%2Fjsr%2Fdetail%3Fid%3D310" target="_blank" rel="noopener">新的Date-Time API(JSR 310)</a>来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。<strong>java.util.Date</strong>和后来的<strong>java.util.Calendar</strong>一直没有解决这个问题（甚至令开发者更加迷茫）。</p>
<p>因为上面这些原因，诞生了第三方库<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.joda.org%2Fjoda-time%2F" target="_blank" rel="noopener">Joda-Time</a>，可以替代Java的时间管理API。Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p>
<p>我们接下来看看java.time包中的关键类和各自的使用例子。首先，<strong>Clock</strong>类使用时区来返回当前的纳秒时间和日期。<strong>Clock</strong>可以替代<strong>System.currentTimeMillis()</strong>和<strong>TimeZone.getDefault()</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the system clock as UTC offset </span></span><br><span class="line"><span class="keyword">final</span> Clock clock = Clock.systemUTC();</span><br><span class="line">System.<span class="keyword">out</span>.println( clock.instant() );</span><br><span class="line">System.<span class="keyword">out</span>.println( clock.millis() );</span><br></pre></td></tr></table></figure>

<p>这个例子的输出结果是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2014<span class="selector-tag">-04-12T15</span><span class="selector-pseudo">:19</span><span class="selector-pseudo">:29.282Z</span></span><br><span class="line">1397315969360</span><br></pre></td></tr></table></figure>

<p>第二，关注下<strong>LocalDate</strong>和<strong>LocalTime</strong>类。<strong>LocalDate</strong>仅仅包含ISO-8601日历系统中的日期部分；<strong>LocalTime</strong>则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the local date and local time</span></span><br><span class="line"><span class="keyword">final</span> LocalDate date = LocalDate.now();</span><br><span class="line"><span class="keyword">final</span> LocalDate dateFromClock = LocalDate.now( clock );</span><br><span class="line">        </span><br><span class="line">System.<span class="keyword">out</span>.println( date );</span><br><span class="line">System.<span class="keyword">out</span>.println( dateFromClock );</span><br><span class="line">        </span><br><span class="line"><span class="comment">// Get the local date and local time</span></span><br><span class="line"><span class="keyword">final</span> LocalTime time = LocalTime.now();</span><br><span class="line"><span class="keyword">final</span> LocalTime timeFromClock = LocalTime.now( clock );</span><br><span class="line">        </span><br><span class="line">System.<span class="keyword">out</span>.println( time );</span><br><span class="line">System.<span class="keyword">out</span>.println( timeFromClock );</span><br></pre></td></tr></table></figure>

<p>上述例子的输出结果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2014<span class="selector-tag">-04-12</span></span><br><span class="line">2014<span class="selector-tag">-04-12</span></span><br><span class="line">11<span class="selector-pseudo">:25</span><span class="selector-pseudo">:54.568</span></span><br><span class="line">15<span class="selector-pseudo">:25</span><span class="selector-pseudo">:54.568</span></span><br></pre></td></tr></table></figure>

<p><strong>LocalDateTime</strong>类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.javacodegeeks.com%2F2014%2F04%2Fjava-8-date-time-api-tutorial-localdatetime.html" target="_blank" rel="noopener">关于LocalDate和LocalTime的例子</a>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the local date/time</span></span><br><span class="line"><span class="keyword">final</span> LocalDateTime datetime = LocalDateTime.now();</span><br><span class="line"><span class="keyword">final</span> LocalDateTime datetimeFromClock = LocalDateTime.now( clock );</span><br><span class="line">        </span><br><span class="line">System.<span class="keyword">out</span>.println( datetime );</span><br><span class="line">System.<span class="keyword">out</span>.println( datetimeFromClock );</span><br></pre></td></tr></table></figure>

<p>上述这个例子的输出结果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2014<span class="selector-tag">-04-12T11</span><span class="selector-pseudo">:37</span><span class="selector-pseudo">:52.309</span></span><br><span class="line">2014<span class="selector-tag">-04-12T15</span><span class="selector-pseudo">:37</span><span class="selector-pseudo">:52.309</span></span><br></pre></td></tr></table></figure>

<p>如果你需要特定时区的data/time信息，则可以使用<strong>ZoneDateTime</strong>，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the zoned date/time</span></span><br><span class="line"><span class="keyword">final</span> ZonedDateTime zonedDatetime = ZonedDateTime.now();</span><br><span class="line"><span class="keyword">final</span> ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );</span><br><span class="line"><span class="keyword">final</span> ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( <span class="string">"America/Los_Angeles"</span> ) );</span><br><span class="line">        </span><br><span class="line">System.<span class="keyword">out</span>.println( zonedDatetime );</span><br><span class="line">System.<span class="keyword">out</span>.println( zonedDatetimeFromClock );</span><br><span class="line">System.<span class="keyword">out</span>.println( zonedDatetimeFromZone );</span><br></pre></td></tr></table></figure>

<p>这个例子的输出结果是：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2014<span class="selector-tag">-04-12T11</span><span class="selector-pseudo">:47</span><span class="selector-pseudo">:01.017-04</span><span class="selector-pseudo">:00</span><span class="selector-attr">[America/New_York]</span></span><br><span class="line">2014<span class="selector-tag">-04-12T15</span><span class="selector-pseudo">:47</span><span class="selector-pseudo">:01.017Z</span></span><br><span class="line">2014<span class="selector-tag">-04-12T08</span><span class="selector-pseudo">:47</span><span class="selector-pseudo">:01.017-07</span><span class="selector-pseudo">:00</span><span class="selector-attr">[America/Los_Angeles]</span></span><br></pre></td></tr></table></figure>

<p>最后看下<strong>Duration</strong>类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get duration between two dates</span></span><br><span class="line"><span class="keyword">final</span> LocalDateTime from = LocalDateTime.of( <span class="number">2014</span>, Month.APRIL, <span class="number">16</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">final</span> LocalDateTime to = LocalDateTime.of( <span class="number">2015</span>, Month.APRIL, <span class="number">16</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">Duration</span> duration = <span class="built_in">Duration</span>.between( from, to );</span><br><span class="line">System.out.println( <span class="string">"Duration in days: "</span> + duration.toDays() );</span><br><span class="line">System.out.println( <span class="string">"Duration in hours: "</span> + duration.toHours() );</span><br></pre></td></tr></table></figure>

<p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Duration</span> <span class="keyword">in</span> days: <span class="number">365</span></span><br><span class="line"><span class="built_in">Duration</span> <span class="keyword">in</span> hours: <span class="number">8783</span></span><br></pre></td></tr></table></figure>

<p>对于Java 8的新日期时间的总体印象还是比较积极的，一部分是因为Joda-Time的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2Ftutorial%2Fdatetime%2Findex.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="6-Optional-类"><a href="#6-Optional-类" class="headerlink" title="6. Optional 类"></a>6. Optional 类</h2><p>Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p>
<p>Java应用中最常见的bug就是<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fexamples.javacodegeeks.com%2Fjava-basics%2Fexceptions%2Fjava-lang-nullpointerexception-how-to-handle-null-pointer-exception%2F" target="_blank" rel="noopener">空值异常</a>。在Java 8之前，<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcode.google.com%2Fp%2Fguava-libraries%2F" target="_blank" rel="noopener">Google Guava</a>引入了<strong>Optionals</strong>类来解决<strong>NullPointerException</strong>，从而避免源码被各种<strong>null</strong>检查污染，以便开发者写出更加整洁的代码。Java 8也将<strong>Optional</strong>加入了官方库。</p>
<p><strong>Optional</strong>仅仅是一个容易：存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fapi%2F" target="_blank" rel="noopener">Java 8官方文档</a>了解更多细节。</p>
<p>接下来看一点使用<strong>Optional</strong>的例子：可能为空的值或者某个类型的值：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Optional&lt; String &gt; fullName = Optional.ofNullable( <span class="literal">null</span> );</span><br><span class="line">System.<span class="keyword">out</span>.println( <span class="string">"Full Name is set? "</span> + fullName.isPresent() );        </span><br><span class="line">System.<span class="keyword">out</span>.println( <span class="string">"Full Name: "</span> + fullName.orElseGet( () -&gt; <span class="string">"[none]"</span> ) ); </span><br><span class="line">System.<span class="keyword">out</span>.println( fullName.map( s -&gt; <span class="string">"Hey "</span> + s + <span class="string">"!"</span> ).orElse( <span class="string">"Hey Stranger!"</span> ) );</span><br></pre></td></tr></table></figure>

<p>如果<strong>Optional</strong>实例持有一个非空值，则<strong>isPresent()</strong>方法返回true，否则返回false；<strong>orElseGet()</strong>方法，<strong>Optional</strong>实例持有null，则可以接受一个lambda表达式生成的默认值；<strong>map()</strong>方法可以将现有的<strong>Opetional</strong>实例的值转换成新的值；<strong>orElse()</strong>方法与<strong>orElseGet()</strong>方法类似，但是在持有null的时候返回传入的默认值。</p>
<p>上述代码的输出结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Full</span> <span class="type">Name</span> <span class="keyword">is</span> <span class="keyword">set</span>? <span class="literal">false</span></span><br><span class="line"><span class="type">Full</span> <span class="type">Name</span>: [<span class="keyword">none</span>]</span><br><span class="line"><span class="type">Hey</span> <span class="type">Stranger!</span></span><br></pre></td></tr></table></figure>

<p>再看下另一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Optional&lt; String &gt; firstName = Optional.of( <span class="string">"Tom"</span> );</span><br><span class="line">System.out.<span class="built_in">println</span>( <span class="string">"First Name is set? "</span> + firstName.isPresent() );        </span><br><span class="line">System.out.<span class="built_in">println</span>( <span class="string">"First Name: "</span> + firstName.orElseGet( () -&gt; <span class="string">"[none]"</span> ) ); </span><br><span class="line">System.out.<span class="built_in">println</span>( firstName.<span class="keyword">map</span>( s -&gt; <span class="string">"Hey "</span> + s + <span class="string">"!"</span> ).orElse( <span class="string">"Hey Stranger!"</span> ) );</span><br><span class="line">System.out.<span class="built_in">println</span>();</span><br></pre></td></tr></table></figure>

<p>这个例子的输出是：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> <span class="type">Name</span> <span class="keyword">is</span> <span class="keyword">set</span>? <span class="literal">true</span></span><br><span class="line"><span class="type">First</span> <span class="type">Name</span>: <span class="type">Tom</span></span><br><span class="line"><span class="type">Hey</span> <span class="type">Tom!</span></span><br></pre></td></tr></table></figure>

<p>如果想了解更多的细节，请参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Fapi%2Fjava%2Futil%2FOptional.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="7-Nashorn-JavaScript-引擎"><a href="#7-Nashorn-JavaScript-引擎" class="headerlink" title="7. Nashorn, JavaScript 引擎"></a>7. Nashorn, JavaScript 引擎</h2><p>Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</p>
<p>Java 8提供了新的<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.javacodegeeks.com%2F2014%2F02%2Fjava-8-compiling-lambda-expressions-in-the-new-nashorn-js-engine.html" target="_blank" rel="noopener">Nashorn JavaScript引擎</a>，使得我们可以在JVM上开发和运行JS应用。Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用，例子代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ScriptEngineManager manager = <span class="keyword">new</span> ScriptEngineManager();</span><br><span class="line">ScriptEngine engine = manager.getEngineByName( <span class="string">"JavaScript"</span> );</span><br><span class="line">        </span><br><span class="line">System.<span class="keyword">out</span>.println( engine.getClass().getName() );</span><br><span class="line">System.<span class="keyword">out</span>.println( <span class="string">"Result:"</span> + engine.eval( <span class="string">"function f() &#123; return 1; &#125;; f() + 1;"</span> ) );</span><br></pre></td></tr></table></figure>

<p>这个代码的输出结果如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">jdk</span><span class="selector-class">.nashorn</span><span class="selector-class">.api</span><span class="selector-class">.scripting</span><span class="selector-class">.NashornScriptEngine</span></span><br><span class="line"><span class="selector-tag">Result</span>: 2</span><br></pre></td></tr></table></figure>



<p>还有一些并行和并发的操作可以参考下面文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/5b800057f2d8" target="_blank" rel="noopener">https://www.jianshu.com/p/5b800057f2d8</a></li>
<li><a href="https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1" target="_blank" rel="noopener">https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1https://juejin.im/post/5ae6bfb66fb9a07a9b35bac1</a></li>
<li><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">https://www.runoob.com/java/java8-new-features.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-8-Java基础：Stream接口终端操作reduce操作</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-8-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9Creduce%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>对于中间操作和终端操作的定义，请看<a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a>，这篇主要讲述的是stream的reduce操作，</p>
<p>reduce 是一种归约操作，将流归约成一个值的操作叫做归约操作，用函数式编程语言的术语来说，这种称为折叠（fold）；</p>
<p>我们先看下函数的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在ReferencePipeline类中对该接口中的reduce方法进行了实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> P_OUT <span class="title">reduce</span><span class="params">(<span class="keyword">final</span> P_OUT identity, <span class="keyword">final</span> BinaryOperator&lt;P_OUT&gt; accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evaluate(ReduceOps.makeRef(identity, accumulator, accumulator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Optional&lt;P_OUT&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;P_OUT&gt; accumulator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evaluate(ReduceOps.makeRef(accumulator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">reduce</span><span class="params">(R identity, BiFunction&lt;R, ? <span class="keyword">super</span> P_OUT, R&gt; accumulator, BinaryOperator&lt;R&gt; combiner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evaluate(ReduceOps.makeRef(identity, accumulator, combiner));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，第一个和第三个，是一个重载方法，调用的同一个实现；下面，我们看下具体的小案例</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Collectors.toList()是将流转换为list</span></span><br><span class="line">        List&lt;Integer&gt; numbers = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">1</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">        Integer aa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : numbers)&#123;</span><br><span class="line">            aa +=i;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer dd = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b, (a, b) -&gt; a - b);</span><br><span class="line">        Optional&lt;Integer&gt; dd1 = numbers.stream().reduce((a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(aa); <span class="comment">// 55</span></span><br><span class="line">        System.out.println(dd); <span class="comment">// 55</span></span><br><span class="line">        System.out.println(dd1.get());  <span class="comment">// 55</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用无限流，生成了1-10的数字的list，关于无限流的解释，以及流的创建的方式，可以 参看<a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《java8 Stream-创建流的几种方式》</a>；</p>
<p>在java8之前，我们对数据求和的，是需要对list进行遍历，然后累加求和的；在案例中，变量aa就是对list遍历累加求和的出处理；从第二段代码中开始，就是java8中的求和方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数，接受2个参数，第一个表示初始值，第二个值，传入的是一个函数式接口BinaryOperator，这个接口继承BiFunction;计算的表达式的规则；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个接口。只用传入计算规则，初始值是list的第一个参数，返回的optional对象，预防list里，全部是null；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关于这个三个参数的接口，在《java8实战》这本书中，没有做介绍。我也不是特别理解，查阅过一些资料，在多线程中使用的，具体感兴趣的，可以参考<a href="https://segmentfault.com/q/1010000004944450" target="_blank" rel="noopener">《 java8中3个参数的reduce方法怎么理解？》</a></p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-9-Java基础：Stream接口终端操作collect操作</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-9-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9Ccollect%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Stream接口终端操作collect操作"><a href="#1-Stream接口终端操作collect操作" class="headerlink" title="1. Stream接口终端操作collect操作"></a>1. Stream接口终端操作collect操作</h2><p>在之前，我们有说到，java8中的stream操作，分为中间操作和终端操作，在终端操作中，前面也看到了归约的方式，这篇主要是也说的归约操作的方式collect，收集器操作，收集器操作，可以当做是一种更高级的归约操作；</p>
<p>先看下stream中的collect操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,BiConsumer&lt;R, R&gt; combiner)</span></span>;	&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个，是传入3个参数的抽象方法，</p>
<p>第二个只有一个参数的先看下stream中的collect操作Collectors静态工厂类，而在这个静态工厂类中，大部分的实现，都是调用的三个参数的方法，几乎满足了我们日常中所有的操作；所以说，我们只看下，这个静态工厂类中，有哪些实现；</p>
<p><img src="https://img-blog.csdn.net/20180715145937380?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4NDEwMjgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>)<img src="https://img-blog.csdn.net/2018071514595970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4NDEwMjgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>在java8实战中，有列举出来，大家可以自己看下介绍，下面，我们通过代码，做个演示；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Emp&gt; list = <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"上海"</span>, <span class="string">"小名"</span>, <span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"北京"</span>, <span class="string">"小红"</span>, <span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"深圳"</span>, <span class="string">"小蓝"</span>, <span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"广州"</span>, <span class="string">"小灰"</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"杭州"</span>, <span class="string">"小黄"</span>, <span class="number">21</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"贵阳"</span>, <span class="string">"小白"</span>, <span class="number">22</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转list   将流中所有项目收集到一个List中</span></span><br><span class="line">        List&lt;String&gt; listValue = StreamTest8.list.stream().map(emp -&gt; emp.getName()).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 转set    将流中所有项目收集到一个Set中，删除重复项</span></span><br><span class="line">        Set&lt;String&gt; set = StreamTest8.list.stream().map(emp -&gt; emp.getName()).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// 转map，需要指定key和value，Function.identity()表示当前的Emp对象本身</span></span><br><span class="line">        Map&lt;String, Emp&gt; map = StreamTest8.list.stream().collect(Collectors.toMap(Emp::getName, Function.identity()));</span><br><span class="line">        <span class="comment">// 计算流中元素的个数</span></span><br><span class="line">        Long count = list.stream().collect(Collectors.counting());</span><br><span class="line">        <span class="comment">// 对流中的属性求和</span></span><br><span class="line">        <span class="comment">// summingInt summingLong summingDouble</span></span><br><span class="line">        Integer sumAges = list.stream().collect(Collectors.summingInt(Emp::getAge));</span><br><span class="line">        <span class="comment">// 对流中的属性求平均值</span></span><br><span class="line">        <span class="comment">// averagingInt,averagingDouble,averagingLong</span></span><br><span class="line">        Double aveAges = list.stream().collect(Collectors.averagingInt(Emp::getAge));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 综合处理 求最大值，最小值，平均值，求和操作</span></span><br><span class="line">        <span class="comment">// summarizingInt，summarizingLong,summarizingDouble</span></span><br><span class="line">        IntSummaryStatistics intSummary = list.stream().collect(Collectors.summarizingInt(Emp::getAge));</span><br><span class="line">        System.out.println(intSummary.getAverage());</span><br><span class="line">        System.out.println(intSummary.getMax());</span><br><span class="line">        System.out.println(intSummary.getMin());</span><br><span class="line">        System.out.println(intSummary.getSum());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接字符串,当然也可以使用重载的方法，加上一些前缀，后缀和中间分隔符</span></span><br><span class="line">        String strEmp = list.stream().map(emp -&gt; emp.getName()).collect(Collectors.joining());</span><br><span class="line">        String strEmp1 = list.stream().map(emp -&gt; emp.getName()).collect(Collectors.joining(<span class="string">"-中间的分隔符-"</span>));</span><br><span class="line">        String strEmp2 = list.stream().map(emp -&gt; emp.getName()).collect(Collectors.joining(<span class="string">"-中间的分隔符-"</span>, <span class="string">"前缀*"</span>, <span class="string">"&amp;后缀"</span>));</span><br><span class="line">        System.out.println(strEmp);  <span class="comment">// 小名小红小蓝小灰小黄小白</span></span><br><span class="line">        System.out.println(strEmp1); <span class="comment">// 小名-中间的分隔符-小红-中间的分隔符-小蓝-中间的分隔符-小灰-中间的分隔符-小黄-中间的分隔符-小白</span></span><br><span class="line">        System.out.println(strEmp2); <span class="comment">// 前缀*小名-中间的分隔符-小红-中间的分隔符-小蓝-中间的分隔符-小灰-中间的分隔符-小黄-中间的分隔符-小白&amp;后缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// maxBy 按照比较器中的比较结果刷选 最大值</span></span><br><span class="line">        Optional&lt;Integer&gt; maxAge = list.stream().map(emp -&gt; emp.getAge())</span><br><span class="line">                .collect(Collectors.maxBy(Comparator.comparing(Function.identity())));</span><br><span class="line">        <span class="comment">// minBy 按照比较器中的比较结果刷选 最大值</span></span><br><span class="line">        Optional&lt;Integer&gt; minAge = list.stream().map(emp -&gt; emp.getAge())</span><br><span class="line">                .collect(Collectors.minBy(Comparator.comparing(Function.identity())));</span><br><span class="line">        System.out.println(<span class="string">"max:"</span> + maxAge);</span><br><span class="line">        System.out.println(<span class="string">"min:"</span> + minAge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 规约操作</span></span><br><span class="line">        list.stream().map(emp -&gt; emp.getAge())</span><br><span class="line">                .collect(Collectors.reducing((x, y) -&gt; x + y));</span><br><span class="line">        list.stream().map(emp -&gt; emp.getAge())</span><br><span class="line">                .collect(Collectors.reducing(<span class="number">0</span>, (x, y) -&gt; x + y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分组操作 groupingBy 根据地址，把原list进行分组</span></span><br><span class="line">        Map&lt;String, List&lt;Emp&gt;&gt; mapGroup = list.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Emp::getAddress));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分区操作 partitioningBy 需要根据类型指定判断分区</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Integer&gt;&gt; partitioningMap = list.stream()</span><br><span class="line">                .map(emp -&gt; emp.getAge()).collect(Collectors.partitioningBy(emp -&gt; emp &gt; <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String address, String name, Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Emp [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先介绍在这里，大家对java8的的函数式接口，以及lambda表达式的写法，有看不懂的，可以参看我之前的文章</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-6-Java基础：Stream接口终端操作-toArray操作</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-6-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C-toArray%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>对于中间操作和终端操作的定义，请看<a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a>，这篇主要讲述的是stream的toArray操作，我们先看下函数的定义以及实现。</p>
<p>在Stream类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure>

<p>存在有参和无参的构造函数，其实现类为ReferencePipeline类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator) &#123;</span><br><span class="line">    <span class="comment">// Since A has no relation to U (not possible to declare that A is an upper bound of U)</span></span><br><span class="line">    <span class="comment">// there will be no static type checking.</span></span><br><span class="line">    <span class="comment">// Therefore use a raw type and assume A == U rather than propagating the separation of A and U</span></span><br><span class="line">    <span class="comment">// throughout the code-base.</span></span><br><span class="line">    <span class="comment">// The runtime type of U is never checked for equality with the component type of the runtime type of A[].</span></span><br><span class="line">    <span class="comment">// Runtime checking will be performed when an element is stored in A[], thus if A is not a</span></span><br><span class="line">    <span class="comment">// super type of U an ArrayStoreException will be thrown.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    IntFunction rawGenerator = (IntFunction) generator;</span><br><span class="line">    <span class="keyword">return</span> (A[]) Nodes.flatten(evaluateToArrayNode(rawGenerator), rawGenerator)</span><br><span class="line">                          .asArray(rawGenerator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> toArray(Object[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现无参的<code>toArray()</code>方法实际上调用的是有参的方法，并且传入的是<code>Object[]</code>。</p>
<p>下面我们通过案例，看下具体的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java8 stream接口 终端操作 toArray操作</span></span><br><span class="line"><span class="comment"> * 参考：https://blog.csdn.net/qq_28410283/article/details/80783286</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Stream类中的toArray:</span></span><br><span class="line"><span class="comment"> *      通过源码可以发现，无参情况下默认返回的是Object[]；通过指定参数返回相对应的数组形式</span></span><br><span class="line"><span class="comment"> * List类中的toArray:</span></span><br><span class="line"><span class="comment"> *      和前者功能几乎差不读</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        String[] dd = strs.stream().toArray(str -&gt; <span class="keyword">new</span> String[strs.size()]);</span><br><span class="line">        String[] dd1 = strs.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        Object[] obj = strs.stream().toArray();</span><br><span class="line"></span><br><span class="line">        String[] dd2 = strs.toArray(<span class="keyword">new</span> String[strs.size()]);</span><br><span class="line">        Object[] obj1 = strs.toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，前三个，是调用的stream的toArray的函数，以及一些用法，后面的两个，是直接调用的List接口的toArray函数，List接口里的，只是顺带提了一下，用法就是这样，请大家自己get吧</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-7-Java基础：Stream接口终端操作-count，anyMatch，allMatch，noneMatch</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-7-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C-count%EF%BC%8CanyMatch%EF%BC%8CallMatch%EF%BC%8CnoneMatch/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>对于中间操作和终端操作的定义，请看<a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a>，这篇主要讲述的是stream的count，anyMatch，allMatch，noneMatch操作，我们先看下函数的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 跟List接口的size一样，返回的都是这个集合流的元素的长度，不同的是，流是集合的一个高级工厂，中间操作是工厂里的每一道工序，我们对这个流操作完成后，可以进行元素的数量的和</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断的条件里，任意一个元素成功，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="comment">// 判断条件里的元素，所有的都是，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="comment">// 跟allMatch相反，判断条件里的元素，所有的都不是，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<p>剩下的三个方法，传入的都是Predicate的函数式接口，接口定义请看<a href="https://blog.csdn.net/qq_28410283/article/details/80601495" target="_blank" rel="noopener">《JAVA8 Predicate接口》</a>；</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> aa = strs.stream().anyMatch(str -&gt; str.equals(<span class="string">"a"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> bb = strs.stream().allMatch(str -&gt; str.equals(<span class="string">"a"</span>));</span><br><span class="line">        <span class="keyword">boolean</span> cc = strs.stream().noneMatch(str -&gt; str.equals(<span class="string">"a"</span>));</span><br><span class="line">        <span class="keyword">long</span> count = strs.stream().filter(str -&gt; str.equals(<span class="string">"a"</span>)).count();</span><br><span class="line">        System.out.println(aa);</span><br><span class="line">        System.out.println(bb);</span><br><span class="line">        System.out.println(cc);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>通过例子可以看到，变量aa的表达式，strs里的元素，任意有“a”，表示true</p>
<p>变量bb的表达式，strs里的元素，全部为“a”，表示true，否则false</p>
<p>变量cc的表达式，strs里的元素，全部不为“a”，表示true，否则false</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-5-Java基础：Stream接口终端操作-forEachOrdered和forEach</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-5-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C-forEachOrdered%E5%92%8CforEach/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>对于中间操作和终端操作的定义，请看<a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<h3 id="1-1-串行流和并行流"><a href="#1-1-串行流和并行流" class="headerlink" title="1.1 串行流和并行流"></a>1.1 串行流和并行流</h3><p>在<code>Collection</code>类中存在如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用并行流的方式</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用串行流的方式</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并行流相当于可以实现一种并行计算。</p>
<h3 id="1-2-forEach和forEachOrder操作"><a href="#1-2-forEach和forEachOrder操作" class="headerlink" title="1.2 forEach和forEachOrder操作"></a>1.2 forEach和forEachOrder操作</h3><p>这篇开始介绍java8的终端操作，以及forEachOrdered和forEach；先看下这个函数的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数都是对集合的流，进行遍历操作，是属于内部迭代；传入一个Consumer的函数接口，关于consumer的定义请看<a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a>；下面通过案例，简单了解下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 串行流：stream(),程序是串行执行的，所有看到遍历的结果都是按照集合的元素放入的顺序</span></span><br><span class="line"><span class="comment"> *        使用foreEach()输出的效果和forEachOrder效果一样。</span></span><br><span class="line"><span class="comment"> * 并行流：parallelStream()，并行流，也就是在程序内部迭代的时候，会帮你免费的并行处理，</span></span><br><span class="line"><span class="comment"> *        forEachOrdered表示严格按照顺序取数据，forEach在并行中，随机排列了。</span></span><br><span class="line"><span class="comment"> *        forEach的效率高于forEachOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line"></span><br><span class="line">        strs.stream().forEachOrdered(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        strs.stream().forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        strs.parallelStream().forEachOrdered(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        strs.parallelStream().forEach(System.out::print);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line">cab</span><br></pre></td></tr></table></figure>

<p>先看第一段输出和第二段输出，使用的是stream的流，这个是一个串行流，也就是程序是串行执行的，所有看到遍历的结果都是按照集合的元素放入的顺序；</p>
<p>看第三段和第四段输出，使用的parallelStream的流，这个流表示一个并行流，也就是在程序内部迭代的时候，会帮你免费的并行处理，关于java8的并行处理，会在后期为大家介绍；</p>
<p>第三段代码的forEachOrdered表示严格按照顺序取数据，forEach在并行中，随机排列了；这个也可以看出来，在并行的程序中，如果对处理之后的数据，没有顺序的要求，使用forEach的效率，肯定是要更好的</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-4-Java基础：Stream接口distinct，sorted，peek，limit，skip操作</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-4-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3distinct%EF%BC%8Csorted%EF%BC%8Cpeek%EF%BC%8Climit%EF%BC%8Cskip%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Stream接口distinct，sorted，peek，limit，skip操作"><a href="#1-Stream接口distinct，sorted，peek，limit，skip操作" class="headerlink" title="1. Stream接口distinct，sorted，peek，limit，skip操作"></a>1. Stream接口distinct，sorted，peek，limit，skip操作</h2><p>下面，我们来看其他的剩余的一些中间操作，各自的作用，我也通过注释，做了解析，方法定义如下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去重复</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//根据属性排序</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"><span class="comment">//对对象的进行操作</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"><span class="comment">//截断--取先maxSize个对象</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br><span class="line"><span class="comment">//截断--忽略前N个对象</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面，我们用一些案例，对这些操作，做一些综合的演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Emp&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong1"</span>, <span class="number">20</span>, <span class="number">1000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong2"</span>, <span class="number">25</span>, <span class="number">2000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong3"</span>, <span class="number">30</span>, <span class="number">3000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong4"</span>, <span class="number">35</span>, <span class="number">4000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong5"</span>, <span class="number">38</span>, <span class="number">5000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong6"</span>, <span class="number">45</span>, <span class="number">9000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong7"</span>, <span class="number">55</span>, <span class="number">10000.0</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Emp(<span class="string">"xiaoHong8"</span>, <span class="number">42</span>, <span class="number">15000.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Stream&lt;Emp&gt; stream)</span></span>&#123;</span><br><span class="line">        stream.forEach(emp-&gt;&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"名字：%s，年纪：%s，薪水：%s"</span>, emp.getName(), emp.getAge(), emp.getSalary()));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组流，先过滤重复，在排序，再控制台输出 1，2，3</span></span><br><span class="line">        Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>).stream().distinct().sorted().forEach(str-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对list里的emp对象，取出薪水，并对薪水进行排序，然后输出薪水的内容，map操作，改变了Strenm的泛型对象</span></span><br><span class="line">        list.stream().map(emp-&gt;emp.getSalary()).sorted().forEach(salary-&gt;&#123;</span><br><span class="line">            System.out.println(salary);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据emp的属性name，进行排序</span></span><br><span class="line">        println(list.stream().sorted(Comparator.comparing(Emp::getName)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给年级大于30岁的人，薪水提升1.5倍，并输出结果</span></span><br><span class="line">        Stream&lt;Emp&gt; stream = list.stream().filter(emp -&gt; emp.getAge()&gt;<span class="number">30</span>).peek(emp -&gt; &#123;</span><br><span class="line">            emp.setSalary(emp.getSalary()*<span class="number">1.5</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        println(stream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数字从1开始迭代（无限流），下一个数字，是上个数字+1，忽略前5个 ，并且只取10个数字</span></span><br><span class="line">        <span class="comment">// 原本1-无限，忽略前5个，就是1-5数字，不要，从6开始，截取10个，就是6-15</span></span><br><span class="line">        Stream.iterate(<span class="number">1</span>, x-&gt;++x).skip(<span class="number">5</span>).limit(<span class="number">10</span>).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Double salary;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, Integer age, Double salary)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> salary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(Double salary)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个例子，也都加了注释，大家看例子，自己get吧</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-2-Java基础：Stream接口中间操作和终端操作</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-2-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E5%92%8C%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Stream接口中间操作和终端操作"><a href="#1-Stream接口中间操作和终端操作" class="headerlink" title="1. Stream接口中间操作和终端操作"></a>1. Stream接口中间操作和终端操作</h2><p>上一篇我们介绍了stream的集中创建方式，<a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a>，从这篇开始，我们开始介绍stream接口里的一系列方法的作用，以及使用，每个方法都会有相对应的案例的解析，让大家可以更加直观的方式，了解方法的使用，使用这些方法之前，我们先对方法的类型，进行归类，然后分类型进行讲解；下面，我们再看下接口定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">Stream</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">IntStream <span class="title">flatMapToInt</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends IntStream&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">LongStream <span class="title">flatMapToLong</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends LongStream&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">DoubleStream <span class="title">flatMapToDouble</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends DoubleStream&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">	Object[] toArray();</span><br><span class="line"> </span><br><span class="line">	&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"> </span><br><span class="line">	<span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Builder&lt;T&gt; <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Streams.StreamBuilderImpl&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(Spliterators.&lt;T&gt; emptySpliterator(), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> Streams.StreamBuilderImpl&lt;&gt;(t), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SafeVarargs</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>) <span class="comment">// Creating a stream from an array is safe</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(f);</span><br><span class="line">		<span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">			T t = (T) Streams.NONE;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> t = (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(</span><br><span class="line">				Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(s);</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s),</span><br><span class="line">				<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(a);</span><br><span class="line">		Objects.requireNonNull(b);</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		Spliterator&lt;T&gt; split = <span class="keyword">new</span> Streams.ConcatSpliterator.OfRef&lt;&gt;((Spliterator&lt;T&gt;) a.spliterator(),</span><br><span class="line">				(Spliterator&lt;T&gt;) b.spliterator());</span><br><span class="line">		Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());</span><br><span class="line">		<span class="keyword">return</span> stream.onClose(Streams.composedClose(a, b));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">default</span> Builder&lt;T&gt; <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">			accept(t);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function">Stream&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过抽象方法的定义，我们可以看到，这个方法，可以分成两种类型，一种返回类型为接口本身的Stream<T>，另外一种是返回其他对象类型的，返回接口类型的，我们称这些方法为中间操作，返回其他具体类型的，我们称为终端操作；</T></p>
<p>中间操作，是什么操作? 我们先看下字符串操作StringBuilder的append的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;        <span class="keyword">super</span>.append(str);        <span class="keyword">return</span> <span class="keyword">this</span>;    &#125;</span><br></pre></td></tr></table></figure>

<p>对，就是这样，返回对象本身；然后我们就可以像操作StringBuilder的append一样，可以连接操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();		sb.append(<span class="string">"a"</span>).append(<span class="string">"b"</span>).append(<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>

<p>终端操作，是指返回最终的结果，例如我们常用的forEach，内部迭代；</p>
<p>下面附一张具体的分类的图，这个图，来自《java8实战》的第五章，我也就直接拿来使用了，不再去单独整理</p>
<p><img src="https://img-blog.csdn.net/20180609175507605?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4NDEwMjgz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>先介绍到这里，我们下一篇开始，介绍流的中间操作的方法</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-3-Java基础：Stream接口map操作filter操作flatMap操作</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-3-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%8E%A5%E5%8F%A3map%E6%93%8D%E4%BD%9Cfilter%E6%93%8D%E4%BD%9CflatMap%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h2><p>这篇，我们来看Stream的一些中间操作，关于中间操作的一些介绍，可以看<a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<h3 id="1-1filter操作"><a href="#1-1filter操作" class="headerlink" title="1.1filter操作"></a>1.1filter操作</h3><p><strong>作用：</strong>对内部的boolean判断，如果结果为true，则返回该对象</p>
<p><strong>分析：</strong>我们先看方法的定义，这个方法，传入一个Predicate的函数接口，关于Predicate函数接口定义，可以查看<a href="https://blog.csdn.net/qq_28410283/article/details/80601495" target="_blank" rel="noopener">《JAVA8 Predicate接口》</a>，这个接口传入一个泛型参数T，做完操作之后，返回一个boolean值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>案例：</strong>使用Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// filter方法</span></span><br><span class="line">        String[] dd = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(dd);</span><br><span class="line">        stream.filter(str -&gt; str.equals(<span class="string">"a"</span>)).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">a</span></span><br></pre></td></tr></table></figure>



<h3 id="1-2-map操作"><a href="#1-2-map操作" class="headerlink" title="1.2 map操作"></a>1.2 map操作</h3><p><strong>作用：</strong>调用这个函数后，可以改变返回的类型</p>
<p><strong>分析：</strong>这个方法传入一个Function的函数式接口，接口定义可以查看<a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口》</a>，这个接口，接收一个泛型T，返回泛型R，map函数的定义，返回的流，表示的泛型是R对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>案例：</strong>使用map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map操作</span></span><br><span class="line">        <span class="comment">// 基本类型</span></span><br><span class="line">        Integer[] aa = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream1 = Arrays.stream(aa);</span><br><span class="line">        stream1.map(str-&gt;Integer.toString(str)).forEach(str-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">            System.out.println(str.getClass());</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">	    <span class="comment">// 对象</span></span><br><span class="line">        List&lt;Emp&gt; list = Arrays.asList(<span class="keyword">new</span> Emp(<span class="string">"a"</span>), <span class="keyword">new</span> Emp(<span class="string">"b"</span>), <span class="keyword">new</span> Emp(<span class="string">"c"</span>));</span><br><span class="line">        list.stream().map(emp-&gt;emp.getName()).forEach(str-&gt;&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class">2</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class">3</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="title">a</span></span></span><br><span class="line"><span class="class"><span class="title">b</span></span></span><br><span class="line"><span class="class"><span class="title">c</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们把Integer，变成了String输出，把Emp对象里的name字符串，单独输出；现在，我们只看到了一个forEach的终端操作，后面，我们会看到，更多的终端操作，把map操作后，改变的对象类型，返回各种类型的集合，或者对数字类型的，返回求和，最大，最小等的操作；</p>
<h3 id="1-3-flatMap操作"><a href="#1-3-flatMap操作" class="headerlink" title="1.3 flatMap操作"></a>1.3 flatMap操作</h3><p><strong>作用：</strong>把两个流，变成一个流返回</p>
<p><strong>分析：</strong>这个接口，跟map一样，接收一个Fucntion的函数式接口，不同的是，Function接收的泛型参数，第二个参数是一个Stream流；方法，返回的也是泛型R</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>案例：</strong>使用flatMap，将两个流的内容，变成一个流的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flatMap操作:将两个流变成一个流</span></span><br><span class="line">        String[] str = &#123;<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>&#125;;</span><br><span class="line">        Arrays.stream(str).map(str1-&gt;str1.split(<span class="string">""</span>)).forEach(System.out::print); </span><br><span class="line">        System.out.println();</span><br><span class="line">        Arrays.stream(str).map(str1-&gt;str1.split(<span class="string">""</span>)).flatMap(Arrays::stream).forEach(System.out::print); </span><br><span class="line">        System.out.println();</span><br><span class="line">        Arrays.stream(str).map(str1-&gt;str1.split(<span class="string">""</span>)).flatMap(str1-&gt;Arrays.stream(str1)).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[Ljava.lang.String;@<span class="number">568</span>db2f2[Ljava.lang.String;@<span class="number">378</span>bf509[Ljava.lang.String;@<span class="number">5f</span>d0d5ae</span><br><span class="line">aaabbbccc</span><br><span class="line">aaabbbccc</span><br></pre></td></tr></table></figure>

<p>首先，第一个输出语句里，我们看到，我们输出的对象，并不是想象中的具体的字符串，第二段代码，才输出的具体的字符串；</p>
<p>第一段输出代码里，我们先看map操作，通过上面对map的介绍，我们可以看到，map可以改变返回的Stream的泛型，str.split(“”)，根据空字符串分隔，返回的类型是一个数组，返回的流也是Stream&lt;String[]&gt;，而不是Stream<String>；在第二段代码中，数组的流，经过map操作，返回Stream&lt;String[]&gt;后，再经过flatMap，把数组通过Arrays.stream变成一个新的流，再返回到原来的流里；这样，两个流就合并成一个流；第三段代码，是第二段代码的，另一种写法；</String></p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-18-Java基础：BiConsumer接口</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-18-Java%E5%9F%BA%E7%A1%80%EF%BC%9ABiConsumer%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-BiConsumer接口"><a href="#1-BiConsumer接口" class="headerlink" title="1. BiConsumer接口"></a>1. BiConsumer接口</h2><p>这个接口跟<a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a>很像，表达的想法也是一致的，都是消费的意思，我们先看下接口定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiConsumer</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**本接口中的accept先执行，传入的BiConsumer 接口类型的参数，后执行accept*/</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title">andThen</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口接收两个泛型参数，跟Consumer一样，都有一个 accept方法，只不过，这里的，接收两个泛型参数，对这两个参数做下消费处理；使用这个函数式接口的终端操作有map的遍历；下面看下面的例子，两个参数消费数据的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="string">"a"</span>);</span><br><span class="line">map.put(<span class="string">"b"</span>, <span class="string">"b"</span>);</span><br><span class="line">map.put(<span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">map.put(<span class="string">"d"</span>, <span class="string">"d"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，Map接口的终端操作，forEach的参数就是BiConsumer函数接口，对HashMap 的数据进行消费；BiConsumer函数接口还有一个默认函数，andThen，接收一个BiConsumer接口，先执行本接口的，再执行传入的参数。</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-16-Java基础：Supplier接口</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-16-Java%E5%9F%BA%E7%A1%80%EF%BC%9ASupplier%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Supplier接口"><a href="#1-Supplier接口" class="headerlink" title="1. Supplier接口"></a>1. Supplier接口</h2><p>下看下接口定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个接口是一个提供者的意思，只有一个get的抽象类，没有默认的方法以及静态的方法，传入一个泛型T的，get方法，返回一个泛型T</p>
<p>下面，我们用一个小案例，来看看这个接口，是干什么用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;String&gt; supplier = String::<span class="keyword">new</span>;</span><br><span class="line">System.out.println(supplier.get());<span class="comment">//""</span></span><br><span class="line">Supplier&lt;Emp&gt; supplierEmp = Emp::<span class="keyword">new</span>;</span><br><span class="line">Emp emp = supplierEmp.get();</span><br><span class="line">emp.setName(<span class="string">"dd"</span>);</span><br><span class="line">System.out.println(emp.getName());<span class="comment">//dd</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这个接口，只是为我们提供了一个创建好的对象，这也符号接口的语义的定义，提供者，提供一个对象，</p>
<p>直接理解成一个创建对象的工厂，就可以了；</p>
<p>Emp对象定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-17-Java基础：UnaryOperator接口</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-17-Java%E5%9F%BA%E7%A1%80%EF%BC%9AUnaryOperator%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-UnaryOperator接口"><a href="#1-UnaryOperator接口" class="headerlink" title="1. UnaryOperator接口"></a>1. UnaryOperator接口</h2><p>我们先看下这个接口的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a unary operator that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output of the operator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a unary operator that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口继承Function接口，Funtion接口，定义了一个apply的抽象类，接收一个泛型T对象，并且返回泛型R对象</p>
<p>关于Funtcion的意思以及用法，可以移步这边<a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">Function接口的详细</a>；</p>
<p>这个接口，只接收一个泛型参数T，集成Function接口，也就是说，传入泛型T类型的参数，调用apply后，返回也T类型的参数；这个接口定义了一个静态方法，返回泛型对象的本身；</p>
<p>具体用法，可以参照<a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">Function接口详细</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UnaryOperator&lt;Integer&gt; dda = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">System.out.println(dda.apply(<span class="number">10</span>));<span class="comment">// 11</span></span><br><span class="line">UnaryOperator&lt;String&gt; ddb = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">System.out.println(ddb.apply(<span class="string">"aa"</span>));<span class="comment">// aa1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-14-Java基础：Function接口以及同类型的特化的接口</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-14-Java%E5%9F%BA%E7%A1%80%EF%BC%9AFunction%E6%8E%A5%E5%8F%A3%E4%BB%A5%E5%8F%8A%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E5%8C%96%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Function接口以及同类型的特化的接口"><a href="#1-Function接口以及同类型的特化的接口" class="headerlink" title="1. Function接口以及同类型的特化的接口"></a>1. Function接口以及同类型的特化的接口</h2><p>我们先来看下Funtion接口的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Funtion接口，定义了一个apply的抽象方法，接收一个泛型T对象，并且返回泛型R对象，看到这里，是不是对这个接口的描述，还是一头雾水呢，下面，我们看下几个例子，来讲述这个接口的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; function1 = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">System.out.println(function1.apply(<span class="number">4</span>));<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer, String&gt; function2 = x -&gt; x * <span class="number">2</span> + <span class="string">"dd"</span>;</span><br><span class="line">System.out.println(function2.apply(<span class="number">4</span>));<span class="comment">//8dd</span></span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; strFunction1 = (str) -&gt; <span class="keyword">new</span> String(str);</span><br><span class="line">System.out.println(strFunction1.apply(<span class="string">"aa"</span>));<span class="comment">//aa</span></span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; strFunction2 = String::<span class="keyword">new</span>;</span><br><span class="line">System.out.println(strFunction2.apply(<span class="string">"bb"</span>));<span class="comment">//bb</span></span><br><span class="line"></span><br><span class="line">Function&lt;String, Emp&gt; objFunction1 = (str) -&gt; <span class="keyword">new</span> Emp(str);</span><br><span class="line">System.out.println(objFunction1.apply(<span class="string">"cc"</span>).getName());<span class="comment">//cc</span></span><br><span class="line"></span><br><span class="line">Function&lt;String, Emp&gt; objFunction2 = Emp::<span class="keyword">new</span>;</span><br><span class="line">System.out.println(objFunction2.apply(<span class="string">"dd"</span>).getName());<span class="comment">//dd</span></span><br></pre></td></tr></table></figure>

<p>第一段代码，表示x，为传入参数的类型，也是接口中泛型T，返回的类型也是Integer，调用apply方法，传入Integer的4，做乘法操作，然后返回R的泛型，Integer类型</p>
<p>第二段代码，传入的泛型T是Integer的，返回的泛型R是String的，里面的做的操作是传入的参数x 乘2，然后连接一个dd的字符串，然后的就是泛型R的字符串；</p>
<p>后面的表示创建一个对象的两种方式，分别调用有一个参数的构造方法，和无参的构造方法，返回泛型R对象；对象Emp的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几段代码，可以看出，这个接口，是要传入的泛型T参数，然后做业务操作，然后泛型R；</p>
<p>这个接口的其他的默认方法以及静态方法的解释如下代码所示，就不在写案例测试了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先做传入的Function类型的参数的apply操作，再做当前这个接口的apply操作</span></span><br><span class="line"><span class="comment"> * V表示这个Function类型的参数的传入参数类型，也就是本接口的T类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> before</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先做本接口的apply操作，再做传入的Function类型的参数的apply操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> after</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态方法表示，这个传入的泛型参数T的本身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看下Funtion这个接口的“扩展”的原始类型特化的一些函数接口</p>
<p>IntFunction<R>,IntToDoubleFunction,IntToLongFunction,LongFunction<R>,LongToDoubleFunction,LongToIntFunction,DoubleFunction<R>,ToIntFunction<T>,ToDoubleFunction<T>,ToLongFunction<T></T></T></T></R></R></R></p>
<p>我们知道，我们在做基础数据处理的时候（eg: Integer i=0; Integer dd= i+1;）,会对基础类型的包装类，进行拆箱的操作，转成基本类型，再做运算处理，拆箱和装箱，其实是非常消耗性能的，尤其是在大量数据运算的时候；这些特殊的Function函数式接口，根据不同的类型，避免了拆箱和装箱的操作，从而提高程序的运行效率</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-15-Java基础：Consumer接口</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-15-Java%E5%9F%BA%E7%A1%80%EF%BC%9AConsumer%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Consumer接口"><a href="#1-Consumer接口" class="headerlink" title="1. Consumer接口"></a>1. Consumer接口</h2><p>Consumer的语义是消费的意思，了解一些消息队列的同学，肯定对这个单词，有一定的理解，我们先看接口的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口，接收一个泛型的参数T，然后调用accept，对这个参数做一系列的操作，没有返回值；看到这里，是不是很懵，下面用一个简单的小例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Consumer&lt;Integer&gt; consumer = x -&gt; &#123;</span><br><span class="line">     <span class="keyword">int</span> a = x + <span class="number">2</span>;</span><br><span class="line">     System.out.println(a);<span class="comment">// 12</span></span><br><span class="line">     System.out.println(a + <span class="string">"_"</span>);<span class="comment">// 12_</span></span><br><span class="line"> &#125;;</span><br><span class="line">consumer.accept(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>调用accept的时候，传入一个泛型T的参数Integer，然后定义参数对一系列操作，然后打印这些值；</p>
<p>只有调用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.accept(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数，控制台才会 有输出；还是很懵？</p>
<p>其实，主要是理解Consumer，消费者，就可以了~主要是对入参做一些列的操作，在stream里，主要是用于forEach；内部迭代的时候，对传入的参数，做一系列的业务操作，没有返回值；</p>
<p>这个接口，只有一个默认方法，看下注释内容，就清楚用法了，就不在写案例解释了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**传入一个Consumer类型的参数，</span></span><br><span class="line"><span class="comment"> * 他的泛型类型，</span></span><br><span class="line"><span class="comment"> * 跟本接口是一致的T，先做本接口的accept操作，</span></span><br><span class="line"><span class="comment"> * 然后在做传入的Consumer类型的参数的accept操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-13-Java基础：函数式接口简介</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-13-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-函数式接口简介"><a href="#1-函数式接口简介" class="headerlink" title="1. 函数式接口简介"></a>1. 函数式接口简介</h2><p>在java8中，lambda表达式所用的接口，必须是函数式接口；</p>
<p>函数式接口的定义：接口中只有一个抽象方法的接口，称为函数式接口；</p>
<p>可以使用@FunctionalInterface注解修饰，对该接口做检查；如果接口里，有多个抽象类，使用该注解，会有语法错误。</p>
<p>在java8中的函数式接口，有很多，比说，无参无返回值的（Runnable接口），有一个参数，无返回值的（Consumer），有多个参数有返回值的（BiFunction）……等等；</p>
<p>根据不用的作用，java8中，内置了4个核心接口</p>
<p>1.Consumer<T>  消费型接口，具体用法实例和介绍如下：</T></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p>2..Supplier<T> 供给型接口，具体用法实例如下</T></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p>3.Function&lt;T,R&gt; 函数型接口，具体介绍如下：</p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p>4.Predicate<T> 断言型接口，或者判断型的接口，具体用法如下</T></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80601495" target="_blank" rel="noopener">《JAVA8 Predicate接口》</a></p>
<p>另外，我还简单列举了一些其他的函数式接口的用法</p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《 JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p>最后我们列举下java8中 java.util.function包下，内置所有的接口简介和表达的意思</p>
<p>1 BiConsumer&lt;T,U&gt;</p>
<p>代表了一个接受两个输入参数的操作，并且不返回任何结果</p>
<p>2 BiFunction&lt;T,U,R&gt;</p>
<p>代表了一个接受两个输入参数的方法，并且返回一个结果</p>
<p>3 BinaryOperator<T></T></p>
<p>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</p>
<p>4 BiPredicate&lt;T,U&gt;</p>
<p>代表了一个两个参数的boolean值方法</p>
<p>5 BooleanSupplier</p>
<p>代表了boolean值结果的提供方</p>
<p>6 Consumer<T></T></p>
<p>代表了接受一个输入参数并且无返回的操作</p>
<p>7 DoubleBinaryOperator</p>
<p>代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</p>
<p>8 DoubleConsumer</p>
<p>代表一个接受double值参数的操作，并且不返回结果。</p>
<p>9 DoubleFunction<R></R></p>
<p>代表接受一个double值参数的方法，并且返回结果</p>
<p>10 DoublePredicate</p>
<p>代表一个拥有double值参数的boolean值方法</p>
<p>11 DoubleSupplier</p>
<p>代表一个double值结构的提供方</p>
<p>12 DoubleToIntFunction</p>
<p>接受一个double类型输入，返回一个int类型结果。</p>
<p>13 DoubleToLongFunction</p>
<p>接受一个double类型输入，返回一个long类型结果</p>
<p>14 DoubleUnaryOperator</p>
<p>接受一个参数同为类型double,返回值类型也为double 。</p>
<p>15 Function&lt;T,R&gt;</p>
<p>接受一个输入参数，返回一个结果。</p>
<p>16 IntBinaryOperator</p>
<p>接受两个参数同为类型int,返回值类型也为int 。</p>
<p>17 IntConsumer</p>
<p>接受一个int类型的输入参数，无返回值 。</p>
<p>18 IntFunction<R></R></p>
<p>接受一个int类型输入参数，返回一个结果 。</p>
<p>19 IntPredicate</p>
<p>：接受一个int输入参数，返回一个布尔值的结果。</p>
<p>20 IntSupplier</p>
<p>无参数，返回一个int类型结果。</p>
<p>21 IntToDoubleFunction</p>
<p>接受一个int类型输入，返回一个double类型结果 。</p>
<p>22 IntToLongFunction</p>
<p>接受一个int类型输入，返回一个long类型结果。</p>
<p>23 IntUnaryOperator</p>
<p>接受一个参数同为类型int,返回值类型也为int 。</p>
<p>24 LongBinaryOperator</p>
<p>接受两个参数同为类型long,返回值类型也为long。</p>
<p>25 LongConsumer</p>
<p>接受一个long类型的输入参数，无返回值。</p>
<p>26 LongFunction<R></R></p>
<p>接受一个long类型输入参数，返回一个结果。</p>
<p>27 LongPredicate</p>
<p>R接受一个long输入参数，返回一个布尔值类型结果。</p>
<p>28 LongSupplier</p>
<p>无参数，返回一个结果long类型的值。</p>
<p>29 LongToDoubleFunction</p>
<p>接受一个long类型输入，返回一个double类型结果。</p>
<p>30 LongToIntFunction</p>
<p>接受一个long类型输入，返回一个int类型结果。</p>
<p>31 LongUnaryOperator</p>
<p>接受一个参数同为类型long,返回值类型也为long。</p>
<p>32 ObjDoubleConsumer<T></T></p>
<p>接受一个object类型和一个double类型的输入参数，无返回值。</p>
<p>33 ObjIntConsumer<T></T></p>
<p>接受一个object类型和一个int类型的输入参数，无返回值。</p>
<p>34 ObjLongConsumer<T></T></p>
<p>接受一个object类型和一个long类型的输入参数，无返回值。</p>
<p>35 Predicate<T></T></p>
<p>接受一个输入参数，返回一个布尔值结果。</p>
<p>36 Supplier<T></T></p>
<p>无参数，返回一个结果。</p>
<p>37 ToDoubleBiFunction&lt;T,U&gt;</p>
<p>接受两个输入参数，返回一个double类型结果</p>
<p>38 ToDoubleFunction<T></T></p>
<p>接受一个输入参数，返回一个double类型结果</p>
<p>39 ToIntBiFunction&lt;T,U&gt;</p>
<p>接受两个输入参数，返回一个int类型结果。</p>
<p>40 ToIntFunction<T></T></p>
<p>接受一个输入参数，返回一个int类型结果。</p>
<p>41 ToLongBiFunction&lt;T,U&gt;</p>
<p>接受两个输入参数，返回一个long类型结果。</p>
<p>42 ToLongFunction<T></T></p>
<p>接受一个输入参数，返回一个long类型结果。</p>
<p>43 UnaryOperator<T><br>接受一个参数为类型T,返回值类型也为T。</T></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-11-Java基础：Lambda表达式简介</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-11-Java%E5%9F%BA%E7%A1%80%EF%BC%9ALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>在《java8实战》这本书中，对Lambda的解释如下：</p>
<p>可以把Lambda表达式理解为简洁的表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表，函数主体，返回类型，可能还有一个可以抛出的异常列表。</p>
<p> java中，引入了一个新的操作符“-&gt;”，该操作符在很多资料中，称为箭头操作符，或者lambda操作符；箭头操作符将lambda分成了两个部分：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">左侧：<span class="built_in">lambda</span>表达式的参数列表</span><br><span class="line"></span><br><span class="line">右侧：<span class="built_in">lambda</span>表达式中所需要执行的功能，即<span class="built_in">lambda</span>函数体</span><br></pre></td></tr></table></figure>

<h3 id="1-1-无参数无返回值"><a href="#1-1-无参数无返回值" class="headerlink" title="1.1 无参数无返回值"></a>1.1 无参数无返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLambda</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"hello lambda"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"hello lambda"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-有一个参数无返回值"><a href="#1-2-有一个参数无返回值" class="headerlink" title="1.2 有一个参数无返回值"></a>1.2 有一个参数无返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一个参数的情况下可以省略“（）”</span></span><br><span class="line">    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">    con.accept(<span class="string">"有一个参数，无返回值的用法（Consumer函数式接口）"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常可以将<code>(x)</code>写成<code>x</code>，也即去掉小括号。</p>
<h3 id="1-3-有两个参数有返回值"><a href="#1-3-有两个参数有返回值" class="headerlink" title="1.3 有两个参数有返回值"></a>1.3 有两个参数有返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BinaryOperator&lt;Integer&gt; binary = (x, y) -&gt; x + y;</span><br><span class="line">    System.out.println(binary.apply(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带返回值的情况，通常会默认有一个return。</p>
<h3 id="1-4-lambda函数体"><a href="#1-4-lambda函数体" class="headerlink" title="1.4 lambda函数体"></a>1.4 lambda函数体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 无返回值lambda函数体中用法</span></span><br><span class="line">    Runnable r1 = () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello lambda1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello lambda2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"hello lambda3"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    r1.run();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有返回值lambda函数体中用法</span></span><br><span class="line">    BinaryOperator&lt;Integer&gt; binary = (x, y) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> a = x * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> b = y + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(binary.apply(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，多行的，只需要用大括号{}把语句包含起来就可以了；有返回值和无返回值的，只有一个return的区别；只有一条语句的，大括号和renturn都可以不用写；</p>
<h3 id="1-5-lambda的类型推断"><a href="#1-5-lambda的类型推断" class="headerlink" title="1.5 lambda的类型推断"></a>1.5 lambda的类型推断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BinaryOperator&lt;Integer&gt; binary = (Integer x, Integer y) -&gt; x + y;</span><br><span class="line">    System.out.println(binary.apply(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在lambda中的参数列表，可以不用写参数的类型，跟java7中 new ArrayList&lt;&gt;(); 不需要指定泛型类型，这样的&lt;&gt;棱形操作符一样，根据上下文做类型的推断</p>
<h2 id="2-Lambda函数接口特点"><a href="#2-Lambda函数接口特点" class="headerlink" title="2. Lambda函数接口特点"></a>2. Lambda函数接口特点</h2><p>lamabd表达式中，需要有函数式接口的支持；</p>
<p>函数式接口定义：接口中只有一个抽象方法的接口，称为函数式接口；</p>
<p>可以使用@FunctionalInterface注解修饰，对该接口做检查；如果接口里，有多个抽象类，使用该注解，会有语法错误</p>
<p>比如在常用的接口<code>Consumer</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-12-Java基础：lambda表达式，方法的引用以及构造器的引用</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-12-Java%E5%9F%BA%E7%A1%80%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>在前面有讲述过lambda表达式中，使用的都是函数式接口；关于lambda表达式简介<a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a>；关于函数式接口<a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a>；</p>
<p>这篇主要是讲，在lambda表达式中，使用方法的引用，来传递方法方法的行为参数化；</p>
<h3 id="1-1-方法的引用"><a href="#1-1-方法的引用" class="headerlink" title="1.1 方法的引用"></a>1.1 方法的引用</h3><p>方法的引用，在《java8实战》介绍如下：</p>
<p>方法的引用让你可以重复使用现有的方法定义，并像lambda一样传递他们，在一些情况下，比起使用lambda表达式，它们似乎更易读，感觉也更自然；</p>
<p>方法的引用的语法，主要有三类</p>
<p><strong>1.指向静态方法的方法引用</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="title">类::</span>静态方法名</span><br></pre></td></tr></table></figure>

<p>例如<code>Integer</code>的<code>parseInt</code>方法 ，可以写成<code>Integer::parseInt</code></p>
<p><strong>2.指向任意类型实例方法的方法引用</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="title">类::</span>实例方法名</span><br></pre></td></tr></table></figure>

<p>例如<code>String</code>的<code>length</code>方法，写成<code>String::length</code></p>
<p><strong>3.指向现有对象的实例方法的方法引用</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="title">对象::</span>实例方法名</span><br></pre></td></tr></table></figure>



<h3 id="1-2-构造器的引用"><a href="#1-2-构造器的引用" class="headerlink" title="1.2 构造器的引用"></a>1.2 构造器的引用</h3><p>构造器的引用：对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ClassName::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<p>在java8中的函数式接口，提供了，无参构造函数，以及有参构造函数创建实例的方式；构造器的参数列表，需要与函数式接口中参数列表保持一致！</p>
<h3 id="1-3-具体案例"><a href="#1-3-具体案例" class="headerlink" title="1.3 具体案例"></a>1.3 具体案例</h3><p>下面，我们用个小案例，来演示方法的引用以及构造器的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLambda2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*************** 方法的引用 ****************/</span></span><br><span class="line">        <span class="comment">// 类::静态方法名</span></span><br><span class="line">        <span class="comment">// 简单方式</span></span><br><span class="line">        Comparator&lt;Integer&gt; caml1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer x, Integer y)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> x.compareTo(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(caml1.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// lambda方式</span></span><br><span class="line">        Comparator&lt;Integer&gt; caml2 = (x, y) -&gt; x.compareTo(y);</span><br><span class="line">        System.out.println(caml2.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">// lambda方式改进</span></span><br><span class="line">        Comparator&lt;Integer&gt; cam3 = Integer::compareTo;</span><br><span class="line">        System.out.println(cam3.compare(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类::实例方法名</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; bp1 = <span class="keyword">new</span> BiPredicate&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.equals(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(bp1.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line">        BiPredicate&lt;String, String&gt; bp2 = (s, s2) -&gt; s.equals(s2);</span><br><span class="line">        System.out.println(bp2.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line">        BiPredicate&lt;String, String&gt; bp3 = String::equals;</span><br><span class="line">        System.out.println(bp3.test(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象::实例方法名</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">"abc"</span>);</span><br><span class="line">        Consumer&lt;String&gt; con2 = x -&gt; System.out.println(x);</span><br><span class="line">        con2.accept(<span class="string">"abc"</span>);</span><br><span class="line">        Consumer&lt;String&gt; con3 = System.out::println;</span><br><span class="line">        con3.accept(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        Emp emp = <span class="keyword">new</span> Emp(<span class="string">"上海"</span>, <span class="string">"xiaoMing"</span>, <span class="number">18</span>);</span><br><span class="line">        Supplier&lt;String&gt; supper1 = <span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> emp.getAddress();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supper1.get());</span><br><span class="line">        Supplier&lt;String&gt; supper2 = () -&gt; emp.getAddress();</span><br><span class="line">        System.out.println(supper2.get());</span><br><span class="line">        Supplier&lt;String&gt; supper3 = emp::getAddress;</span><br><span class="line">        System.out.println(supper3.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//************************构造器的引用******************</span></span><br><span class="line">        <span class="comment">// 无参构造函数，创建实例</span></span><br><span class="line">        Supplier&lt;Emp&gt; supper4 = <span class="keyword">new</span> Supplier&lt;Emp&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Emp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Supplier&lt;Emp&gt; supper5 = () -&gt; <span class="keyword">new</span> Emp();</span><br><span class="line">        Supplier&lt;Emp&gt; supper6 = Emp::<span class="keyword">new</span>;</span><br><span class="line">        Emp emp1 = supper4.get();</span><br><span class="line">        emp1.setAddress(<span class="string">"上海"</span>);</span><br><span class="line">        <span class="comment">// 一个参数</span></span><br><span class="line">        Function&lt;String, Emp&gt; fun1 = <span class="keyword">new</span> Function&lt;String, Emp&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">apply</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Emp(address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Function&lt;String, Emp&gt; fun2 = address -&gt; <span class="keyword">new</span> Emp(address);</span><br><span class="line">        Function&lt;String, Emp&gt; fun3 = Emp::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(fun3.apply(<span class="string">"北京"</span>));</span><br><span class="line">        <span class="comment">// 两个参数</span></span><br><span class="line">        BiFunction&lt;String, Integer, Emp&gt; bFun1 = <span class="keyword">new</span> BiFunction&lt;String, Integer, Emp&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">apply</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Emp(name, age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        BiFunction&lt;String, Integer, Emp&gt; bFun2 = (name, age) -&gt; <span class="keyword">new</span> Emp(name, age);</span><br><span class="line">        BiFunction&lt;String, Integer, Emp&gt; bFun3 = Emp::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(bFun3.apply(<span class="string">"张三"</span>, <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String address, String name, Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Emp [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，特别要注意：</p>
<p>①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！</p>
<p>②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-1-Java基础：Stream流的创建方式</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-1-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%B5%81%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h2 id="1-创建Stream接口的方式"><a href="#1-创建Stream接口的方式" class="headerlink" title="1.创建Stream接口的方式"></a>1.创建Stream接口的方式</h2><p>前面（<a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a>），我们已经对stream这个接口，做了简单的介绍，下面，我们用几个案例，来看看流的几种创建方式</p>
<h3 id="1-1-Arrays-stream创建"><a href="#1-1-Arrays-stream创建" class="headerlink" title="1.1 Arrays.stream创建"></a>1.1 Arrays.stream创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] dd = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        <span class="comment">// Arrays中的静态方法stream</span></span><br><span class="line">        Arrays.stream(dd).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中静态方法<code>stream</code>定义如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="built_in">Stream</span>&lt;T&gt; stream(T[] <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> stream(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-Stream-of创建"><a href="#1-2-Stream-of创建" class="headerlink" title="1.2 Stream.of创建"></a>1.2 Stream.of创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] dd = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        <span class="comment">// Stream中的静态方法of</span></span><br><span class="line">        Stream.of(dd).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中静态方法<code>of</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>) <span class="comment">// Creating a stream from an array is safe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以传入一个泛型数组或者多个参数，创建一个流。其内部实际上调用的是<code>Arrays.stream(values)</code></p>
<h3 id="1-3-Collection-stream创建"><a href="#1-3-Collection-stream创建" class="headerlink" title="1.3 Collection.stream创建"></a>1.3 Collection.stream创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] dd = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        <span class="comment">// 使用Collection中的stream方法,所以Collection的子类Set，List，Map，SortedSet 都可以这样用</span></span><br><span class="line">        Arrays.asList(dd).stream().forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>Arrays.asList(dd)</code>,可以将一个数组转换为<code>List</code>。<code>stream()</code>方法是<code>Collection</code>中的方法，<code>List</code>是<code>Collection</code>的子类。定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-Stream-iterate创建"><a href="#1-4-Stream-iterate创建" class="headerlink" title="1.4 Stream.iterate创建"></a>1.4 Stream.iterate创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] dd = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        <span class="comment">// Stream接口中的静态方法</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, x-&gt;x+<span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中方法<code>iterate(0, x-&gt;x+1)</code>通过名字可以发现使用的是迭代器的形式创建一个数据流。该方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为：</span></span><br><span class="line"><span class="comment"> * seed：初始化元素</span></span><br><span class="line"><span class="comment"> * f： 一个函数，可以将初始化元素生成一个新的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(f);</span><br><span class="line">    <span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T t = (T) Streams.NONE;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> t = (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class="line">            iterator,</span><br><span class="line">            Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>UnaryOperator</code>是<code>Function</code>的子类（不知道这个接口的，<a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">JAVA8 UnaryOperator接口</a>，有详细介绍）。<code>x-&gt;x+1</code>调用的是<code>Function</code>类中的<code>apply</code>方法，输入的是<code>x</code>，输出的是<code>x+1</code>。从迭代器hasNext中，可以看到，返回一直为true，表示迭代器，会一直执行下去，创建的数据集合的值为泛型T对象； 这样一直创建无限个对象的流，也成为无限流；<strong>上面的<code>limit(10)</code>是为了限制这个无限流的长度为10</strong></p>
<h3 id="1-5-Stream-generate创建"><a href="#1-5-Stream-generate创建" class="headerlink" title="1.5 Stream.generate创建"></a>1.5 Stream.generate创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] dd = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">        <span class="comment">// Stream接口中的静态方法，</span></span><br><span class="line">        Stream.generate(()-&gt;<span class="string">"x"</span>).limit(<span class="number">10</span>).forEach(System.out::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法<code>generate</code>定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(s);</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(</span><br><span class="line">                <span class="keyword">new</span> StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从静态方法定义中，可以看到，传入一个函数式接口Supplier（不知道这个接口是什么意义的，可以移步这边，<a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">JAVA8 Supplier接口</a>有详细介绍）；这个静态方法，也是无限生成对象的集合流，也是一个无限流；其中长度便是上面源码中的<code>Long.MAX_VALUE</code>。因此也采取了限流措施<code>limit(10)</code>。</p>
<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><p>应用场景：我们再做B端系统的时候，会遇到很多的统计类的需求，会用到百度的echarts插件，比如曲线图，在x抽，固定的况下（按月统计 1号-31号，或者按年统计1月-12月，或者按天24个小时的刻度），那么我就需要创建一个这个数组，或者集合，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(buildList(<span class="number">100</span>));</span><br><span class="line">		System.out.println(buildIterate(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">buildList</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">			list.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">buildIterate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Stream.iterate(<span class="number">1</span>, x -&gt; ++x).limit(size).collect(Collectors.toList());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用流，可以更加简便，也更加直观的表现出代码的功能</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p>4.其他部分</p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">java8 Stream-创建流的几种方式</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-10-Java基础：Optional静态类简介，以及用法</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-10-Java%E5%9F%BA%E7%A1%80%EF%BC%9AOptional%E9%9D%99%E6%80%81%E7%B1%BB%E7%AE%80%E4%BB%8B%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-Optional静态类简介，以及用法"><a href="#1-Optional静态类简介，以及用法" class="headerlink" title="1. Optional静态类简介，以及用法"></a>1. Optional静态类简介，以及用法</h2><p>在java8中，很多的stream的终端操作，都返回了一个Optional<T>对象，这个对象，是用来解决空指针的问题，而产生的一个类；我们先看下，这个类的一些定义</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"No value present"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">			consumer.accept(value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(predicate);</span><br><span class="line">		<span class="keyword">if</span> (!isPresent())</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(mapper);</span><br><span class="line">		<span class="keyword">if</span> (!isPresent())</span><br><span class="line">			<span class="keyword">return</span> empty();</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(mapper);</span><br><span class="line">		<span class="keyword">if</span> (!isPresent())</span><br><span class="line">			<span class="keyword">return</span> empty();</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Optional)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;</span><br><span class="line">		<span class="keyword">return</span> Objects.equals(value, other.value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hashCode(value);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value != <span class="keyword">null</span> ? String.format(<span class="string">"Optional[%s]"</span>, value) : <span class="string">"Optional.empty"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些定义，我把java的源代码，去掉了注释，所展示的部分，我们可以看下，这个类，有两个构造方法，以及三个静态方法</p>
<p>如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法被私有化，外部不能直接创建这个对象，静态方法中，也提供了实例化这个类的三个静态方法，</p>
<p>第一个是empty方法，直接返回一个类加载后就创建的一个空的optional对象，</p>
<p>第二个是of(T value)方法，可以看到，直接new了一个optional对象；</p>
<p>第三个是ofNullable(T value)方法，可以看到，这个方法，先对传入的泛型对象，做了null的判断，为null的话，返回第一个静态方法的空对象；</p>
<p>创建完optional对象后，我们来看下，取到这个泛型对象的几个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"No value present"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，有4种取泛型参数的方式；</p>
<p>1.get()直接取，如果为null，就返回异常</p>
<p>2.orElse(T other)在取这个对象的时候，设置一个默认对象（默认值）；如果当前对象为null的时候，就返回默认对象</p>
<p>3.orElseGet(Supplier&lt;? extends T&gt; other)跟第二个是一样的，区别只是参数，传入了一个函数式参数；</p>
<ol start="4">
<li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)第四个，跟上面表达的是一样的，为null的时候，返回一个特定的异常；</li>
</ol>
<p>下面，我们再看下，剩下的几个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isPresent()是对当前的value进行null判断</p>
<p>ifPresent(Consumer&lt;? super T&gt; consumer)具体的意思，可以参看<a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a>，理解了consumer接口，也就理解了这个方法；</p>
<p>filter(Predicate&lt;? super T&gt; predicate)，map(Function&lt;? super T, ? extends U&gt; mapper) ，flatMap(Function&lt;? super T, Optional<U>&gt; mapper) 这几个方法的应用，可以参看我的<a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a>，跟stream的上的方法，用法是一致的，没有区别；</U></p>
<p>最后，我们用几个案例，来演示一下，这个类的使用方式，大家自己观看代码，就不做解释了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">		Emp emp = <span class="keyword">new</span> Emp(<span class="string">"xiaoMing"</span>, <span class="string">"上海"</span>, <span class="string">"11"</span>);</span><br><span class="line">		Optional&lt;Emp&gt; op = Optional.ofNullable(emp);</span><br><span class="line">		System.out.println(op.get().getAddress());<span class="comment">// 上海</span></span><br><span class="line">		Optional&lt;Emp&gt; op1 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">		System.out.println(op1.orElse(emp).getAddress());<span class="comment">// 上海</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这里指定了一个默认对象emp，为先创建的一个emp对象，emp对象里的成员变量还没有复制，所以输出为null</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.out.println(op1.orElseGet(Emp::<span class="keyword">new</span>).getAddress());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(op1.orElseThrow(RuntimeException::<span class="keyword">new</span>));<span class="comment">// java.lang.RuntimeException</span></span><br><span class="line"> </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(op1.get().getAddress());<span class="comment">// java.util.NoSuchElementException</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String address = op.filter(obj -&gt; obj.getAddress().equals(<span class="string">"上海"</span>)).map(str -&gt; str.getAddress()).get();</span><br><span class="line">		System.out.println(address);<span class="comment">// 上海</span></span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">private</span> String age;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(String name, String address, String age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.address = address;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> address;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.address = address;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> age;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-5-Java8新特性-0-Java基础：Stream流介绍</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-5-Java8%E6%96%B0%E7%89%B9%E6%80%A7-0-Java%E5%9F%BA%E7%A1%80%EF%BC%9AStream%E6%B5%81%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Stream接口简介"><a href="#1-Stream接口简介" class="headerlink" title="1. Stream接口简介"></a>1. Stream接口简介</h2><p>首先我们先来认识下一个的接口的意思，流是什么？</p>
<p>流是java API中的新的成员，它可以让你用声明式的方式处理集合，简单点说，可以看成遍历数据的一个高级点的迭代器，也可以看做一个工厂，数据处理的工厂，当然，流还天然的支持并行操作；也就不用去写复杂的多线程的代码，下面我先来看下stream的接口定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stream</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BaseStream</span>&lt;<span class="title">T</span>, <span class="title">Stream</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">IntStream <span class="title">flatMapToInt</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends IntStream&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">LongStream <span class="title">flatMapToLong</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends LongStream&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">DoubleStream <span class="title">flatMapToDouble</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends DoubleStream&gt; mapper)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line"> </span><br><span class="line">	Object[] toArray();</span><br><span class="line"> </span><br><span class="line">	&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line"> </span><br><span class="line">	<span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line"> </span><br><span class="line">	&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Builder&lt;T&gt; <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Streams.StreamBuilderImpl&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(Spliterators.&lt;T&gt; emptySpliterator(), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> Streams.StreamBuilderImpl&lt;&gt;(t), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@SafeVarargs</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>) <span class="comment">// Creating a stream from an array is safe</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(f);</span><br><span class="line">		<span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">			<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">			T t = (T) Streams.NONE;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> t = (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(</span><br><span class="line">				Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(s);</span><br><span class="line">		<span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> StreamSpliterators.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s),</span><br><span class="line">				<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(a);</span><br><span class="line">		Objects.requireNonNull(b);</span><br><span class="line"> </span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		Spliterator&lt;T&gt; split = <span class="keyword">new</span> Streams.ConcatSpliterator.OfRef&lt;&gt;((Spliterator&lt;T&gt;) a.spliterator(),</span><br><span class="line">				(Spliterator&lt;T&gt;) b.spliterator());</span><br><span class="line">		Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());</span><br><span class="line">		<span class="keyword">return</span> stream.onClose(Streams.composedClose(a, b));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"> </span><br><span class="line">		<span class="function"><span class="keyword">default</span> Builder&lt;T&gt; <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">			accept(t);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="function">Stream&lt;T&gt; <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过接口定义，可以看到，抽象方法，有30多个，里面还有一些其他的接口；后续，我会慢慢给大家介绍，每个抽象方法的作用，以及用法</p>
<p><strong>1.lambda表达式</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80961022" target="_blank" rel="noopener">《java8 Lambda表达式简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80963351" target="_blank" rel="noopener">《java8 lambda表达式，方法的引用以及构造器的引用》</a></p>
<p><strong>2.函数式接口</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80962325" target="_blank" rel="noopener">《java8 函数式接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80615629" target="_blank" rel="noopener">《JAVA8 Function接口以及同类型的特化的接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80618456" target="_blank" rel="noopener">《JAVA8 Consumer接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80625482" target="_blank" rel="noopener">《JAVA8 Supplier接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634319" target="_blank" rel="noopener">《JAVA8 UnaryOperator接口》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80704487" target="_blank" rel="noopener">《JAVA8 BiConsumer 接口》</a></p>
<p><strong>3.stream接口操作</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633292" target="_blank" rel="noopener">《java8 Stream接口简介》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80633710" target="_blank" rel="noopener">《 java8 Stream-创建流的几种方式》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80634725" target="_blank" rel="noopener">《JAVA8 stream接口 中间操作和终端操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80642786" target="_blank" rel="noopener">《JAVA8 Stream接口，map操作，filter操作，flatMap操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80643711" target="_blank" rel="noopener">《JAVA8 stream接口 distinct，sorted，peek，limit，skip》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80782808" target="_blank" rel="noopener">《java8 stream接口 终端操作 forEachOrdered和forEach》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783286" target="_blank" rel="noopener">《java8 stream接口 终端操作 toArray操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口 终端操作 min，max，findFirst，findAny操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80783946" target="_blank" rel="noopener">《java8 stream接口终端操作 count，anyMatch，allMatch，noneMatch》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80873910" target="_blank" rel="noopener">《java8 srteam接口终端操作reduce操作》</a></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/81052881" target="_blank" rel="noopener">《java8 stream接口 终端操作 collect操作》</a></p>
<p><strong>4.其他部分</strong></p>
<p><a href="https://blog.csdn.net/qq_28410283/article/details/80952768" target="_blank" rel="noopener">《java8 Optional静态类简介，以及用法》</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-迭代器之ListIterator使用注意</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B9%8BListIterator%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>首先需要知道ListIterator接口是继承了Iterator接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在List集合中有对该接口的具体实现。（只有List集合实现了，所以Map、Set中没有的）</p>
<p>说明两者的相同点和区别</p>
<p><strong>相同点</strong>：</p>
<blockquote>
<ul>
<li>都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。 </li>
</ul>
</blockquote>
<p><strong>区别</strong>：</p>
<blockquote>
<ul>
<li><strong>使用范围不同</strong>，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。 </li>
<li>ListIterator有add方法，可以向List中添加对象，而Iterator不能。 </li>
<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。 </li>
<li>ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 </li>
<li>虽然两者都可以删除，但是ListIterator还可以进行修改。</li>
</ul>
</blockquote>
<h2 id="2-实例说明"><a href="#2-实例说明" class="headerlink" title="2. 实例说明"></a>2. 实例说明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个list</span></span><br><span class="line">    List&lt;String&gt; staff = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    staff.add(<span class="string">"测试1"</span>);</span><br><span class="line">    staff.add(<span class="string">"测试2"</span>);</span><br><span class="line">    staff.add(<span class="string">"测试3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ListIterator对象</span></span><br><span class="line">    ListIterator&lt;String&gt; iter = staff.listIterator();</span><br><span class="line">    String first = iter.next();</span><br><span class="line">    String second = iter.next();</span><br><span class="line">    System.out.println(<span class="string">"第一个为： "</span>+first);</span><br><span class="line">    System.out.println(<span class="string">"第二个为： "</span>+second);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 可以往list添加元素,Iterator不行</span></span><br><span class="line">    iter.add(<span class="string">"张三"</span>);</span><br><span class="line">    System.out.println(<span class="string">"增加元素后的集合为："</span>+staff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 有hasPrevious()用于判断前面是否还有元素</span></span><br><span class="line">    <span class="comment">//   有previous()获取前面一个元素</span></span><br><span class="line">    System.out.println(<span class="string">"前面有元素吗？："</span>+iter.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">"前面一个元素为："</span>+iter.previous());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 定位当前索引位置，有nextIndex()和previoisIndex()</span></span><br><span class="line">    System.out.println(<span class="string">"后一个元素索引："</span>+iter.nextIndex());</span><br><span class="line">    System.out.println(<span class="string">"前一个元素索引："</span>+iter.previousIndex());</span><br><span class="line"></span><br><span class="line">    iter.set(<span class="string">"王五"</span>);</span><br><span class="line">    System.out.println(<span class="string">"修改后的元素为："</span>+staff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">第一个为： 测试<span class="number">1</span></span><br><span class="line">第二个为： 测试<span class="number">2</span></span><br><span class="line">增加元素后的集合为：[测试<span class="number">1</span>, 测试<span class="number">2</span>, 张三, 测试<span class="number">3</span>]</span><br><span class="line">前面有元素吗？：<span class="literal">true</span></span><br><span class="line">前面一个元素为：张三</span><br><span class="line">后一个元素索引：<span class="number">2</span></span><br><span class="line">前一个元素索引：<span class="number">1</span></span><br><span class="line">修改后的元素为：[测试<span class="number">1</span>, 测试<span class="number">2</span>, 王五, 测试<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-迭代器之Iterator使用注意</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B9%8BIterator%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在Java集合中常常会使用到迭代器Iterator，并且我们知道Collection接口也继承了Iterator接口，所以只要是Collection的实现类，那么一定具备有迭代器功能。通过迭代器，开发人员不需要了解容器底层的结构，就可以实现对容器的遍历。由于创建迭代器的代价小，因此迭代器通常称为轻量级容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看ArrayList中对Iterator实现</p>
<p>（1）在ArrayList中存在如下方法，用于放回一个Iterator对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在ArrayList内部类中存在下面三个主要方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断容器中是否还有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 删除迭代器返回的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用lambda表达式迭代 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span></span></span><br></pre></td></tr></table></figure>

<p>对于最后一个方式，这里举一个例子说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"zhangsan"</span>);</span><br><span class="line">    list.add(<span class="string">"lisi"</span>);</span><br><span class="line">    list.add(<span class="string">"wangwu"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    iterator.forEachRemaining(data-&gt;&#123;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-问题提出"><a href="#2-问题提出" class="headerlink" title="2. 问题提出"></a>2. 问题提出</h2><p>经常有一个说法：<span style="color:red"><strong>使用Iterator遍历容器时不能对容器做增加或删除操作</strong></span></p>
<p>否则将报一个异常：<code>ConcurrentModificationException</code></p>
<p>【注意】增强for是jdk1.5提出，其内部实现原理仍然是一个迭代器。</p>
<h2 id="3-问题探究"><a href="#3-问题探究" class="headerlink" title="3. 问题探究"></a>3. 问题探究</h2><p>【案例1】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s: list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"3"</span>.equals(s))&#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面的学习，可以知道这段代码一定有问题的，违背了前面的规则。但是当运行代码的时候，输出结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClB9xcW7hkVEL81W2vDnCP75P3vE9KjZFjp0stgReicxMrJeplNEX6FKw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>结果傻眼了，居然正常输出没有报错，而且结果还是正确的！于是我又改动了一下代码</p>
<p>【代码修改1】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    <span class="comment">// 在“3”的前面添加一个“2”</span></span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s: list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"3"</span>.equals(s))&#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClX3TkTA4snvrkYVaxSrxKlfPcpVYfmbfJkzyboBKBZXQBARMDpU6bQg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>发现结果还是正确的。</p>
<p>【代码修改2】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line">    <span class="comment">// 在“3”的后面添加“4”</span></span><br><span class="line">    list.add(<span class="string">"4"</span>);</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String s: list)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"3"</span>.equals(s))&#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClQZnmuACZCgajcJPO133iczS1g44WPjrn5PcUAAbY1pcvjwnHlbpNuqQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>这一次终于出现了期待已久的报错。</p>
<h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><h3 id="4-1-基本问题分析"><a href="#4-1-基本问题分析" class="headerlink" title="4.1 基本问题分析"></a>4.1 基本问题分析</h3><p>在控制台打印的日志显示，在 <code>java.util.ArrayList$Itr.next()</code>内部的 <code>checkForComodification()</code>方法。定位到ArrayList源码指定位置，如下图标识红框位置：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClNQ5m1D9u4RFvYP9dBQ8s6fPSHKJyaVf7zwTQYJvB96D7E1G0SCtx5g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>这个方法的逻辑非常简单。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClWWY13rQr3Cj1ayX6cJPpKXDjRhrhC7Ht9wURPPYzqp67dThW5IRAjA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>那<code>modCount</code>和<code>expectedModCount</code>又是何方神圣？跟着来到定义他们的地方。熟悉ArrayList源码的就可以知道<code>modCount</code>和<code>expectedModCount</code>通常是为了防止在多线程情况下，一个线程使用迭代器遍历容器，与此同时另一个线程对这个容器进行增加或者删除操作。当这两个变量不一致时，就会报一个<code>ConcurrentModificationException</code>异常。</p>
<h3 id="4-2-分步调试"><a href="#4-2-分步调试" class="headerlink" title="4.2 分步调试"></a>4.2 分步调试</h3><p>首先在ArrayList中的内部类Ite类处打上两处debug调试点。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClzcrTudJW4NJr4Fl2W6KlA2Pr7mHQ1MZRDlibEssvDBJ4GicJNNGL1n1A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>我们就以开头的那三个例子最后一个报错的为例，开始debug。</p>
<p>刚开始list添加了5个元素，size等于5。由前面得知，add操作属于结构性操作，会导致 <code>modCount++</code>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClwP1tNqp4HEdyZGgs87sHPIjrGibcoyD7uhoTeMiacwictn62GBcnLPqlA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>Itr迭代器的游标cursor值会从0开始随着元素的遍历移动。hasNext()通过判断 <code>cursor!=size</code>来确定list是否还有下一个元素取出。如果返回true，则会进入next()用来返回下一个元素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zCl2uaCwxiakKw3Es5GkI1U5k9BurFNaibgL39icXsSPcK5yEZEm4aF7xd3A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>显然我们有5个元素，可以进入next()。而在next方法中，第一行代码就是checkForComodification()用来校验expectedModCount和modCount的一致性。显然从List添加完元素到现在为止，我们没有再对list有过额外的结构性操作，自然前面3次迭代都不会抛出异常，正常返回元素。都如图所示。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClXyEN5uOVxhduKW84MObsEFTxqZZgVZoKR6cBOcicc7M9Hy05DoxZaqQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>并且每次执行完next()后，cursor会往后移动一位，为迭代下一个元素做准备。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClg37auZ3y4YzGebibwUZOzrF0BQMsOOeAGPPcgrfJdswnTlgicPw3mkKQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>这个时候轮到迭代第三个元素”3”了。自然if条件判断成立，会进入删除操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClRyEAtPrA9ebvLicvas9J1HJmMe3VPicJFXgIDCqqxps5yOKpsx39QPUA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>跟进remove()方法源码中，确实发现了 <code>modCount++</code>。也就是说，这个时候modCount值已经变成6了。而expectedModCount依然还是保存着初始值5。此时两者不一致了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClzZdfLbYl1KBOtPOeV4jjqTQPoWW5eUnicFsTDxNyb0E63kxfG92XhDw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClHBpcHyp8vyq4glia1Dg3FZpInnyDmzLUJkLp1EDT5mfnEovibCuwZia9w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>因为list在“3”之后还有“4”，“5”两个元素，因此当删除“3”元素之后，迭代器还会继续迭代，重复之前的流程，会先进入hasNext()，此时cursor等于3，size等于4，自然还是满足的，所以还是会继续进入next()取出下一个元素。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClice2e1XEYVkibchDPtEO39ukXZdy0gmpnPlETVfm6FdYLJXm5uzAABjQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>可以预料此时checkForComodification()校验expectedModCount和modCount已经不一致了，所以抛出了ConcurrentModificationException。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zCl807mIgj0zmPsl3v3Tnj2QaUqIPAAge773ltXj5kcexjcDb2HjfXWcg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h3 id="4-3-初步总结"><a href="#4-3-初步总结" class="headerlink" title="4.3 初步总结"></a>4.3 初步总结</h3><p>也就是说，在forEach或者迭代器中调用对集合的结构性操作会导致modCount值发生修改，而expectedModCount的值仍然是初始化值，所以在next()中校验不通过抛出异常。所以应该使用迭代器的删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line">    list.add(<span class="string">"4"</span>);</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"3"</span>.equals(it.next()))&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是老师教的正确姿势。结果当然是正确的。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClgLxbAZpUOLzEIgKmomePPz4MokJ7TF00l80Qr5MSB2HeEmU6C1G4tQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h3 id="4-4-再探虎穴"><a href="#4-4-再探虎穴" class="headerlink" title="4.4 再探虎穴"></a>4.4 再探虎穴</h3><p>要搞清楚这中间的区别，当然还是需要深入虎穴，再去看看List迭代器remove方法的源码了。下面代码中主要关注红框的2行，第一行作用是删除被迭代的元素， <code>ArrayList.this.remove</code>这个是调用外部类ArrayList的remove方法，上面已经说过了，集合的remove方法是结构性操作，会导致modCount++的，这样等迭代下一个元素时，调用next()时校验expectedModCount和modCount一致性必然会报错，为了防止这个问题，所以下一行 <code>expectedModCount=modCount</code>将expectedModCount更新至modCount最新值，使得一致性不被破坏。这也是为什么使用迭代器自带的remove方法并不会抛出异常的原因。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zCldic7rY1Qc4NbGPYEuOeNEDL6lfcibowl0G9va2UH12EVUBUTqEI6tlMw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>怎么样？是不是感觉大功告成了，感觉自己要飘了……</p>
<p>然而，这只是解释了文章开头3个例子的最后一个，那为什么前两个可以正常删除没有报错？说实话，我当时遇到这问题的内心是崩溃到怀疑人生的。</p>
<p>还是没有好的办法，继续来debug一下前面的例子，看看会有什么不同的事情发生吧。</p>
<p>List中前面的元素的遍历过程和上面是一样的，不再赘述。直接看关键处，如下图，这个时候已经遍历到“3”这个元素了，即将开始remove操作，remove操作也和上面一样，会调用fastRemove()删除元素，fastRemove()也确实会执行 <code>modCount++</code>，确实导致了 <code>expectedModCount!=modCount</code>。但是……</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClUjicIjyibowIeuBfbkznglbtcUAX78V1jjwufpvpLnial1RUToFUcK1iaQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>当将要迭代下一个元素的时候，还是会进入hashNext()做判断，很遗憾，这个时候cursor和size都是2，也就是hashNext()条件不成立返回false，也就不会再进入next()方法，自然也就不会再去调用checkForComodification()做校验，也就不会再有机会抛异常了。其实这个时候，list中最后一个元素”5”根本也就没遍历到。为了验证这一点，可以在for循环中添加输出代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Object o: list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"3"</span>.equals(s)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现只会输出1和3。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClFI8tBAcNa7bLZPwYgSFiaG68Oj9xCvIW3Uk9LaVuLcnMNQh4gqIfnbw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>事情还没完，最后再来一种情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"1"</span>);</span><br><span class="line">    list.add(<span class="string">"2"</span>);</span><br><span class="line">    list.add(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Object o: list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"3"</span>.equals(s)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>猜猜结果是啥？有人会认为，不是和文章第一个例子一模一样的吗？那就是成功删除了啊，输出1和2啊。呵呵🙄，让您失望了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zClrk0j0qYXwgiceQqOdtCx7nkOeHDwaX32XwQPLsGdojMkZJXEko2h62w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>是不是又怀疑人生了？其实有了前面这么多的铺垫，这个错误原因已经不难推断发现了。</p>
<p>原因还是在这里。前面“1”，“2”两个元素遍历完毕肯定是没问题的，当开始遍历“3”时候，通过next()返回元素“3”，cursor此时会增加到3，而size由于后面会调用remove减为2了，这个时候hasNext()里的条件返回true又成立啦！我的乖乖……所以Itr迭代器又会傻傻的去调用next()，后面的事情就都知道了，checkForComodification()又被调用了，抛出ConcurrentModificationException异常。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/5j8oo6Mib4zLML8teTBKXoz1qu5C01zCl6TKfuic1l3nmAr7RZK2wmGrAWic8YxMKwGaJ63evcOzF77NvMdNMayuA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>其实通过上述的整个分析过程，可以总结出一点结论：其实整个过程的问题关键所在就是 <code>java.util.ArrayList$Itr</code>的hasNext()方法的逻辑。不难看出，每当迭代器返回一个元素时，元素在列表中的索引等于Itr的cursor值，而每次删除一个元素会导致 <code>size--</code>，不难推断出，如果你要删除的元素恰好位于List倒数第二个位置，则并不会抛出异常，并且会显示正确的删除操作，就像文章开头第一个例子，其余情况都会抛出异常。但是就算是不抛异常的情况，其实此时List迭代器内部的expectedModCount 和modCount一致性已经遭到了破坏，只是被掩盖了，所以这样的操作后续可能会有非常大的隐患，个人不建议这样使用，需要在迭代过程操作集合的还是应该用迭代器的方法。</p>
<p>另外，其实除了ArrayList以外，会发现HashMap中也会有modCount属性，而在其相应的结构性操作方法内部，如put()、clear()等都会有对 <code>modCount++</code>操作，而在HashMap内部也有一个内部迭代器HashIterator，内部会维护一个expectedModCount属性，其余的套路就都和ArrayList类似了。</p>
<p>参考资料</p>
<p> <a href="https://mp.weixin.qq.com/s/CfCLUr7DtiTVOowpfZf4DQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/CfCLUr7DtiTVOowpfZf4DQ</a> </p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Set集合面试题</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Set%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-HashSet和TreeSet的区别和适用场景？"><a href="#1-HashSet和TreeSet的区别和适用场景？" class="headerlink" title="1.HashSet和TreeSet的区别和适用场景？"></a>1.HashSet和TreeSet的区别和适用场景？</h2><p><strong>相同点</strong></p>
<p>由于两者都实现Set接口，所以具有Set集合的特点：不能重复（HashSet底层实现是HashMap，TreeSet底层实现是TreeMap。当进行增加操作时，插入值作为key，而对于Map结构而言，可以是不允许重复的，所以Set集合值不能重复）。均为非并发安全</p>
<p><strong>不同点：</strong></p>
<p><strong><em>HashSet</em></strong>：HashSet 是基于 HashMap （哈希表）实现的。<strong>HashSet中的数据是无序的，允许放入null值。</strong></p>
<p><strong><em>TreeSet</em></strong>：TreeSet是基于二叉树TreeMap（底层结构是红黑树）。<strong>具有排序功能</strong>，分为自然排序和自定义排序，默认是自然排序（如1，2，3以及a,b,c这样的顺序），基本数据类型可以直接使用，但是对于对象类型则需要实现Comparable接口，自定义排序规则，否则就会报错（基本数据类型时因为其包装类已经实现了Comparable接口）。<strong>不允许放入null值</strong>。</p>
<p><strong>适用场景分析:</strong><br>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p>
<h2 id="2-JDK8下分析HashSet和TreeSet"><a href="#2-JDK8下分析HashSet和TreeSet" class="headerlink" title="2.JDK8下分析HashSet和TreeSet"></a>2.JDK8下分析HashSet和TreeSet</h2><p>在JDK8之后可以发现HashSet在进行add方法时，实际上调用的是HashMap中的put方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap中的put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要这么做呢？</p>
<p>由于使用哈希表进行存储，所以一定会出现一种状况：哈希碰撞。Java解决哈希碰撞的方法很多，比如单向链表和红黑树。在JDK8中添加了红黑树，当链表链长度为8时，及时转成红黑树，提高map的效率。因为当碰撞的数据较多，就造成单链表越来越长，使得哈希表实际上退化为单链接。而操作单链表的时间复杂度远远高于哈希表结构，所以会造成CPU资源的大量浪费，这时不妨就通过红黑树来解决。查看下面的源码也可以发现确实改进了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果是true，则不需要修改已经存在的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，则表属于创建模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前数组table为null，进行resize()初始化</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(n - 1) &amp; hash 计算出下标 如果该位置为null 说明没有碰撞就赋值到此位置 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之 说明碰撞了 </span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断 key是否存在 如果存在就覆盖原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//不存在，判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//都不是 就是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将next指向新的节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//这个判断是用来判断是否要转化为红黑树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-HashSet添加操作"><a href="#3-HashSet添加操作" class="headerlink" title="3. HashSet添加操作"></a>3. HashSet添加操作</h2><p>如果是添加基本数据类型（包括String类型），将无法添加重复元素，主要原因是基本数据类型都重写了equals方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"jiaboyan"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"jiaboyan"</span>);</span><br><span class="line">set1.add(str1);</span><br><span class="line">set1.add(str2);</span><br><span class="line">System.out.println(<span class="string">"长度："</span>+set1.size()+<span class="string">",内容为："</span>+set1);<span class="comment">//添加了一个</span></span><br></pre></td></tr></table></figure>

<p>如果是一个自定义的对象，并且没有实现equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;App&gt; set2 = <span class="keyword">new</span> HashSet&lt;App&gt;();</span><br><span class="line">App app1 = <span class="keyword">new</span> App();</span><br><span class="line">app1.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">App app2 = <span class="keyword">new</span> App();</span><br><span class="line">app2.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">set2.add(app1);</span><br><span class="line">set2.add(app2);</span><br><span class="line">System.out.println(<span class="string">"长度："</span>+set2.size()+<span class="string">",内容为："</span>+set2);<span class="comment">// 添加了两个</span></span><br></pre></td></tr></table></figure>

<p>如果添加的是同一对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;App&gt; set3 = <span class="keyword">new</span> HashSet&lt;App&gt;();</span><br><span class="line">App app3 = <span class="keyword">new</span> App();</span><br><span class="line">app3.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">set3.add(app3);</span><br><span class="line">set3.add(app3);</span><br><span class="line">System.out.println(<span class="string">"长度："</span>+set3.size()+<span class="string">",内容为："</span>+set3);<span class="comment">//添加了一个</span></span><br></pre></td></tr></table></figure>

<p>因为在进行元素添加是，先判断该元素的hashcode，然后再判断值是否相等。</p>
<h2 id="4-HashSet是如何保证数据不可重复的？"><a href="#4-HashSet是如何保证数据不可重复的？" class="headerlink" title="4.HashSet是如何保证数据不可重复的？"></a>4.HashSet是如何保证数据不可重复的？</h2><p>答：HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>，我们可以看到源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;<span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性；</p>
<h2 id="5-HashSet插入自定义对象"><a href="#5-HashSet插入自定义对象" class="headerlink" title="5. HashSet插入自定义对象"></a>5. HashSet插入自定义对象</h2><p>假如存在下面例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="string">"1"</span>);</span><br><span class="line">    set.add(<span class="string">"2"</span>);</span><br><span class="line">    set.add(<span class="string">"3"</span>);</span><br><span class="line">    set.add(<span class="string">"4"</span>);</span><br><span class="line">    set.add(<span class="string">"4"</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Student&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Student stu1 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"张三"</span>);</span><br><span class="line">    Student stu2 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"李四"</span>);</span><br><span class="line">    Student stu3 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"王五"</span>);</span><br><span class="line">    Student stu4 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"张三"</span>);</span><br><span class="line">    set1.add(stu1);</span><br><span class="line">    set1.add(stu2);</span><br><span class="line">    set1.add(stu3);</span><br><span class="line">    set1.add(stu4);</span><br><span class="line"></span><br><span class="line">    System.out.println(set1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Student类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面得到的结果是</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br><span class="line">[Student&#123;<span class="attribute">age</span>=12, <span class="attribute">name</span>=<span class="string">'张三'</span>&#125;, Student&#123;<span class="attribute">age</span>=12, <span class="attribute">name</span>=<span class="string">'王五'</span>&#125;, Student&#123;<span class="attribute">age</span>=12, <span class="attribute">name</span>=<span class="string">'李四'</span>&#125;, Student&#123;<span class="attribute">age</span>=12, <span class="attribute">name</span>=<span class="string">'张三'</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>为什么这里可以插入重复的对象呢？首先我们回忆下下HashSet插入元素调用的是HashMap的put方法，实际上之后调用的putVal方法，在该方法中存在一个很重要的判断语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">    <span class="comment">// 成立，则将p值覆盖e值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断hash是否相同，对于添加的是自定义对象，由于没有重写Object类的hashCode方法，所以只能调用Object自己的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object的hashCode放底层是native，所以由自己的默认实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是经过试验发现，虽然两个值相同，但是两个的hashCode实际上是不同的，所以在不从写的情况下，是可以添加相同的自定义对象的（注意基本类型由于内部实现了hashCode和equals方法，所以不需要理会）。</p>
<p>在Student类中重写了hashCode方法后，还需要重写equals方法，因为默认调用的Object类的equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Object类中判断两个对象是否相同（A.equals(B)，也即A和B是否相同，而两者相同的具体表现在地址是否相同。）很明显上面在进行插入时，分别一共定义了四个对象，地址都不同，所以哪怕值相同的stu1和stu4都可以插入成功。所以一定需要重写equals方法的。</p>
<p>修改后的Student类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现实际上调用的还是Object类的方法hashCode(…)和equals(…)方法，只是这里调用的是多参数方法。</p>
<p>总结：<strong>在使用HashSet添加元素时，对于基本类型由于本身已经重写了equals和hashCode方法，所以不需要单独处理；但是添加自定义类型时，需要在定义的类实体类中重写hashCode和equals方法。</strong></p>
<h2 id="5-hashCode-和equals-方法有何重要性？"><a href="#5-hashCode-和equals-方法有何重要性？" class="headerlink" title="5.hashCode()和equals()方法有何重要性？"></a>5.hashCode()和equals()方法有何重要性？</h2><p>HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则：</p>
<p>（1）如果o1.equals(o2)，那么o1.hashCode() == o2.hashCode()总是为true的。</p>
<p>（2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。</p>
<h2 id="6-TreeSet使用注意"><a href="#6-TreeSet使用注意" class="headerlink" title="6.TreeSet使用注意"></a>6.TreeSet使用注意</h2><p>在TreeSet源码中可以发现，TreeSet实现了NavigableSet接口，而NavigableSet接口继承了SortedSet，所以TreeSet具有排序功能。</p>
<p>TreeSet分为自然排序和自定义排序。</p>
<p>自然排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="string">"dd"</span>);</span><br><span class="line">    set.add(<span class="string">"cc"</span>);</span><br><span class="line">    set.add(<span class="string">"bbb"</span>);</span><br><span class="line">    set.add(<span class="string">"bb"</span>);</span><br><span class="line">    set.add(<span class="string">"aa"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(set);</span><br><span class="line"></span><br><span class="line">    Student stu1 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"张三"</span>);</span><br><span class="line">    Student stu2 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"李四"</span>);</span><br><span class="line">    Student stu3 = <span class="keyword">new</span> Student(<span class="number">12</span>, <span class="string">"王五"</span>);</span><br><span class="line">    Student stu4 = <span class="keyword">new</span> Student(<span class="number">12</span>,<span class="string">"陈六"</span>);</span><br><span class="line">    TreeSet&lt;Student&gt; set1 = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set1.add(stu1);</span><br><span class="line">    set1.add(stu2);</span><br><span class="line">    set1.add(stu3);</span><br><span class="line">    set1.add(stu4);</span><br><span class="line">    System.out.println(set1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Student类为前面修改后的Student类。</p>
<p>输出结果：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[aa, bb, bbb, cc, dd]</span></span><br><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassCastException</span>: <span class="selector-tag">com</span><span class="selector-class">.xfcy</span><span class="selector-class">.collection</span><span class="selector-class">.set</span><span class="selector-class">.Student</span> <span class="selector-tag">cannot</span> <span class="selector-tag">be</span> <span class="selector-tag">cast</span> <span class="selector-tag">to</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Comparable</span></span><br><span class="line">	<span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.TreeMap</span><span class="selector-class">.compare</span>(<span class="selector-tag">TreeMap</span><span class="selector-class">.java</span><span class="selector-pseudo">:1294)</span></span><br><span class="line">	<span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.TreeMap</span><span class="selector-class">.put</span>(<span class="selector-tag">TreeMap</span><span class="selector-class">.java</span><span class="selector-pseudo">:538)</span></span><br><span class="line">	<span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.TreeSet</span><span class="selector-class">.add</span>(<span class="selector-tag">TreeSet</span><span class="selector-class">.java</span><span class="selector-pseudo">:255)</span></span><br><span class="line">	<span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.xfcy</span><span class="selector-class">.collection</span><span class="selector-class">.set</span><span class="selector-class">.SortedSetDemo</span><span class="selector-class">.main</span>(<span class="selector-tag">SortedSetDemo</span><span class="selector-class">.java</span><span class="selector-pseudo">:24)</span></span><br></pre></td></tr></table></figure>

<p>在学习源码的时候知道，TreeMap实际上底层的调用的是一个Map结构，其中put方法也是M</p>
<p>TreeMap的。在TreeMap的方法中存在如下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">compare(key, key);</span><br></pre></td></tr></table></figure>

<p>其具体实现为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">            : comparator.compare((K)k1, (K)k2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当使用自定义类型时，comparator为null，所以需要做强制类型转换。很明显这令会报错的，K为null。所以自然就出现了上面的类型转换异常。</p>
<p>【解决方法】对于自定义类Student需要实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 比较年龄大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-student.age&gt;<span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后输出结果为：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[aa, bb, bbb, cc, dd]</span><br><span class="line">[Student&#123;<span class="attribute">age</span>=12, <span class="attribute">name</span>=<span class="string">'张三'</span>&#125;, Student&#123;<span class="attribute">age</span>=14, <span class="attribute">name</span>=<span class="string">'王五'</span>&#125;, Student&#123;<span class="attribute">age</span>=15, <span class="attribute">name</span>=<span class="string">'陈六'</span>&#125;, Student&#123;<span class="attribute">age</span>=16, <span class="attribute">name</span>=<span class="string">'李四'</span>&#125;]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Set集合-HashSet和TreeSet集合源码</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Set%E9%9B%86%E5%90%88-HashSet%E5%92%8CTreeSet%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在本节主要学习Set集合，首先看一下Set集合中的主要两个类<code>HashSet</code>和<code>TreeSet</code>类的继承结构图。</p>
<p><img src="images/Set%E9%9B%86%E5%90%88.png" alt></p>
<p><strong>1.HashSet简要说明</strong></p>
<p>HashSet在添加元素时，需要调用hashCode()和equals()方法，由于基本数据类型（比如String类，本身已经实现了这两个方法）所以可以直接添加。但是对于自定义类，需要在自定义类中需要手动实现上述两个方法。</p>
<p>HashSet是哈希结构，底层的实现由HashMap完成，在添加元素时，实际上是将添加的值作为key进行添加，所以这也是为什么不能重复的原因了。其中HashMap主要的数据结构为：数组+链表+红黑树</p>
<p><strong>2.TreeSet简要说明</strong></p>
<p>TreeSet一个树形结构，底层调用的是TreeMap。TreeMap是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；</p>
<p>在上图中TreeSet实现了NavigableSet接口（也间接实现的是SortedSet）接口，因此TreeSet是可以排序的（排序分为自然排序和自定义排序，需要继承Comparable接口）</p>
<h2 id="2-Set接口常用方法"><a href="#2-Set接口常用方法" class="headerlink" title="2. Set接口常用方法"></a>2. Set接口常用方法</h2><p>与List接口一样，Set接口也提供了集合操作的基本方法。</p>
<p>但与List不同的是，Set还提供了equals(Object o)和hashCode()，供其子类重写，以实现对集合中插入重复元素的处理；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// A:添加功能</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="comment">// B:删除功能</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// C:长度功能</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// D:判断功能</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>; </span><br><span class="line">    <span class="comment">// E:获取Set集合的迭代器：</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// F:把集合转换成数组</span></span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="comment">// 判断元素是否重复，为子类提高重写方法</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-HashSet"><a href="#3-HashSet" class="headerlink" title="3. HashSet"></a>3. HashSet</h2><h3 id="3-1-基本介绍"><a href="#3-1-基本介绍" class="headerlink" title="3.1 基本介绍"></a>3.1 基本介绍</h3><p>首先看一下HashSet类的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet实现Set接口，底层由HashMap(后面讲解)来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap;</p>
<p>当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来；</p>
<p>它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。</p>
<p>(1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类（因为AbstractSet继承了AbstractCollection类）；</p>
<p>(2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；</p>
<p>(3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；</p>
<p>(4)HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。</p>
<p>具有如下特点：</p>
<ul>
<li><p>不允许出现重复因素；</p>
</li>
<li><p>允许插入Null值；</p>
</li>
<li><p>元素无序（添加顺序和遍历顺序不一致）；</p>
</li>
<li><p>线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步；</p>
</li>
</ul>
<h3 id="3-2-基本操作"><a href="#3-2-基本操作" class="headerlink" title="3.2 基本操作"></a>3.2 基本操作</h3><p>HashSet底层由HashMap实现，插入的元素被当做是HashMap的key，根据hashCode值来确定集合中的位置，由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建HashSet集合：</span></span><br><span class="line">        Set&lt;String&gt; hashSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        System.out.println(<span class="string">"HashSet初始容量大小："</span>+hashSet.size());</span><br><span class="line">        <span class="comment">//元素添加：</span></span><br><span class="line">        hashSet.add(<span class="string">"my"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"name"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"is"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        hashSet.add(<span class="string">","</span>);</span><br><span class="line">        hashSet.add(<span class="string">"hello"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"world"</span>);</span><br><span class="line">        hashSet.add(<span class="string">"!"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HashSet容量大小："</span>+hashSet.size());</span><br><span class="line">        <span class="comment">//迭代器遍历：</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            String str = iterator.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="keyword">for</span>(String str:hashSet)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"jiaboyan"</span>.equals(str))&#123;</span><br><span class="line">                System.out.println(<span class="string">"你就是我想要的元素:"</span>+str);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素删除：</span></span><br><span class="line">        hashSet.remove(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HashSet元素大小："</span> + hashSet.size());</span><br><span class="line">        hashSet.clear();</span><br><span class="line">        System.out.println(<span class="string">"HashSet元素大小："</span> + hashSet.size());</span><br><span class="line">        <span class="comment">//集合判断：</span></span><br><span class="line">        <span class="keyword">boolean</span> isEmpty = hashSet.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">"HashSet是否为空："</span> + isEmpty);</span><br><span class="line">        <span class="keyword">boolean</span> isContains = hashSet.contains(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(<span class="string">"HashSet是否为空："</span> + isContains);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.4 HashSet元素添加分析</strong></p>
<p>Set集合不允许添加重复元素，那么到底是个怎么情况呢？</p>
<p>来看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="comment">//hashCode() 和 equals()测试：</span></span><br><span class="line">        hashCodeAndEquals();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hashCodeAndEquals</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一个 Set集合：</span></span><br><span class="line">        Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        set1.add(str1);</span><br><span class="line">        set1.add(str2);</span><br><span class="line">        System.out.println(<span class="string">"长度："</span>+set1.size()+<span class="string">",内容为："</span>+set1);</span><br><span class="line">        <span class="comment">//第二个 Set集合：</span></span><br><span class="line">        Set&lt;App&gt; set2 = <span class="keyword">new</span> HashSet&lt;App&gt;();</span><br><span class="line">        App app1 = <span class="keyword">new</span> App();</span><br><span class="line">        app1.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        App app2 = <span class="keyword">new</span> App();</span><br><span class="line">        app2.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        set2.add(app1);</span><br><span class="line">        set2.add(app2);</span><br><span class="line">        System.out.println(<span class="string">"长度："</span>+set2.size()+<span class="string">",内容为："</span>+set2);</span><br><span class="line">        <span class="comment">//第三个 Set集合：</span></span><br><span class="line">        Set&lt;App&gt; set3 = <span class="keyword">new</span> HashSet&lt;App&gt;();</span><br><span class="line">        App app3 = <span class="keyword">new</span> App();</span><br><span class="line">        app3.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        set3.add(app3);</span><br><span class="line">        set3.add(app3);</span><br><span class="line">        System.out.println(<span class="string">"长度："</span>+set3.size()+<span class="string">",内容为："</span>+set3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<blockquote>
<p>长度：1,内容为：[jiaboyan]<br>长度：2,内容为：[com.jiaboyan.collection.App@efb78af, com.jiaboyan.collection.App@5f3306ad]<br>长度：1,内容为：[com.jiaboyan.collection.App@1fb030d8]</p>
</blockquote>
<p>可以看到，第一个Set集合中最终只有一个元素；第二个Set集合保留了2个元素；第三个集合也只有1个元素；</p>
<p>究竟是什么原因呢？</p>
<p>让我们来看看HashSet的add(E e)方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在底层HashSet调用了<strong>HashMap</strong>的put(K key, V value)方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 然后调用的是putValue方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果是true，则不需要修改已经存在的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为false，则表属于创建模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前数组table为null，进行resize()初始化</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(n - 1) &amp; hash 计算出下标 如果该位置为null 说明没有碰撞就赋值到此位置 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之 说明碰撞了 </span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断 key是否存在 如果存在就覆盖原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//不存在，判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//都不是 就是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将next指向新的节点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//这个判断是用来判断是否要转化为红黑树结构</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>红黑树是什么？</li>
</ul>
<p>在这篇文章中有介绍：<a href="https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jz1ajDUygZ7sXLQFHyfjWA</a></p>
<ul>
<li>哈希碰撞是什么？</li>
</ul>
<p>在上面的代码中，提到了红黑树是为了防止<strong>哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率。</strong></p>
<p>现在的web开发通常采用的是RESTful风格，使用的数据传输形式通常是json。如果了解json，便会发现json实际上是一种类似Map的结构。而Map实际上是利用了哈希表进行存储的，通过插入元素，然后返回对应的地址索引。但是实际情况下，会出现不同的数据定位到同一位置，因而出现哈希碰撞现象。</p>
<p>java解决哈希碰撞采用的思路是单向链表和红黑树，上文提到的红黑树是JDK8之后添加的，目的便是为了缓解哈希碰撞。当碰撞的数据较多，就造成单链表越来越长，使得哈希表实际上退化为单链接。而操作单链表的时间复杂度远远高于哈希表结构，所以会造成CPU资源的大量浪费，这时不妨就通过红黑树来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">	e = p;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简答概括如下：</p>
<p>在向HashMap中添加元素时，先判断key的hashCode值是否相同？如果相同就判断key是否也相同，如果任然相同，则直接覆盖。如果不相同则在key不为null的情况下判断调用equals()判断。</p>
<p>分析上面的例子：</p>
<ul>
<li><p>第一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"jiaboyan"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"jiaboyan"</span>);</span><br><span class="line">set1.add(str1);</span><br><span class="line">set1.add(str2);</span><br><span class="line">System.out.println(<span class="string">"长度："</span>+set1.size()+<span class="string">",内容为："</span>+set1);</span><br></pre></td></tr></table></figure>

<p>在第一个Set集合中，我们new了两个String对象，赋了相同的值。当传入到HashMap中时，key均为“jiaboyan”，所以hash和i的值都相同。进行if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))判断，由于String对象重写了equals()方法，所以在((k = e.key) == key || key.equals(k))判断时，返回了true，所以第二次的插入并不会增加Set集合的长度；</p>
</li>
<li><p>第二个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;App&gt; set2 = <span class="keyword">new</span> HashSet&lt;App&gt;();</span><br><span class="line">App app1 = <span class="keyword">new</span> App();</span><br><span class="line">app1.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">App app2 = <span class="keyword">new</span> App();</span><br><span class="line">app2.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">set2.add(app1);</span><br><span class="line">set2.add(app2);</span><br><span class="line">System.out.println(<span class="string">"长度："</span>+set2.size()+<span class="string">",内容为："</span>+set2);</span><br></pre></td></tr></table></figure>

<p>第二个Set集合中，也是new了两个对象，但没有重写equals()方法（底层调用的Object的equals()，也就是==判断），所以会增加2个元素；</p>
</li>
<li><p>第三个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;App&gt; set3 = <span class="keyword">new</span> HashSet&lt;App&gt;();</span><br><span class="line">App app3 = <span class="keyword">new</span> App();</span><br><span class="line">app3.setName(<span class="string">"jiaboyan"</span>);</span><br><span class="line">set3.add(app3);</span><br><span class="line">set3.add(app3);</span><br><span class="line">System.out.println(<span class="string">"长度："</span>+set3.size()+<span class="string">",内容为："</span>+set3);</span><br></pre></td></tr></table></figure>

<p>第三个Set集合中，只new了一个对象，调用的两次add方法都添加的这个新new的对象，所以也只是保留了1个元素；</p>
</li>
</ul>
<h2 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4. TreeSet"></a>4. TreeSet</h2><p>从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现<strong>TreeMap</strong>(后面讲解)，其底层结构为<strong>红黑树</strong>（特殊的二叉查找树）；</p>
<p>与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出--倒序或者升序；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。</p>
<p>（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；</p>
<p>（2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；</p>
<p>（3）TreeSet实现Cloneable接口，意味着它也可以被克隆；</p>
<p>（4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；</p>
<p>具有如下特点：</p>
<ul>
<li><p>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;</p>
</li>
<li><p>底层使用红黑树结构，而不是哈希表结构；</p>
</li>
<li><p>允许插入Null值；</p>
</li>
<li><p>不允许插入重复元素；</p>
</li>
<li><p>线程不安全；</p>
</li>
</ul>
<p><strong>1.6 TreeSet基本操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        System.out.println(<span class="string">"TreeSet初始化容量大小："</span>+treeSet.size());</span><br><span class="line">        <span class="comment">//元素添加：</span></span><br><span class="line">        treeSet.add(<span class="string">"my"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"name"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"hello"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"world"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"1"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"2"</span>);</span><br><span class="line">        treeSet.add(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"TreeSet容量大小："</span> + treeSet.size());</span><br><span class="line">        System.out.println(<span class="string">"TreeSet元素顺序为："</span> + treeSet.toString());</span><br><span class="line">        <span class="comment">//增加for循环遍历：</span></span><br><span class="line">        <span class="keyword">for</span>(String str:treeSet)&#123;</span><br><span class="line">            System.out.println(<span class="string">"遍历元素："</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代器遍历：升序</span></span><br><span class="line">        Iterator&lt;String&gt; iteratorAesc = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iteratorAesc.hasNext())&#123;</span><br><span class="line">            String str = iteratorAesc.next();</span><br><span class="line">            System.out.println(<span class="string">"遍历元素升序："</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代器遍历：降序</span></span><br><span class="line">        Iterator&lt;String&gt; iteratorDesc = treeSet.descendingIterator();</span><br><span class="line">        <span class="keyword">while</span>(iteratorDesc.hasNext())&#123;</span><br><span class="line">            String str = iteratorDesc.next();</span><br><span class="line">            System.out.println(<span class="string">"遍历元素降序："</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素获取:实现NavigableSet接口</span></span><br><span class="line">        String firstEle = treeSet.first();<span class="comment">//获取TreeSet头节点：</span></span><br><span class="line">        System.out.println(<span class="string">"TreeSet头节点为："</span> + firstEle);</span><br><span class="line">        <span class="comment">// 获取指定元素之前的所有元素集合：(不包含指定元素)</span></span><br><span class="line">        SortedSet&lt;String&gt; headSet = treeSet.headSet(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        System.out.println(<span class="string">"jiaboyan节点之前的元素为："</span>+headSet.toString());</span><br><span class="line">        <span class="comment">//获取给定元素之间的集合：（包含头，不包含尾）</span></span><br><span class="line">        SortedSet subSet = treeSet.subSet(<span class="string">"1"</span>,<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(<span class="string">"1--jiaboan之间节点元素为："</span>+subSet.toString());</span><br><span class="line">        <span class="comment">//集合判断：</span></span><br><span class="line">        <span class="keyword">boolean</span> isEmpty = treeSet.isEmpty();</span><br><span class="line">        System.out.println(<span class="string">"TreeSet是否为空："</span>+isEmpty);</span><br><span class="line">        <span class="keyword">boolean</span> isContain = treeSet.contains(<span class="string">"who"</span>);</span><br><span class="line">        System.out.println(<span class="string">"TreeSet是否包含who元素："</span>+isContain);</span><br><span class="line">        <span class="comment">//元素删除：</span></span><br><span class="line">        <span class="keyword">boolean</span> jiaboyanRemove = treeSet.remove(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        System.out.println(<span class="string">"jiaboyan元素是否被删除"</span>+jiaboyanRemove);</span><br><span class="line">        <span class="comment">//集合中不存在的元素，删除返回false</span></span><br><span class="line">        <span class="keyword">boolean</span> whoRemove = treeSet.remove(<span class="string">"who"</span>);</span><br><span class="line">        System.out.println(<span class="string">"who元素是否被删除"</span>+whoRemove);</span><br><span class="line">       <span class="comment">//删除并返回第一个元素：如果set集合不存在元素，则返回null</span></span><br><span class="line">        String pollFirst = treeSet.pollFirst();</span><br><span class="line">        System.out.println(<span class="string">"删除的第一个元素："</span>+pollFirst);</span><br><span class="line">        <span class="comment">//删除并返回最后一个元素：如果set集合不存在元素，则返回null</span></span><br><span class="line">        String pollLast = treeSet.pollLast();</span><br><span class="line">        System.out.println(<span class="string">"删除的最后一个元素："</span>+pollLast);</span><br><span class="line">        treeSet.clear();<span class="comment">//清空集合:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-TreeSet元素排序"><a href="#4-1-TreeSet元素排序" class="headerlink" title="4.1 TreeSet元素排序"></a>4.1 TreeSet元素排序</h3><p>在前面的章节，我们讲到了TreeSet是一个有序集合，可以对集合元素排序，其中分为自然排序和自定义排序，那么这两种方式如何实现呢？</p>
<p>首先，我们通过JDK提供的对象来展示，我们使用String、Integer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        naturalSort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自然排序顺序：升序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">naturalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSetString = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">        treeSetString.add(<span class="string">"a"</span>);</span><br><span class="line">        treeSetString.add(<span class="string">"z"</span>);</span><br><span class="line">        treeSetString.add(<span class="string">"d"</span>);</span><br><span class="line">        treeSetString.add(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(<span class="string">"字母顺序："</span> + treeSetString.toString());</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSetInteger = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        treeSetInteger.add(<span class="number">1</span>);</span><br><span class="line">        treeSetInteger.add(<span class="number">24</span>);</span><br><span class="line">        treeSetInteger.add(<span class="number">23</span>);</span><br><span class="line">        treeSetInteger.add(<span class="number">6</span>);</span><br><span class="line">        System.out.println(treeSetInteger.toString());</span><br><span class="line">        System.out.println(<span class="string">"数字顺序："</span> + treeSetString.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<blockquote>
<p>字母顺序：[a, b, d, z]<br>数字顺序：[1, 6, 23, 24]</p>
</blockquote>
<p>接下来，我们自定义对象，看能否实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args )</span></span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        customSort();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//自定义排序顺序：升序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;App&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;App&gt;();</span><br><span class="line">        <span class="comment">//排序对象：</span></span><br><span class="line">        App app1 = <span class="keyword">new</span> App(<span class="string">"hello"</span>,<span class="number">10</span>);</span><br><span class="line">        App app2 = <span class="keyword">new</span> App(<span class="string">"world"</span>,<span class="number">20</span>);</span><br><span class="line">        App app3 = <span class="keyword">new</span> App(<span class="string">"my"</span>,<span class="number">15</span>);</span><br><span class="line">        App app4 = <span class="keyword">new</span> App(<span class="string">"name"</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">//添加到集合：</span></span><br><span class="line">        treeSet.add(app1);</span><br><span class="line">        treeSet.add(app2);</span><br><span class="line">        treeSet.add(app3);</span><br><span class="line">        treeSet.add(app4);</span><br><span class="line">        System.out.println(<span class="string">"TreeSet集合顺序为："</span>+treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<blockquote>
<p>抛出异常：提示App不能转换为Comparable对象：<br>Exception in thread “main” java.lang.ClassCastException: com.jiaboyan.collection.App cannot be cast to java.lang.Comparable</p>
</blockquote>
<p>为什么会报错呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看源码发现，在TreeSet调用add方法时，会调用到底层TreeMap的put方法，在put方法中会调用到compare(key, key)方法，进行key大小的比较；</p>
<p>在比较的时候，会将传入的key进行类型强转，所以当我们自定义的App类进行比较的时候，自然就会抛出异常，因为App类并没有实现Comparable接口；</p>
<p>将App实现Comparable接口，在做比较:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">App</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义比较：先比较name的长度，在比较age的大小；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(App app)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//比较name的长度：</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">this</span>.name.length() - app.name.length();</span><br><span class="line">        <span class="comment">//如果name长度一样，则比较年龄的大小：</span></span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span> ? <span class="keyword">this</span>.age - app.age : num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"App&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<blockquote>
<p>TreeSet集合顺序为：[App{name=’my’, age=15}, App{name=’name’, age=25}, App{name=’hello’, age=10}, App{name=’world’, age=20}]</p>
</blockquote>
<p>此外，还有另一种方式，那就是实现Comparetor 接口，并重写compare方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义App类的比较器：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">App</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//比较方法：先比较年龄，年龄若相同在比较名字长度；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(App app1, App app2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = app1.getAge() - app2.getAge();</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span> ? app1.getName().length() - app2.getName().length() : num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，App不用在实现Comparerable接口了，单纯的定义一个类即可；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args )</span></span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        customSort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义比较器：升序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">customComparatorSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TreeSet&lt;App&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;App&gt;(<span class="keyword">new</span> AppComparator());</span><br><span class="line">        <span class="comment">//排序对象：</span></span><br><span class="line">        App app1 = <span class="keyword">new</span> App(<span class="string">"hello"</span>,<span class="number">10</span>);</span><br><span class="line">        App app2 = <span class="keyword">new</span> App(<span class="string">"world"</span>,<span class="number">20</span>);</span><br><span class="line">        App app3 = <span class="keyword">new</span> App(<span class="string">"my"</span>,<span class="number">15</span>);</span><br><span class="line">        App app4 = <span class="keyword">new</span> App(<span class="string">"name"</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">//添加到集合：</span></span><br><span class="line">        treeSet.add(app1);</span><br><span class="line">        treeSet.add(app2);</span><br><span class="line">        treeSet.add(app3);</span><br><span class="line">        treeSet.add(app4);</span><br><span class="line">        System.out.println(<span class="string">"TreeSet集合顺序为："</span>+treeSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<blockquote>
<p>TreeSet集合顺序为：[App{name=’hello’, age=10}, App{name=’my’, age=15}, App{name=’world’, age=20}, App{name=’name’, age=25}]</p>
</blockquote>
<p>最后，在说下关于compareTo()、compare()方法：</p>
<blockquote>
<p>结果返回大于0时，方法前面的值大于方法中的值；<br>结果返回等于0时，方法前面的值等于方法中的值；<br>结果返回小于0时，方法前面的值小于方法中的值；</p>
</blockquote>
<h2 id="5-HashSet源码分析"><a href="#5-HashSet源码分析" class="headerlink" title="5. HashSet源码分析"></a>5. HashSet源码分析</h2><p>HashSet基于HashMap，底层方法是通过调用HashMap的API来实现，因此HashSet源码结构比较简单，代码较少。</p>
<ul>
<li>成员变量：</li>
</ul>
<p>在HashSet中，有两个成员变量比较重要--map、PRESENT;</p>
<p>其中，map就是存储元素的地方，实际是一个HashMap。当有元素插入到HashSet中时，会被当做HashMap的key保存到map属性中去。</p>
<p>对于HashMap来说，光有key还不够，在HashSet的实现中，每个key对应的value都默认为PRESENT属性，也就是new了一个Object对象而已；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line">    <span class="comment">//HashSet通过HashMap保存集合元素的：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line">    <span class="comment">//HashSet底层由HashMap实现，新增的元素为map的key，而value则默认为PRESENT。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造方法：</li>
</ul>
<p>HashSet的构造方法很简单，主要是在方法内部初始化map属性，new了一个HashMap对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认new一个HashMap</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带集合的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进行初始化HashMap容量判断，</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定HashSet初始容量和加载因子的构造函数：主要用于Map内部的扩容机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定HashSet初始容量的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与前4个不同，此构造最终new了一个LinkedHashMap对象：</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>add():</li>
</ul>
<p>HashSet的add(E e)方法，主要是调用底层HashMap的put(K key, V value)方法。</p>
<p>其中key就是HashSet集合插入的元素，而value则是默认的PRESENT属性(一个new Object());</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用HashMap中的put()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>put()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put 方法会调用 putVal 方法进行添加元素,前面将结果这个putVal方法，自行查看。</p>
<ul>
<li>remove():</li>
</ul>
<p>与add(E e)方法类似，HashSet的remove(Object o)也是调用了底层HashMap的(Object key)方法；</p>
<p>主要是计算出要删除元素的hash值，在HashMap找到对应的对象，然后从Entry []数组中删除；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用HashMap中的remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-TreeSet源码分析"><a href="#6-TreeSet源码分析" class="headerlink" title="6. TreeSet源码分析"></a>6. TreeSet源码分析</h2><p>上面说了HashSet，接下来说说TreeSet。</p>
<p>与HashSet类似，TreeSet底层也是采用了一个Map来保存集合元素，这个Map就是NavigableMap。</p>
<p>不过，NavigableMap仅仅是一个接口，具体的实现还是使用了TreeMap类；</p>
<ul>
<li>成员变量</li>
</ul>
<p>当你看到下面的代码之后，你就会明白我为什么一直在说TreeSet底层使用了Map集合了；成员变量m是一个NavigableMap类型的Map集合，常用实现是TreeMap对象；</p>
<p>在TreeMap中，key是我们TreeSet插入的元素，而value则是TreeSet中另一个成员变量PRESENT，一个普通的不能再普通的Object对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TreeSet中保存元素的map对象：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">//map对象中保存的value:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最底层的构造方法，不对外。传入一个NavigableMap接口的实现类</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无参构造：向底层构造传入一个TreeMap对象：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入比较器的构造：通常传入一个自定义Comparator的实现类；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将集合Collection传入TreeSet中：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将集合SortedSet传入TreeSet中：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>add</li>
</ul>
<p>向TreeSet中添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put方法实际上是在NavigableMap接口中定义，具体实现类为TreeMap。后面到TreeMap再学习。</p>
<ul>
<li>remove</li>
</ul>
<p>删除TreeSet中元素o:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是HashSet，还是TreeSet，它们的API都是通过底层的Map来实现的。所以就源码来说，没有太多需要去理解地方。</p>
<p>在后面的Map讲解中，我会在详细进行说明。当你理解了Map之后，再回过头来看Set，就很容易去理解了；</p>
<h2 id="7-SortedSet和NavigableSet到底是什么"><a href="#7-SortedSet和NavigableSet到底是什么" class="headerlink" title="7. SortedSet和NavigableSet到底是什么"></a>7. SortedSet和NavigableSet到底是什么</h2><p>本章节，是我在写的时候突然想起来的，觉得有必要加进来阐述下。</p>
<p>为什么觉得有必要呢？</p>
<p>主要是看了一些关于TreeSet讲解的文章，在介绍TreeSet的时候都会提到NavigableSet，接着会说下NavigableSet是个”导航Set集合”，提供了一系列”导航”方法。看到这，我不禁想吐槽下，什么是”导航”方法。</p>
<p>针对于这个疑问，我查了下相关的资料，对这个类有个初步的理解。下面，我就说一下！</p>
<p>通过接口的定义，我们可以看到NavigableSet继承了SortedSet接口(后面说)，实现了对其的扩展；</p>
<p>而通过下面的方法，我们得出NavigableSet实际提供了一系列的搜索匹配元素的功能，能获取到某一区间内的集合元素 ；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function">E <span class="title">lower</span><span class="params">(E e)</span></span>;<span class="comment">//返回此set集合中小于e元素的最大元素</span></span><br><span class="line">     <span class="function">E <span class="title">floor</span><span class="params">(E e)</span></span>;<span class="comment">//返回此set集合中小于等于e元素的最大元素</span></span><br><span class="line">     <span class="function">E <span class="title">ceiling</span><span class="params">(E e)</span></span>;<span class="comment">//返回此set集合中大于等于e元素的最小元素</span></span><br><span class="line">     <span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span>;<span class="comment">//返回此set集合中大于e元素的最小元素</span></span><br><span class="line">     <span class="function">E <span class="title">pollFirst</span><span class="params">()</span></span>; <span class="comment">//获取并移除此set集合中的第一个元素</span></span><br><span class="line">     <span class="function">E <span class="title">pollLast</span><span class="params">()</span></span>;<span class="comment">//获取并移除此set集合中的最后一个元素</span></span><br><span class="line">     <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//返回此set集合的迭代器--升序</span></span><br><span class="line">     <span class="function">NavigableSet&lt;E&gt; <span class="title">descendingSet</span><span class="params">()</span></span>;<span class="comment">//以倒序的顺序返回此set集合</span></span><br><span class="line">     <span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span></span>;<span class="comment">//返回此set集合的迭代器--倒序</span></span><br><span class="line">     <span class="comment">//返回此set集合的部分元素--从fromElement开始到toElement结束，其中fromInclusive、toInclusive意为返回的集合是否包含头尾元素</span></span><br><span class="line">     <span class="function">NavigableSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, <span class="keyword">boolean</span> fromInclusive, E toElement, <span class="keyword">boolean</span> toInclusive)</span></span>;</span><br><span class="line">     <span class="comment">//返回此set集合的部分元素--小于toElement，inclusive意味返回的集合是否包含toElement</span></span><br><span class="line">     <span class="function">NavigableSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement, <span class="keyword">boolean</span> inclusive)</span></span>;</span><br><span class="line">     <span class="comment">//返回此set集合的部分元素--从fromElement开始到toElement结束，包含头不含为尾</span></span><br><span class="line">     <span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line">     <span class="comment">//返回此set集合的部分元素--小于toElement</span></span><br><span class="line">     <span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line">     <span class="comment">//返回此set集合的部分元素--大于等于toElement</span></span><br><span class="line">     <span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说完了NavigableSet，我们在一起儿看下其父类SortedSet接口：</p>
<p>通过名字，我们可以得出此接口跟排序有关，会提供跟排序的方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//返回与排序有关的比较器</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; comparator();</span><br><span class="line">    <span class="comment">//返回从fromElement到toElement的元素集合：</span></span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line">    <span class="comment">//返回从第一个元素到toElement元素的集合：</span></span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line">    <span class="comment">//返回从fromElement开始到最后元素的集合：</span></span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line">    <span class="comment">//返回集合中的第一个元素：</span></span><br><span class="line">    <span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回集合中的最后一个元素：</span></span><br><span class="line">    <span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原文链接：<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODI5NDkxMw==&amp;mid=2247486856&amp;idx=1&amp;sn=59747b78fef6df2599ddfd95d252f45c&amp;chksm=eca94666dbdecf70c237d603965b12cda5f0cae8220655d416ddb7dbfcdc566afd228ae32927&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI5ODI5NDkxMw==&amp;mid=2247486856&amp;idx=1&amp;sn=59747b78fef6df2599ddfd95d252f45c&amp;chksm=eca94666dbdecf70c237d603965b12cda5f0cae8220655d416ddb7dbfcdc566afd228ae32927&amp;scene=21#wechat_redirect</a> </p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Map集合面试题</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Map%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-说说常见的集合有哪些吧？"><a href="#1-说说常见的集合有哪些吧？" class="headerlink" title="1. 说说常见的集合有哪些吧？"></a>1. 说说常见的集合有哪些吧？</h2><p>答：Map接口和Collection接口是所有集合框架的父接口：</p>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等 （使用键值对存储，两个key可以引用相同的对象，但是key不能重复）</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等。（set集合中元素无放入顺序，元素不可重复，重复元素会覆盖掉）</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等。（list集合中元素有放入顺序，元素可重复）</li>
</ol>
<h2 id="2-HashMap与TreeMap、HashTable的区别及适用场景"><a href="#2-HashMap与TreeMap、HashTable的区别及适用场景" class="headerlink" title="2. HashMap与TreeMap、HashTable的区别及适用场景"></a>2. HashMap与TreeMap、HashTable的区别及适用场景</h2><p><strong>相同点</strong></p>
<p>由于都是Map，Map集合通过Key/value保存数据，其中key唯一。</p>
<p><strong>不同点</strong></p>
<p><strong><em>HashMap</em></strong>：基于哈希表(散列表)实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。其中散列表的冲突处理主要分两种，一种是开放定址法，另一种是链表法。HashMap的实现中采用的是链表法。<strong>允许K/V都为null，HashMap没有考虑同步，是线程不安全的；支持fail-fast机制</strong></p>
<p><strong><em>TreeMap</em></strong>：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<p><strong><em>HashTable</em></strong>：<strong>K/V都不允许为null，Hashtable使用了synchronized关键字，是线程安全的；不支持fail-fast。</strong>HashTable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。</p>
<p>使用场景**</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/qhRZNwUg1HCCm1Cfib7Afo3auaJdY4zdp1tuMWQX6fA9a34RUbc7j54eXibA1SK2RaUEZM0EtQJq6sT0otlHJR2w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="3-HashMap扩容原理"><a href="#3-HashMap扩容原理" class="headerlink" title="3. HashMap扩容原理"></a>3. HashMap扩容原理</h2><p>首先HashMap采用的是懒加载机制，当进行put操作时才会创建一个table数组，第一次调用resize操作，此时设定capacity为16，扩容阈值为16*0.75=12（默认，其中0.75是默认的负载因子）。第二次扩容在put操作完成之后，如果实际数量超过了扩容阈值就需要扩容。</p>
<p>在第二次扩容时，</p>
<p>（1）首先将旧数组用一个变量保存。</p>
<p>（2）然后比较oldCap是否已经超过了最大容量（2的30次方），如果超过了则不能扩容，直接返回。另外将旧的容量<code>*</code>2赋值给新容量（第一次那么就是16<code>*</code>2=32），如果新容量小于最大容量并且大于初始容量（16），将新的阈值设置为旧阈值的2倍（12<code>*</code>2=24）。</p>
<p>（3）调整HashMap中的数据。（但是这个过程相对较负载性能消耗较高，所以通常建议嫩能够预知数据容量的大小的情况下，设置初始容量。）</p>
<h2 id="4-HashMap插入元素的过程"><a href="#4-HashMap插入元素的过程" class="headerlink" title="4. HashMap插入元素的过程"></a>4. HashMap插入元素的过程</h2><p><img src="https://mmbiz.qpic.cn/mmbiz/hbTNOSuicwlsXdFwHEU3CzoP7Dm8fYsT5lWNO20EiaZg8dtlB7iaLs6wsn9oXEL4XZIzdXiaaDvhprHQIXBGXK8QyA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="5-HashMap是怎么解决哈希冲突的？"><a href="#5-HashMap是怎么解决哈希冲突的？" class="headerlink" title="5. HashMap是怎么解决哈希冲突的？"></a>5. HashMap是怎么解决哈希冲突的？</h2><p>（1）什么是哈希？</p>
<p>有一种众所周知的数据结构， 可以快速地査找所需要的对象， 这就是散列表（ hash table)。散列表为每个对象计算一个整数， 称为散列码（hashcode)。在Java中散列表通常用链表数组实现（但是jdk1.8中引入了红黑树）。每个列表被称为桶（ bucket) 。要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。比如某个对象的散列码为20，而这里桶的个数为5，所以得到索引为20%5=0，即最前面的那个桶了。</p>
<p>如果我们大致知道最终会有多少元素插入散列表中，就可以设置桶数了。通常将桶数设置为预计个数的75%——150%，并且设置为一个素数。在java中设置的是2的幂，默认为16个。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H6Yq0g7vN8wDd1ice2KnqQ5FUUBXNob2BpJodOe3bqYrBlY5z89w9kBHROlXajeUhicGsy4XQ8z9ftQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>（2）什么是哈希冲突？</p>
<p>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</p>
<p>（3）怎么解决哈希冲突？</p>
<ul>
<li>链地址法</li>
</ul>
<p>在Java中解决哈希冲突的方式是<strong>链地址法</strong>，</p>
<p>这样我们就可以将拥有相同哈希值的对象组织成一个链表放在hash值所对应的bucket下，<strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，</strong>所以我们还需要对hashCode作一定的优化。</p>
<ul>
<li>扰动函数</li>
</ul>
<p>我们不妨看看HashMap中的Hash()函数是如何解决的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> h;    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</strong></p>
<ul>
<li>红黑树</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H6Yq0g7vN8wDd1ice2KnqQ5F2Yia6Y0TcQUcQWkgCJunfHicAuvgTPcuN8UGgaoXDGXezLJwNwuIadvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>通过上面的<strong>链地址法（使用散列表）</strong>和<strong>扰动函数</strong>我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；</p>
<p>总结：</p>
<p>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：</p>
<p><strong>1. 使用链地址法（使用散列表）来链接拥有相同hash值的数据；</strong><br><strong>2. 使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；</strong><br><strong>3. 引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；</strong></p>
<h2 id="6-HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？"><a href="#6-HashMap为什么不直接使用hashCode-处理后的哈希值直接作为table的下标？" class="headerlink" title="6. HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？"></a>6. HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h2><p>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)<del>(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）</del>2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</p>
<p><strong>面试官：那怎么解决呢？</strong></p>
<p>答：</p>
<ol>
<li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li>
<li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>
</ol>
<p><strong>面试官：为什么数组长度要保证为2的幂次方呢？</strong></p>
<p>答：</p>
<ol>
<li>只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，即实现了key的定位，2的幂次方也可以减少冲突次数，提高HashMap的查询效率；</li>
<li>如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length - 1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0 ，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。</li>
</ol>
<p><strong>面试官：那为什么是两次扰动呢？</strong></p>
<p>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</p>
<h2 id="7-HashMap在JDK1-7和JDK1-8中有哪些不同？"><a href="#7-HashMap在JDK1-7和JDK1-8中有哪些不同？" class="headerlink" title="7. HashMap在JDK1.7和JDK1.8中有哪些不同？"></a>7. HashMap在JDK1.7和JDK1.8中有哪些不同？</h2><p>答：</p>
<table>
<thead>
<tr>
<th align="left">不同</th>
<th align="left">JDK 1.7</th>
<th align="left">JDK 1.8</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储结构</td>
<td align="left">数组 + 链表</td>
<td align="left">数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td align="left">初始化方式</td>
<td align="left">单独函数：<code>inflateTable()</code></td>
<td align="left">直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td align="left">hash值计算方式</td>
<td align="left">扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td align="left">扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td align="left">存放数据的规则</td>
<td align="left">无冲突时，存放数组；冲突时，存放链表</td>
<td align="left">无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td align="left">插入数据方式</td>
<td align="left">头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td align="left">尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td align="left">扩容后存储位置的计算方式</td>
<td align="left">全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td align="left">按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody></table>
<h2 id="8-为什么HashMap中String、Integer这样的包装类适合作为K？"><a href="#8-为什么HashMap中String、Integer这样的包装类适合作为K？" class="headerlink" title="8. 为什么HashMap中String、Integer这样的包装类适合作为K？"></a>8. 为什么HashMap中String、Integer这样的包装类适合作为K？</h2><p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p>
<ol>
<li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>
</ol>
<p><strong>面试官：如果我想要让自己的Object作为K应该怎么办呢？</strong></p>
<p>答：重写<code>hashCode()</code>和<code>equals()</code>方法</p>
<ol>
<li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>
</ol>
<p><strong>面试官：String的equals()源码是怎样的？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断调用equals()的是否是同一对象，如果是则直接返回；然后就将字符串转换为字数数组逐个比较，如果不相同则直接返回false，直到最后返回true。</p>
<p><strong>面试官：String的equals()源码是怎样的？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-ConcurrentHashMap和Hashtable的区别？"><a href="#9-ConcurrentHashMap和Hashtable的区别？" class="headerlink" title="9. ConcurrentHashMap和Hashtable的区别？"></a>9. ConcurrentHashMap和Hashtable的区别？</h2><p>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
<p>面试官：ConcurrentHashMap的具体实现知道吗？**</p>
<blockquote>
<p>参考资料：<a href="http://www.importnew.com/23610.html" target="_blank" rel="noopener">http://www.importnew.com/23610.html</a></p>
</blockquote>
<p>答：<strong>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现</strong>，结构如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H6Yq0g7vN8wDd1ice2KnqQ5FX6AhjvuFjlJrO74TTia3H8ib9J06X1ssZjibiaFXibcLJwZpnN2zTV9nGibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<ol>
<li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>
<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，结构如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H6Yq0g7vN8wDd1ice2KnqQ5FCS3F2FryduzQQ9e8lP4ZwFPxz00Uw2bOQE8GfuEXfdkPBHCicBOtRmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>插入元素过程（建议去看看源码）：</p>
<ol>
<li>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,<span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    </span><br><span class="line">    binCount = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">        K ek;        </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key ||             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;            <span class="keyword">break</span>;        &#125;        Node&lt;K,V&gt; pred = e;        <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;            pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);            <span class="keyword">break</span>;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
<h2 id="10-Java集合的快速失败机制-“fail-fast”？"><a href="#10-Java集合的快速失败机制-“fail-fast”？" class="headerlink" title="10. Java集合的快速失败机制 “fail-fast”？"></a>10. Java集合的快速失败机制 “fail-fast”？</h2><p>答：</p>
<p><strong>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</strong></p>
<p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p>
<p><strong>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1. 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</strong></p>
<p><strong>2. 使用CopyOnWriteArrayList来替换ArrayList</strong></p>
<p>记住2点</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>利用Iterator操作集合更新操作，<span class="comment">remove、add</span></span><br><span class="line"><span class="number">2.</span>一个异常 ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>阿里代码规范也是这么规定的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 正例：  </span></span><br><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();  </span><br><span class="line"> list.add(<span class="string">"1"</span>);  </span><br><span class="line"> list.add(<span class="string">"2"</span>);  </span><br><span class="line"> Iterator&lt;String&gt; iterator = list.iterator();  </span><br><span class="line"> <span class="keyword">while</span> (iterator.hasNext()) &#123;      </span><br><span class="line">     String item = iterator.next();      </span><br><span class="line">     <span class="keyword">if</span> (删除元素的条件) &#123;          </span><br><span class="line">         iterator.remove();      </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 反例：      </span></span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;      </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"1"</span>.equals(item)) &#123;          </span><br><span class="line">        list.remove(item);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="11-HashMap直接背诵的内容"><a href="#11-HashMap直接背诵的内容" class="headerlink" title="11.HashMap直接背诵的内容"></a>11.HashMap直接背诵的内容</h2><p>hashmap是数组和链表的组合结构，数组是一个Entry数组，entry是k-V键值对类型，所以一个entry数组存着很entry节点，一个entry的位置通过key的hashcode方法，再进行hash（移位等操作），最后与表长-1进行相与操作，其实就是取hash值到的后n - 1位，n代表表长是2的n次方。</p>
<p>hashmap的默认负载因子是0.75，阈值是16 * 0.75 = 12；初始长度为16；</p>
<p>hashmap的增删改查方式比较简单，都是遍历，替换。有一点要注意的是key相等时，替换元素，不相等时连成链表。</p>
<p>除此之外，1.8jdk改进了hashmap，当链表上的元素个数超过8个时自动转化成红黑树，节点变成树节点，以提高搜索效率和插入效率到logn。</p>
<p>还有一点值得一提的是，hashmap的扩容操作，由于hashmap非线程安全，扩容时如果多线程并发进行操作，则可能有两个线程分别操作新表和旧表，导致节点成环，查询时会形成死锁。chm避免了这个问题。</p>
<p>另外，扩容时会将旧表元素移到新表，原来的版本移动时会有rehash操作，每个节点都要rehash，非常不方便，而1.8改成另一种方式，对于同一个index下的链表元素，由于一个元素的hash值在扩容后只有两种情况，要么是hash值不变，要么是hash值变为原来值+2^n次方，这是因为表长翻倍，所以hash值取后n位，第一位要么是0要么是1，所以hash值也只有两种情况。这两种情况的元素分别加到两个不同的链表。这两个链表也只需要分别放到新表的两个位置即可，是不是很酷。</p>
<p>最后有一个比较冷门的知识点，hashmap1.7版本链表使用的是节点的头插法，扩容时转移链表仍然使用头插法，这样的结果就是扩容后链表会倒置，而hashmap.1.8在插入时使用尾插法，扩容时使用头插法，这样可以保证顺序不变。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Map集合之TreeMap源码解析</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Map%E9%9B%86%E5%90%88%E4%B9%8BTreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>TreeMap最早出现在JDK 1.2中，是 Java 集合框架中比较重要一个的实现。TreeMap 底层基于红黑树实现，可保证在log(n)时间复杂度内完成 containsKey、get、put 和 remove 操作，效率很高。另一方面，由于 TreeMap 基于红黑树实现，这为 TreeMap 保持键的有序性打下了基础。总的来说，TreeMap 的核心是红黑树，其很多方法也是对红黑树增删查基础操作的一个包装。所以只要弄懂了红黑树，TreeMap 就没什么秘密了。</p>
<h2 id="2-概览"><a href="#2-概览" class="headerlink" title="2. 概览"></a>2. 概览</h2><p>TreeMap继承自AbstractMap，并实现了 NavigableMap接口。NavigableMap 接口继承了SortedMap接口，SortedMap 最终继承自Map接口，同时 AbstractMap 类也实现了 Map 接口。以上就是 TreeMap 的继承体系，描述起来有点乱，不如看图了：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/j0ROiac4adEuG7A0uicCZxL1ZLKPLibRRX8tngfSb85lAPhtalIN3spwPvuUpHfWIAhibpsof2JhOIFCpvRNFmtZQQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>上图就是 TreeMap 的继承体系图，比较直观。这里来简单说一下继承体系中不常见的接口NavigableMap和SortedMap，这两个接口见名知意。先说 NavigableMap 接口，NavigableMap 接口声明了一些列具有导航功能的方法，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回红黑树中最小键所对应的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map.<span class="function">Entry&lt;K,V&gt; <span class="title">firstEntry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回最大的键 maxKey，且 maxKey 仅小于参数 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">K <span class="title">lowerKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回最小的键 minKey，且 minKey 仅大于参数 key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">K <span class="title">higherKey</span><span class="params">(K key)</span></span>;</span><br><span class="line"><span class="comment">// 其他略</span></span><br></pre></td></tr></table></figure>

<p>通过这些导航方法，我们可以快速定位到目标的 key 或 Entry。至于 SortedMap 接口，这个接口提供了一些基于有序键的操作，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回包含键值在 [minKey, toKey) 范围内的 Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回包含键值在 [fromKey, toKey) 范围内的 Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"><span class="comment">// 其他略</span></span><br></pre></td></tr></table></figure>

<p>以上就是两个接口的介绍，很简单。至于 AbstractMap 和 Map 这里就不说了，大家有兴趣自己去看看 Javadoc 吧。关于 TreeMap 的继承体系就这里就说到这，接下来我们进入细节部分分析。</p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>JDK 1.8中的TreeMap源码有两千多行，还是比较多的。本文并不打算逐句分析所有的源码，而是挑选几个常用的方法进行分析。这些方法实现的功能分别是查找、遍历、插入、删除等，其他的方法小伙伴们有兴趣可以自己分析。TreeMap实现的核心部分是关于红黑树的实现，其绝大部分的方法基本都是对底层红黑树增、删、查操作的一个封装。如简介一节所说，只要弄懂了红黑树原理，TreeMap 就没什么秘密了。关于红黑树的原理，请参考本人的另一篇文章-<a href="https://mp.weixin.qq.com/s?__biz=MzI5ODI5NDkxMw==&mid=2247486449&idx=1&sn=06b3b8eb1137bbab0a997d14f98cde82&chksm=eca9401fdbdec909175d1d2ab63da9aef200b25ec8a7c535b3492c5779725ccac5cffd80805c&scene=21#wechat_redirect" target="_blank" rel="noopener">红黑树详细分析，看了都说好</a>，本篇文章不会对此展开讨论。</p>
<h3 id="3-1-查找"><a href="#3-1-查找" class="headerlink" title="3.1 查找"></a>3.1 查找</h3><p>TreeMap基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以 TreeMap 的查找操作流程和二叉查找树一致。二叉树的查找流程是这样的，先将目标值和根节点的值进行比较，如果目标值小于根节点的值，则再和根节点的左孩子进行比较。如果目标值大于根节点的值，则继续和根节点的右孩子比较。在查找过程中，如果目标值和二叉树中的某个节点值相等，则返回 true，否则返回 false。TreeMap 查找和此类似，只不过在 TreeMap 中，节点（Entry）存储的是键值对 。在查找过程中，比较的是键的大小，返回的是值，如果没找到，则返回null。TreeMap 中的查找方法是get，具体实现在getEntry方法中，相关源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据key查找元素</span></span><br><span class="line">	Entry &lt;K,V&gt; p = getEntry(key);</span><br><span class="line">	<span class="comment">// 找到了返回value值，没找到返回null</span></span><br><span class="line">	<span class="keyword">return</span>	(p == <span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果comparator不为空，使用comparator的版本获取元素</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="comment">// 如果key为空返回空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">// 将key强转为Comparable</span></span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果小于0从左子树查找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果大于0从右子树查找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			<span class="comment">// 如果相等说明找到了直接返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是使用Comparator比较器，则调用的是这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从根元素开始遍历</span></span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="comment">// 如果小于0从左子树查找</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果大于0从右子树查找</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果相等说明找到了直接返回</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1）从root遍历整个树；</p>
<p>（2）如果待查找的key比当前遍历的key小，则在其左子树中查找；</p>
<p>（3）如果待查找的key比当前遍历的key大，则在其右子树中查找；</p>
<p>（4）如果待查找的key与当前遍历的key相等，则找到了该元素，直接返回；</p>
<p>（5）从这里可以看出是否有comparator分化成了两个方法，但是内部逻辑一模一样，因此可见笔者 <code>comparator=(k1,k2)-&gt;((Comparable)k1).compareTo(k2);</code>这种改造的必要性。</p>
<h3 id="3-2-左右旋转"><a href="#3-2-左右旋转" class="headerlink" title="3.2 左右旋转"></a>3.2 左右旋转</h3><p>TreeMap只使用到了红黑树，所以它的时间复杂度为O(log n)，我们再来回顾一下红黑树的特性。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSELcibFqrqn6eliawBKI7YkD0B2yWXrtWDGkBL0rBAN8CvKvBcDOHtEQqa4rAXNicibT4wQnrEXsXndg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>（1）每个节点或者是黑色，或者是红色。</p>
<p>（2）根节点是黑色。</p>
<p>（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</p>
<p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p><strong><em>左旋</em></strong></p>
<p>左旋，就是以某个节点为支点向左旋转。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/Naw09lVL3GSELcibFqrqn6eliawBKI7YkDTlqdauqBwVBKOriaLGsS0gic5fsicMs65mqMbCCs9iaXqXlUOdibNX1RQaQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>整个左旋过程如下：</p>
<p>（1）将 y的左节点 设为 x的右节点，即将 β 设为 x的右节点；</p>
<p>（2）将 x 设为 y的左节点的父节点，即将 β的父节点 设为 x；</p>
<p>（3）将 x的父节点 设为 y的父节点；</p>
<p>（4）如果 x的父节点 为空节点，则将y设置为根节点；如果x是它父节点的左（右）节点，则将y设置为x父节点的左（右）节点；</p>
<p>（5）将 x 设为 y的左节点；</p>
<p>（6）将 x的父节点 设为 y；</p>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以p为支点进行左旋</span></span><br><span class="line"><span class="comment"> * 假设p为图中的x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// p的右节点，即y</span></span><br><span class="line">		Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">		<span class="comment">// （1）将 y的左节点 设为 x的右节点</span></span><br><span class="line">		p.right = r.left;</span><br><span class="line">		<span class="comment">// （2）将 x 设为 y的左节点的父节点（如果y的左节点存在的话）</span></span><br><span class="line">		<span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">			r.left.parent = p;</span><br><span class="line">		<span class="comment">// （3）将 x的父节点 设为 y的父节点</span></span><br><span class="line">		r.parent = p.parent;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// （4）...</span></span><br><span class="line">		<span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">//如果 x的父节点 为空，则将y设置为根节点</span></span><br><span class="line">			root = r;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">			<span class="comment">// 如果x是它父节点的左节点，则将y设置为x父节点的左节点</span></span><br><span class="line">			p.parent.left = r;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment">// 如果x是它父节点的右节点，则将y设置为x父节点的右节点</span></span><br><span class="line">			p.parent.right = r;</span><br><span class="line">		<span class="comment">// （5）将 x 设为 y的左节点</span></span><br><span class="line">        r.left = p;</span><br><span class="line">		<span class="comment">// （6）将 x的父节点 设为 y</span></span><br><span class="line">		p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>右旋</em></strong></p>
<p>右旋，就是以某个节点为支点向右旋转。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/Naw09lVL3GSELcibFqrqn6eliawBKI7YkDugJ2yXfcHZA9ic2IudammYXNOWAVhRKOFfej2ToiblRzFvx95KdicC2xw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>整个右旋过程如下：</p>
<p>（1）将 x的右节点 设为 y的左节点，即 将 β 设为 y的左节点；</p>
<p>（2）将 y 设为 x的右节点的父节点，即 将 β的父节点 设为 y；</p>
<p>（3）将 y的父节点 设为 x的父节点；</p>
<p>（4）如果 y的父节点 是 空节点，则将x设为根节点；如果y是它父节点的左（右）节点，则将x设为y的父节点的左（右）节点；</p>
<p>（5）将 y 设为 x的右节点；</p>
<p>（6）将 y的父节点 设为 x；</p>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以p为支点进行右旋</span></span><br><span class="line"><span class="comment"> * 假设p为图中的y</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// p的左节点，即x</span></span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        <span class="comment">// （1）将 x的右节点 设为 y的左节点</span></span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="comment">// （2）将 y 设为 x的右节点的父节点（如果x有右节点的话）</span></span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        <span class="comment">// （3）将 y的父节点 设为 x的父节点</span></span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="comment">// （4）...</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果 y的父节点 是 空节点，则将x设为根节点</span></span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            <span class="comment">// 如果y是它父节点的右节点，则将x设为y的父节点的右节点</span></span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果y是它父节点的左节点，则将x设为y的父节点的左节点</span></span><br><span class="line">            p.parent.left = l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （5）将 y 设为 x的右节点</span></span><br><span class="line">        l.right = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （6）将 y的父节点 设为 x</span></span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-插入"><a href="#3-3-插入" class="headerlink" title="3.3 插入"></a>3.3 插入</h3><p>插入元素，如果元素在树中存在，则替换value；如果元素不存在，则插入到对应的位置，再平衡树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有根节点，直接插入到根节点</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key比较的结果</span></span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">	<span class="comment">// 用来寻找待插入节点的父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// 根据是否有comparator使用不同的分支</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果使用的是comparator方式，key值可以为null，只要在comparator.compare()中允许即可</span></span><br><span class="line">        <span class="comment">// 从根节点开始遍历寻找</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果小于0从左子树寻找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果大于0从右子树寻找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果使用的是Comparable方式，key不能为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="comment">// 从根节点开始遍历寻找</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="comment">// 如果小于0从左子树寻找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果大于0从右子树寻找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没找到，那么新建一个节点，并插入到树中</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果小于0插入到左子节点</span></span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果大于0插入到右子节点</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">	<span class="comment">// 插入之后的平衡</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="comment">// 元素个数加1（不需要扩容）</span></span><br><span class="line">    size++;</span><br><span class="line">	<span class="comment">// 修改次数加1</span></span><br><span class="line">    modCount++; </span><br><span class="line">	<span class="comment">// 如果插入了新节点返回空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>插入再平衡</em></strong></p>
<p>插入的元素默认都是红色，因为插入红色元素只违背了第4条特性，那么我们只要根据这个特性来平衡就容易多了。</p>
<p>根据不同的情况有以下几种处理方式：</p>
<ol>
<li><p>插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；</p>
</li>
<li><p>插入的元素的父节点如果为黑色，不需要平衡；</p>
</li>
<li><p>插入的元素的父节点如果为红色，则违背了特性4，需要平衡，平衡时又分成下面三种情况：</p>
</li>
</ol>
<p><strong>（如果父节点是祖父节点的左节点）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）父节点为红色，叔叔节点也为红色</td>
<td>（1）将父节点设为黑色；<br>（2）将叔叔节点设为黑色；<br>（3）将祖父节点设为红色；<br>（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td>
</tr>
<tr>
<td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td>
<td>（1）将父节点作为新的当前节点；<br>（2）以新当节点为支点进行左旋，进入情况3）；</td>
</tr>
<tr>
<td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td>
<td>（1）将父节点设为黑色；<br>（2）将祖父节点设为红色；<br>（3）以祖父节点为支点进行右旋，进入下一次循环判断；</td>
</tr>
</tbody></table>
<p><strong>（如果父节点是祖父节点的右节点，则正好与上面反过来）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）父节点为红色，叔叔节点也为红色</td>
<td>（1）将父节点设为黑色；<br>（2）将叔叔节点设为黑色；<br>（3）将祖父节点设为红色；<br>（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td>
</tr>
<tr>
<td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td>
<td>（1）将父节点作为新的当前节点；<br>（2）以新当节点为支点进行右旋；</td>
</tr>
<tr>
<td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td>
<td>（1）将父节点设为黑色；<br>（2）将祖父节点设为红色；<br>（3）以祖父节点为支点进行左旋，进入下一次循环判断；</td>
</tr>
</tbody></table>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入再平衡</span></span><br><span class="line"><span class="comment"> *（1）每个节点或者是黑色，或者是红色。</span></span><br><span class="line"><span class="comment"> *（2）根节点是黑色。</span></span><br><span class="line"><span class="comment"> *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span></span><br><span class="line"><span class="comment"> *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span></span><br><span class="line"><span class="comment"> *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入的节点为红节点，x为当前节点</span></span><br><span class="line">    x.color = RED;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 只有当插入节点不是根节点且其父节点为红色时才需要平衡（违背了特性4）</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// a）如果父节点是祖父节点的左节点</span></span><br><span class="line">            <span class="comment">// y为叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1）如果叔叔节点为红色</span></span><br><span class="line">				<span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将叔叔节点设为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// （3）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （4）将祖父节点设为新的当前节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">                <span class="comment">// 情况2）如果当前节点为其父节点的右节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// （1）将父节点设为当前节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">// （2）以新当前节点左旋</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3）如果当前节点为其父节点的左节点（如果是情况2）则左旋之后新当前节点正好为其父节点的左节点了）</span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （3）以祖父节点为支点进行右旋</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// b）如果父节点是祖父节点的右节点</span></span><br><span class="line">			<span class="comment">// y是叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">// 情况1）如果叔叔节点为红色</span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将叔叔节点设为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">// （3）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （4）将祖父节点设为新的当前节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;          </span><br><span class="line">				<span class="comment">// 如果叔叔节点为黑色</span></span><br><span class="line">				<span class="comment">// 情况2）如果当前节点为其父节点的左节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    <span class="comment">// （1）将父节点设为当前节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">// （2）以新当前节点右旋</span></span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况3）如果当前节点为其父节点的右节点（如果是情况2）则右旋之后新当前节点正好为其父节点的右节点了）</span></span><br><span class="line">                <span class="comment">// （1）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （2）将祖父节点设为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">// （3）以祖父节点为支点进行左旋</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡完成后将根节点设为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>插入元素举例</em></strong></p>
<p>我们依次向红黑树中插入 4、2、3 三个元素，来一起看看整个红黑树平衡的过程。</p>
<p>三个元素都插入完成后，符合父节点是祖父节点的左节点，叔叔节点为黑色，且当前节点是其父节点的右节点，即情况2）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSELcibFqrqn6eliawBKI7YkDY8lQcPLDH3JGLalTa5dfApj5Gbjqks0shFbJ6G0ibmcq1QicrGvQVVYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>情况2）需要做以下两步处理：</p>
<p>（1）将父节点作为新的当前节点；</p>
<p>（2）以新当节点为支点进行左旋，进入情况3）；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSELcibFqrqn6eliawBKI7YkDRAzCNMEjgOUD5JWOegCfSvQRXkfk7fFJy5GrPBZ0YfQdyvz2UNt9DA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>情况3）需要做以下三步处理：</p>
<p>（1）将父节点设为黑色；</p>
<p>（2）将祖父节点设为红色；</p>
<p>（3）以祖父节点为支点进行右旋，进入下一次循环判断；</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSELcibFqrqn6eliawBKI7YkDgYOVmKXibepaIalpAS7ia3sPursspdpaib1BLWzRqictibzCkS0Sh3cIMuA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>下一次循环不符合父节点为红色了，退出循环，插入再平衡完成。</p>
<p>其实可以也可以参考下：<a href="https://mp.weixin.qq.com/s/-6bPlmr_ckLeUeK7INXQNA" target="_blank" rel="noopener">程序员小灰——什么是红黑树？</a></p>
<h3 id="3-4-删除"><a href="#3-4-删除" class="headerlink" title="3.4 删除"></a>3.4 删除</h3><p>删除元素本身比较简单，就是采用二叉树的删除规则。</p>
<p>（1）如果删除的位置有两个叶子节点，则从其右子树中取最小的元素放到删除的位置，然后把删除位置移到替代元素的位置，进入下一步。</p>
<p>（2）如果删除的位置只有一个叶子节点（有可能是经过第一步转换后的删除位置），则把那个叶子节点作为替代元素，放到删除的位置，然后把这个叶子节点删除。</p>
<p>（3）如果删除的位置没有叶子节点，则直接把这个删除位置的元素删除即可。</p>
<p>（4）针对红黑树，如果删除位置是黑色节点，还需要做再平衡。</p>
<p>（5）如果有替代元素，则以替代元素作为当前节点进入再平衡。</p>
<p>（6）如果没有替代元素，则以删除的位置的元素作为当前节点进入再平衡，平衡之后再删除这个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点</span></span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="comment">// 返回删除的value</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 元素个数减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点既有左子节点，又有右子节点</span></span><br><span class="line">        <span class="comment">// 取其右子树中最小的节点</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        <span class="comment">// 用右子树中最小节点的值替换当前节点的值</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        <span class="comment">// 把右子树中最小节点设为当前节点</span></span><br><span class="line">        p = s;</span><br><span class="line">		<span class="comment">// 这种情况实际上并没有删除p节点，而是把p节点的值改了，实际删除的是p的后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果原来的当前节点（p）有2个子节点，则当前节点已经变成原来p的右子树中的最小节点了，也就是说其没有左子节点了</span></span><br><span class="line">	<span class="comment">// 到这一步，p肯定只有一个子节点了    </span></span><br><span class="line">	<span class="comment">// 如果当前节点有子节点，则用子节点替换当前节点</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// 把替换节点直接放到当前节点的位置上（相当于删除了p，并把替换节点移动过来了）</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将p的各项属性都设为空.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果p是黑节点，则需要再平衡</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; </span><br><span class="line">		<span class="comment">// 如果当前节点就是根节点，则直接将根节点设为空即可</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 如果当前节点没有子节点且其为黑节点，则把自己当作虚拟的替换节点进行再平衡</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line">		<span class="comment">// 平衡完成后删除当前节点（与父节点断绝关系）</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>删除再平衡</em></strong></p>
<p>经过上面的处理，真正删除的肯定是黑色节点才会进入到再平衡阶段。</p>
<p>因为删除的是黑色节点，导致整颗树不平衡了，所以这里我们假设把删除的黑色赋予当前节点，这样当前节点除了它自已的颜色还多了一个黑色，那么：</p>
<p>（1）如果当前节点是根节点，则直接涂黑即可，不需要再平衡；</p>
<p>（2）如果当前节点是红+黑节点，则直接涂黑即可，不需要平衡；</p>
<p>（3）如果当前节点是黑+黑节点，则我们只要通过旋转把这个多出来的黑色不断的向上传递到一个红色节点即可，这又可能会出现以下四种情况：</p>
<p><strong>（假设当前节点为父节点的左子节点）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）x是黑+黑节点，x的兄弟是红节点</td>
<td>（1）将兄弟节点设为黑色；<br>（2）将父节点设为红色；<br>（3）以父节点为支点进行左旋；<br>（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>2）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td>
<td>（1）将兄弟节点设置为红色；<br>（2）将x的父节点作为新的当前节点，进入下一次循环；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为黑色，左子节点为红色</td>
<td>（1）将兄弟节点的左子节点设为黑色；<br>（2）将兄弟节点设为红色；<br>（3）以兄弟节点为支点进行右旋；<br>（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为红色，左子节点任意颜色</td>
<td>（1）将兄弟节点的颜色设为父节点的颜色；<br>（2）将父节点设为黑色；<br>（3）将兄弟节点的右子节点设为黑色；<br>（4）以父节点为支点进行左旋；<br>（5）将root作为新的当前节点（退出循环）；</td>
</tr>
</tbody></table>
<p><strong>（假设当前节点为父节点的右子节点，正好反过来）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td>1）x是黑+黑节点，x的兄弟是红节点</td>
<td>（1）将兄弟节点设为黑色；<br>（2）将父节点设为红色；<br>（3）以父节点为支点进行右旋；<br>（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>2）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td>
<td>（1）将兄弟节点设置为红色；<br>（2）将x的父节点作为新的当前节点，进入下一次循环；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为黑色，左子节点为红色</td>
<td>（1）将兄弟节点的右子节点设为黑色；<br>（2）将兄弟节点设为红色；<br>（3）以兄弟节点为支点进行左旋；<br>（4）重新设置x的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>3）x是黑+黑节点，x的兄弟是黑节点，且兄弟节点的右子节点为红色，左子节点任意颜色</td>
<td>（1）将兄弟节点的颜色设为父节点的颜色；<br>（2）将父节点设为黑色；<br>（3）将兄弟节点的左子节点设为黑色；<br>（4）以父节点为支点进行右旋；<br>（5）将root作为新的当前节点（退出循环）；</td>
</tr>
</tbody></table>
<p>让我们来看看TreeMap中的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除再平衡</span></span><br><span class="line"><span class="comment"> *（1）每个节点或者是黑色，或者是红色。</span></span><br><span class="line"><span class="comment"> *（2）根节点是黑色。</span></span><br><span class="line"><span class="comment"> *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span></span><br><span class="line"><span class="comment"> *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span></span><br><span class="line"><span class="comment"> *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 只有当前节点不是根节点且当前节点是黑色时才进入循环</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是其父节点的左子节点            </span></span><br><span class="line">			<span class="comment">// sib是当前节点的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">			<span class="comment">// 情况1）如果兄弟节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">				<span class="comment">// （1）将兄弟节点设为黑色</span></span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                <span class="comment">// （2）将父节点设为红色</span></span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// （3）以父节点为支点进行左旋</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                <span class="comment">// （4）重新设置x的兄弟节点，进入下一步</span></span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                <span class="comment">// 情况2）如果兄弟节点的两个子节点都是黑色</span></span><br><span class="line">                <span class="comment">// （1）将兄弟节点设置为红色</span></span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// （2）将x的父节点作为新的当前节点，进入下一次循环</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况3）如果兄弟节点的右子节点为黑色</span></span><br><span class="line">					<span class="comment">// （1）将兄弟节点的左子节点设为黑色</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">					<span class="comment">// （2）将兄弟节点设为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// （3）以兄弟节点为支点进行右旋</span></span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    <span class="comment">// （4）重新设置x的兄弟节点</span></span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况4	</span></span><br><span class="line">				<span class="comment">// （1）将兄弟节点的颜色设为父节点的颜色</span></span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                <span class="comment">// （2）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （3）将兄弟节点的右子节点设为黑色</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                <span class="comment">// （4）以父节点为支点进行左旋</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                <span class="comment">// （5）将root作为新的当前节点（退出循环）</span></span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="comment">// 如果当前节点是其父节点的右子节点</span></span><br><span class="line">			<span class="comment">// sib是当前节点的兄弟节点</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 情况1）如果兄弟节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                <span class="comment">// （1）将兄弟节点设为黑色</span></span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                <span class="comment">// （2）将父节点设为红色</span></span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// （3）以父节点为支点进行右旋</span></span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                <span class="comment">// （4）重新设置x的兄弟节点</span></span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                <span class="comment">// 情况2）如果兄弟节点的两个子节点都是黑色</span></span><br><span class="line">				<span class="comment">// （1）将兄弟节点设置为红色</span></span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// （2）将x的父节点作为新的当前节点，进入下一次循环</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// 情况3）如果兄弟节点的左子节点为黑色</span></span><br><span class="line">					<span class="comment">// （1）将兄弟节点的右子节点设为黑色</span></span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    <span class="comment">// （2）将兄弟节点设为红色</span></span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    <span class="comment">// （3）以兄弟节点为支点进行左旋</span></span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    <span class="comment">// （4）重新设置x的兄弟节点</span></span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 情况4）</span></span><br><span class="line">				<span class="comment">// （1）将兄弟节点的颜色设为父节点的颜色</span></span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                <span class="comment">// （2）将父节点设为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">// （3）将兄弟节点的左子节点设为黑色</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                <span class="comment">// （4）以父节点为支点进行右旋</span></span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                <span class="comment">// （5）将root作为新的当前节点（退出循环）</span></span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">// 退出条件为多出来的黑色向上传递到了根节点或者红节点</span></span><br><span class="line">	<span class="comment">// 则将x设为黑色即可满足红黑树规则</span></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>删除元素举例</em></strong></p>
<p>假设我们有下面这样一颗红黑树。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSkictA70DlibJq3ia079vjAty9koCVeAiaaRtibI46ianwWQqeJs867dsf8Q4yEvCmmXkmIAkibXibicAgXBA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>我们删除6号元素，则从右子树中找到了最小元素7，7又没有子节点了，所以把7作为当前节点进行再平衡。</p>
<p>我们看到7是黑节点，且其兄弟为黑节点，且其兄弟的两个子节点都是红色，满足情况4），平衡之后如下图所示。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSkictA70DlibJq3ia079vjAtyPjHzAf2AMeqtsKj7Jibs7GM9rNWo6OgIghwxrBgyMEcKtGV8nAbEjzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>我们再删除7号元素，则从右子树中找到了最小元素8，8有子节点且为黑色，所以8的子节点9是替代节点，以9为当前节点进行再平衡。</p>
<p>我们发现9是红节点，则直接把它涂成黑色即满足了红黑树的特性，不需要再过多的平衡了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSkictA70DlibJq3ia079vjAtyEtNrQfTcBS6lfh08H62Qd0vpCKSRKwwBWdnMEQvdSibqorybSZic1DUQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>这次我们来个狠的，把根节点删除，从右子树中找到了最小的元素5，5没有子节点，所以把5作为当前节点进行再平衡。</p>
<p>我们看到5是黑节点，且其兄弟为红色，符合情况1），平衡之后如下图所示，然后进入情况2）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSkictA70DlibJq3ia079vjAtyfZiau3GHZ7aibgChyXVJkCpuicD0cpH3cxjNg4eje3Ueyz3qz9UIJVC3A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>对情况2）进行再平衡后如下图所示。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSkictA70DlibJq3ia079vjAtyt2piaBh1L4G1f75D1XZBYBWmcN8vgLmloyiaS2AYVzSy5atGD8zfz0GA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>然后进入下一次循环，发现不符合循环条件了，直接把x涂为黑色即可，退出这个方法之后会把旧x删除掉（见deleteEntry()方法），最后的结果就是下面这样。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Naw09lVL3GSkictA70DlibJq3ia079vjAtyx5MziadAIYfCqc6Qa2EiatFKgibPJQt9JCia1k7sSVUrwnDxHm3VZ1xlkQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<hr>
<h3 id="3-5-遍历"><a href="#3-5-遍历" class="headerlink" title="3.5 遍历"></a>3.5 遍历</h3><p>我们知道二叉查找树的遍历有前序遍历、中序遍历、后序遍历。</p>
<p>（1）前序遍历，先遍历我，再遍历我的左子节点，最后遍历我的右子节点；</p>
<p>（2）中序遍历，先遍历我的左子节点，再遍历我，最后遍历我的右子节点；</p>
<p>（3）后序遍历，先遍历我的左子节点，再遍历我的右子节点，最后遍历我；</p>
<p>这里的前中后都是以“我”的顺序为准的，我在前就是前序遍历，我在中就是中序遍历，我在后就是后序遍历。</p>
<p>在二叉树的前中后序遍历中通常使用<strong><em>递归遍历</em></strong>，但是使用递归会占用额外的空间直到线程栈整个释放掉才会把方法中申请的变量销毁。所以当元素特别多时这种操作实际上是极其危险的。下面看看TreeMap的遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="comment">// 遍历前的修改次数</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">// 执行遍历，先获取第一个元素的位置，再循环遍历后继节点</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e)) &#123;</span><br><span class="line">        <span class="comment">// 执行动作</span></span><br><span class="line">        action.accept(e.key, e.value);</span><br><span class="line">		<span class="comment">// 如果发现修改次数变了，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (expectedModCount != modCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面涉及到了两个步骤：</p>
<p>（1）寻找第一个节点；</p>
<p>从根节点开始找最左边的节点，即最小的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getFirstEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="comment">// 从根节点开始找最左边的节点，即最小的元素</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）循环遍历后继节点；</p>
<p>寻找后继节点这个方法我们在删除元素的时候也用到过，当时的场景是有右子树，则从其右子树中寻找最小的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果当前节点为空，返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点有右子树，取右子树中最小的节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点没有右子树</span></span><br><span class="line">		<span class="comment">// 如果当前节点是父节点的左子节点，直接返回父节点</span></span><br><span class="line">		<span class="comment">// 如果当前节点是父节点的右子节点，一直往上找，直到找到一个祖先节点是其父节点的左子节点为止，返回这个祖先节点的父节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们一起来分析下这种方式的时间复杂度吧。</p>
<p>首先，寻找第一个元素，因为红黑树是接近平衡的二叉树，所以找最小的节点，相当于是从顶到底了，时间复杂度为O(log n)；</p>
<p>其次，寻找后继节点，因为红黑树插入元素的时候会自动平衡，最坏的情况就是寻找右子树中最小的节点，时间复杂度为O(log k)，k为右子树元素个数；</p>
<p>最后，需要遍历所有元素，时间复杂度为O(n)；</p>
<p>所以，总的时间复杂度为 O(log n) + O(n * log k) ≈ O(n)。</p>
<p>虽然遍历红黑树的时间复杂度是O(n)，但是它实际是要比跳表要慢一点的，啥？跳表是啥？安心，后面会讲到跳表的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>到这里红黑树就整个讲完了，让我们再回顾下红黑树的特性：</p>
<p>（1）每个节点或者是黑色，或者是红色。</p>
<p>（2）根节点是黑色。</p>
<p>（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</p>
<p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</p>
<p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>除了上述这些标准的红黑树的特性，你还能讲出来哪些TreeMap的特性呢？</p>
<p>（1）TreeMap的存储结构只有一颗红黑树；</p>
<p>（2）TreeMap中的元素是有序的，按key的顺序排列；</p>
<p>（3）TreeMap比HashMap要慢一些，因为HashMap前面还做了一层桶，寻找元素要快很多；</p>
<p>（4）TreeMap没有扩容的概念；</p>
<p>（5）TreeMap的遍历不是采用传统的递归式遍历；</p>
<p>（6）TreeMap可以按范围查找元素，查找最近的元素；</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>默认文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Map集合之HashTable源码解析</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Map%E9%9B%86%E5%90%88%E4%B9%8BHashTable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在上篇文章中，我们学习了HashMap的源码，了解了其底层数据结构及实现原理。今天我们再来学习一下Map的另一个子类HashTable，我们会学习到HashTable的实现原理及其同HashMap的区别，源码为Java8版本。</p>
<h2 id="2-底层数据结构"><a href="#2-底层数据结构" class="headerlink" title="2. 底层数据结构"></a>2. 底层数据结构</h2><p>同样我们首先来了解下HashTable的底层数据结构，在HashTable中使用的是哈希表（数组+单向链表）的结构来实现的，每个元素是一个Entry对象，包含key、value、哈希和下个元素的引用等信息，相比HashMap要少一个红黑树的结构，因此HashTable的逻辑要比HashMap简单，其结构如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/fQaq9icNRMmZfL8fZr0SGP5ro2OaQv20QsStftJkFWVWTib2rAUX8M1vfVR3tVJtniar9sRMEljMHQW7nUt6xa8qQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>Entry的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Entry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key =  key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>hash：由key的hashCode方法取得</p>
</li>
<li><p>key：键</p>
</li>
<li><p>value：值</p>
</li>
<li><p>next：链表下个节点的引用</p>
</li>
</ul>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>了解了使用的数据结构后，我们开始查看源码学习其处理的逻辑。</p>
<p>在前言中我们说过HashTable是一个线程安全的集合类，通过查看源码我们发现每个方法都被synchronized修饰，因此其线程安全是使用synchronized同步关键字来实现的，这种同步方法实现的线程安全是比较消耗性能的，我们之后会再分析另一个更高效的线程安全的Map（<span style="color:red">ConcurrentHashMap</span>)感兴趣的同学可以先了解一下。</p>
<h3 id="3-1-类的继承关系"><a href="#3-1-类的继承关系" class="headerlink" title="3.1 类的继承关系"></a>3.1 类的继承关系</h3><p>由于Hashtable类通常和HashMap和ConcurrentHashMap比较，所以这里看一下这三个类的继承关系</p>
<p><img src="images/20191225164544.png" alt></p>
<p>主要实现了如下接口：</p>
<p><strong><em>Map接口</em></strong>：需要实现该接口中的全部方法</p>
<p><strong><em>Cloneable接口</em></strong>：允许数据复制</p>
<p><strong><em>Serializable接口</em></strong>：允许进行序列化</p>
<h3 id="3-1-属性字段"><a href="#3-1-属性字段" class="headerlink" title="3.1. 属性字段"></a>3.1. 属性字段</h3><p>还是老规矩，我们也先查看一下在HashTable中存在什么属性字段，在学习了HashMap后，相信大家看到HashTable中的属性字段会感觉很熟悉，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">// 存储的元素数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 需要进行rehash的值 数组长度*负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 对HashTable的修改次数 调用put、remove、clear等方法会加1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>通过查看源码我们发现在HashTable中的字段中似乎没有默认长度和负载因子大小，那我们调用空参构造方法时这两个值是多少呢？不要慌，这点我们在往下看他的构造方法。</p>
<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2  构造方法"></a>3.2  <strong>构造方法</strong></h3><p>其构造方法同HashMap的构造方法一样也是有四个，所需的参数也一样，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定数组大小和负载因子的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">// count超过该值会进行rehash</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定数组长度，负载因子使用默认的0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空参  数组大小默认值为11，负载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HashTable的构造方法中我们找到了数组的默认长度为11，负载因子默认值为0.75</p>
<h3 id="3-3-插入操作"><a href="#3-3-插入操作" class="headerlink" title="3.3 插入操作"></a>3.3 插入操作</h3><p>HashTable的put方法源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// value不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 调用key的hashCode方法获取哈希值</span></span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 定位元素在数组上的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="comment">// 遍历链表，查找key是否存在，存在覆盖其value并返回原值</span></span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            <span class="comment">// 重置value</span></span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">// 返回原值</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key不存在，添加新的节点</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key不存在，添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// modCount值加1</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 元素的数量是否达到扩容的数量</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// 进行扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">        <span class="comment">// 重新计算元素在新数组中的位置</span></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">// 存入元素</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 元素数量加1</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中扩容操作代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 新容量为旧容量的 2 倍加 1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 若新容量的值超过最大容量 MAX_ARRAY_SIZE，且旧容量为 MAX_ARRAY_SIZE，则直接返回；</span></span><br><span class="line">    <span class="comment">// 若旧容量值不为 MAX_ARRAY_SIZE，则新容量为 MAX_ARRAY_SIZE.</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建一个 Entry 数组，容量为上面计算的容量大小</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">    modCount++;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            <span class="comment">// 注意这里会调换顺序</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容过程：</p>
<p>（1）将新容量设置为旧容量*2+1</p>
<p>（2）如果新容量超过了旧容量，当旧容量已经等于MAX_ARRAY_SIZE，则直接返回。否则设置新容量为MAX_ARRAY_SIZE</p>
<p>（3）依次将旧数组中的数据添加大新数组中。</p>
<p><strong>同HashMap的区别如下</strong>：</p>
<ul>
<li><p>HashTabel的key和value不能为null，否则会抛出NullPointException</p>
</li>
<li><p>元素的hash算法不同，在HashTable中使用的是key的hashCode方法</p>
</li>
<li><p>元素的定位不同，在HashTable中采用的是同数组长度取模的方式定位</p>
</li>
</ul>
<p>处理过程如下图所示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/fQaq9icNRMmZfL8fZr0SGP5ro2OaQv20QBOWtwClRvDEMTSD2LQpiaOTE4d9MGORTjNxn3lnOebrac63Wlskqvcg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>HashTable的逻辑还是比较简单的，其他的API感兴趣的自己进行查看吧。</p>
<h3 id="3-4-获取操作"><a href="#3-4-获取操作" class="headerlink" title="3.4 获取操作"></a>3.4 获取操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">// 计算数组index</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="comment">// 比较返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>HashTable的特点：</p>
<ul>
<li>无序</li>
<li>key唯一</li>
<li>线程安全</li>
<li>key和value均不能为null</li>
</ul>
<blockquote>
<ol>
<li>首先，Hashtable底层是通过数组加链表实现的，这点和JDK1.8之前的HashMap差不多。</li>
<li>其次，Hashtable是不允许key或者value为null的。</li>
<li>并且，Hashtable的计算索引方法，默认容量大小，扩容方法都与HashMap不太一样。</li>
<li>其实我们可以看到，Hashtable之所以线程安全，大部分方法都是使用了synchronized关键字，虽然JDK优化了synchronized，但在方法上使用该关键字，无疑仍旧是效率低下的操作。就这方面来说，ConcurrentHashMap无疑比Hashtable好多了，后续会有专门文章介绍ConcurrentHashMap，这里就不多说了。</li>
</ol>
</blockquote>
<p>  总之呢，Hashtable无疑算是废掉了，说不定过不了多久，它就消失在Map框架中了呢。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/xBvu2VEV9UQkcjCSLC78PQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/xBvu2VEV9UQkcjCSLC78PQ</a> </li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Map集合之HashMap源码解析</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Map%E9%9B%86%E5%90%88%E4%B9%8BHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h2 id="1-Map集合概览"><a href="#1-Map集合概览" class="headerlink" title="1. Map集合概览"></a>1. Map集合概览</h2><p><img src="images/20191217152358.png" alt></p>
<p>在Java集合中通常分为两类：Map集合和Collection集合。在Map集合中，主要研究上面五个类：HashMap、Hashtable、TreeMap、WeakHashMap以及LinkedHashMap四类。</p>
<p>Map的底层存储一般都是数组，因为数组可以满足常数时间内进行<strong>get</strong>和<strong>put</strong>操作。对于Map结构的数据需要解决两个问题：</p>
<p>（1）<strong>获取坐标索引index</strong>：而数组的下标一般是由一个哈希函数来获得，在常见的数据结构教材中，一般为对数组长度取模，可以保证哈希函数得到的index范围在[0，len-1]之间，不会数组越界，并且可以利用到数组的所有位置。除了取模这种hash算法，还有很多其他的算法，各有优劣。</p>
<p>（2）<strong>解决索引index重复的问题：</strong>除了hash算法，一个Map实现还需要解决index重复的问题，常见的有再hash法，开放地址法，拉链法等；<strong>在IDK8中，HashMap使用的是红黑树解决。</strong></p>
<p>（3）<strong>动态调整数组的大小：</strong>解决了如何计算hash和解决冲突后，还需要面临的一个问题是，数组的大小都是固定的，那么随着Map存的数据越来越多，同一个下标存储的数据越来越多，存取的性能退化为O(n),数组如何动态的调整其大小来改善性能呢;<strong>HashMap通过一个叫做负载因子的变量来控制调整</strong>的时机。</p>
<h2 id="2-HashMap介绍"><a href="#2-HashMap介绍" class="headerlink" title="2. HashMap介绍"></a>2. HashMap介绍</h2><p>HashMap本质就是一个Node&lt;K, V&gt;数组，当put一个键值对到HashMap，首先将这个键值对封装成Node，然后根据key的hashcode计算出该Node应该放在数组哪个位置，如果这个位置已经被占，那么就在这个位置以链表的形式存储多个Node对象。HashMap大致的结构图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3sp0yMcd4YwVYd6gzQmic7sban71JBq6HksCSCBd7iaol4LI8oUO6dClHCpLz7NJYCibzZDibUAKT6S8jwAI02A1FA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>1.8之后，HashMap引入了红黑树。当链表的长度达到阈值之后，链表就会被树化，形成红黑树结构。大致结构图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/3sp0yMcd4YwVYd6gzQmic7sban71JBq6HR2z6Nj9zxib7RA5LYVMsTUuQoJNn9CKMhsOkb00GvQ4DuN90ibKbQxvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h2 id="3-HashMap源码分析"><a href="#3-HashMap源码分析" class="headerlink" title="3. HashMap源码分析"></a>3. HashMap源码分析</h2><h3 id="3-1-基本属性"><a href="#3-1-基本属性" class="headerlink" title="3.1 基本属性"></a>3.1 基本属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量16(必须是2的幂次方)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，2的30次方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认加载因子，用来计算threshold</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表转成树的阈值，当桶中链表长度大于8时转成树 </span></span><br><span class="line"><span class="comment">   threshold = capacity * loadFactor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行resize操作时，若桶中数量少于6则从树转成链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 当需要将解决 hash 冲突的链表转变为红黑树时，</span></span><br><span class="line"><span class="comment"> 需要判断下此时数组容量，</span></span><br><span class="line"><span class="comment"> 若是由于数组容量太小（小于　MIN_TREEIFY_CAPACITY　）</span></span><br><span class="line"><span class="comment"> 导致的 hash 冲突太多，则不进行链表转变为红黑树操作，</span></span><br><span class="line"><span class="comment"> 转为利用　resize() 函数对　hashMap 扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 保存Node&lt;K,V&gt;节点的数组</span></span><br><span class="line"><span class="comment"> 该表在首次使用时初始化，并根据需要调整大小。 分配时，</span></span><br><span class="line"><span class="comment"> 长度始终是2的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放具体元素的集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录 hashMap 当前存储的元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次更改map结构的计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载因子：要调整大小的下一个大小值（容量*加载因子）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor</span><br></pre></td></tr></table></figure>



<h3 id="3-2-构造函数"><a href="#3-2-构造函数" class="headerlink" title="3.2 构造函数"></a>3.2 构造函数</h3><p>使用集合类的第一步就是通过构造函数，HashMap的构造函数有多个，但其实类似，将从最常见的展开，顺带着其余的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造方法1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loadFactor即为前面提到的负载因子，默认值为0.75，这是最普通的、最常用的构造函数，所有内部参数都使用默认值，关于一些参数，后面用到时再详细介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 负载因子默认值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定构建对象的底层数组大小和负载因子。默认值分别为16和0.75.对传入的参数有一点限制，底层数组必须大于0小于最大容量(2的30次方)，并且会被调整为2的整数幂，原因后续介绍。通过tableSizeFor函数调整。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大容量设置为2的30次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + </span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法4</span></span><br><span class="line"><span class="comment">// 用一个已经存在的map初始化，用的不多，就在代码中稍微写点注释</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面存在部分方法进行说明</p>
<ul>
<li><p>tableSizeFor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过巧妙的位运算，将指定的cap变为大于等于cap的第一个2的幂次方整数，源码中多次利用位运算来进行速度优化</span></span><br><span class="line"><span class="comment">// n =       000..1XXXXXX假设n的二进制格式，1代表第一个1出现的位置，x为任意的0或1</span></span><br><span class="line"><span class="comment">// n &gt;&gt;&gt; 1 = 000..01xxxxx</span></span><br><span class="line"><span class="comment">// 新n     = 000..11xxxxx </span></span><br><span class="line"><span class="comment">// n &gt;&gt;&gt; 2 = 000..0011xxx</span></span><br><span class="line"><span class="comment">// 新n或运算 = 000..1111xxx</span></span><br><span class="line"><span class="comment">// 因为cap传进来时最大为2的30次方，所以最多只要16的时候，就可以保证第一次出现1的位置后面全变为1，即n = 000..00111111，那么在返回时通过n+1的操作，使n=000.01000000的形式，保证返回值是2的n次方</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法实际上就是用来计算数组的容量。</p>
</li>
<li><p>putMapEntries：用于将Map作为参数构造一个HashMap对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="comment">// 如果数组还没分配，根据m的大小建立合适大小的数组</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold) </span><br><span class="line"><span class="comment">// 如果m的大小超过table大小，则扩容，resize()后面介绍</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="3-3-添加元素"><a href="#3-3-添加元素" class="headerlink" title="3.3 添加元素"></a>3.3 添加元素</h3><p>介绍完构造函数后现在介绍下如何添加元素，那么在这之前，需要先了解一下HashMap用了什么结构来保存数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// HashMap中的table属性用来保存数组，数组元素本身的结构为Node,是一个静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 存储hash值，空间换时间，减少重复计算</span></span><br><span class="line">    <span class="keyword">final</span> K key;    <span class="comment">// 字典的key</span></span><br><span class="line">    V value;        <span class="comment">// 字典的value</span></span><br><span class="line">    Node&lt;K,V&gt; next; </span><br><span class="line"><span class="comment">// 前面提到,HashMap使用优化过的拉链法解决Hash冲突，即所有Hash值相同的key通过链表连接，可以看出极端情况get性能会退回为O(N)，所以后面会介绍如何优化，暂时理解为一个简单的链表</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get, set, equal, toString....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看下put方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hash方法求key的index</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 充分利用高16位以及低16位求hash，避免连续的key产生的hash值具有规律性</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// table懒加载，第一次存值时才初始化数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">	<span class="comment">// 初始化数组，分配给tab变量，resize()后面介绍，返回值为新分配的数组，n为新数组长度</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">	<span class="comment">// i = (n-1) &amp; hash求出元素下标，前面介绍了字典一般是通过对数组的大小去取模求得数组的下标，但是cpu更擅长的是位运算，而前面提到了数组的大小肯定是2的整数次方，即n的二进制格式为00.100..000，那么n-1即为00.011..111的,对这样的一个数进行与运算的结果集就是0到n-1，效果与除法取模一样，但是速度大幅度提升</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">	    <span class="comment">// 如果指定下标不存在元素，在下标为i的地方插入新值, newNode方法生成一个Node对象并返回</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果指定下标已经存在元素，进入该分支</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// p为指定下标i位置上的Node元素</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line"></span><br><span class="line">		   <span class="comment">// 如果p指向的节点的key与新put进来的key一样</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">		   <span class="comment">// 如果p指向的节点的key与新Put进来的key不一样，且是TreeNode实例</span></span><br><span class="line">            <span class="comment">// 前面介绍过，HashMap的拉链法是优化过的，就体现在这。如果同一个数组跟着的链表长度大于8，会转化为红黑树，红黑树是一种平衡树，平均复杂度为O(logn),优于链表的O(n)</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value); <span class="comment">// TreeNode版的putVal方法</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// key应该在链表中的情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">// 如果遍历完链表还没找到相同的key，则key为新的值，添加到链表尾端</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 如果节点数大于8，则转换为红黑树结构 TREEIFY_THRESHOLD=8</span></span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// put进来的key已经存在，指向Node e</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// put 进来的key已经存在，将value替换</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) <span class="comment">// @param onlyIfAbsent if true, don't change existing value</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 方法为空，无操作</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果key是新的值，则进入这里，否则直接返回</span></span><br><span class="line">    ++modCount; <span class="comment">// 改变量记录了对map添加和删除的次数</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">// threshold为扩容门槛，如果没有指定，在第一次进行resize()时被置为capacity * load factor，即16*0.75</span></span><br><span class="line">        resize(); <span class="comment">// size记录了table包含的key,value对的数量</span></span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">// 改方法为空，无操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是关于添加元素的部分了，但是对于优化为红黑树的部分没有进行深入介绍。因为红黑树本身的数据结构就比较复杂，不易理解，对红黑树进行插入，平衡，查找的相关操作跟map的关系已经不大，如果有兴趣，可以另外找时间网上搜索一下。需要知道的就是红黑树主要解决的问题是当哈希冲突太多时，链表的查询性能变为O(n),用红黑树替代后可以降低到O(logn)的复杂度，且当链表长度8时才进行这个转变；后面会提到resize()时如果节点数量小于6时，红黑树也会退化为链表。接下来介绍一下前面省略掉的 <code>resize()</code>方法：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia1kbU3RS1H6Yq0g7vN8wDd1ice2KnqQ5FhMtRYPnhCtsHaOpM6ib2M2s6vq7LUCx9eWJLwPZ8d8bTevTe4deibhmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123; <span class="comment">// size超过capacity * load_factory时进行扩容</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 如果已经达到最大的size：2的30次方，不再扩容，直接返回旧table</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">// 如果旧的容量*2小于2的30次方且旧的容量大于16时将数组大小翻倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// table数组还没创建且threshold&gt;0时，将capacity设为threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// table数组还没创建，将capacity设为16，扩容阈值设为16*0.75</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 设置新的扩容阈值</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// threshold重新赋值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 申请一个新的数组，大小为原来数组的两倍</span></span><br><span class="line">    table = newTab;  <span class="comment">// table变量指向新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 遍历旧的数组</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 旧数组对应的下标j不为空时，将该下标的元素转移到新数组中</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>; <span class="comment">// 加速GC？猜测</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 如果对应的下标j只有一个元素，将该元素放到新数组 e.hash &amp; (newCap - 1)处</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果下标j对应的Node是红黑树节点</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"><span class="comment">// 在split函数中，如果节点数量小于static final int UNTREEIFY_THRESHOLD = 6；退化为链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表Node</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// do-while循环，将链表根据重新e.hash &amp; oldCap是否等于0，分成两个子链表</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// oldCap二进制为00.100.00的格式，是2的整数次方，只有1个1</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 按照新的table大小来计算数组下标时，算式应该是这样的：e.hash &amp; (oldCap*2-1),假设oldCap为16， 则二进制表示为10,000，oldCap*2=32的二进制为100,000</span></span><br><span class="line"><span class="comment">// 那么上面do-while循环中(e.hash &amp; oldCap) == 0的分支，hash值格式为xx..xx0x,xxx(从右往左第5个数是0，其他任意),与（32-1）做&amp;运算的以及与（15-1）做&amp;运算的结果分别是：</span></span><br><span class="line"><span class="comment">// （32-1）xx.xx0x,xxx ---- (16-1)xx.xx0x,xxx</span></span><br><span class="line"><span class="comment">// （32-1）0000011,111 ---- (16-1)0000001,111</span></span><br><span class="line"><span class="comment">// 结果:-- 000000x,xxx ---- (16-1)000000x,xxx;可以看出扩容前后下标的计算值是一样的，所以在新数组同样的下标处插入这个链表</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125; </span><br><span class="line"><span class="comment">// 上面do-while循环中(e.hash &amp; oldCap) != 0的分支，hash值格式为xx..xx1x,xxx(oldCap还是16，从右往左第5个数是1，其他任意)，与（32-1）以及（15-1）做&amp;运算的结果分别是：</span></span><br><span class="line"><span class="comment">// （32-1）xx.xx1x,xxx ---- (16-1)xx.xx1x,xxx</span></span><br><span class="line"><span class="comment">// （32-1）0000011,111 ---- (16-1)0000001,111</span></span><br><span class="line"><span class="comment">// 结果:-- 000001x,xxx ---- (16-1)000000x,xxx;可以看出扩容后新的下标值比就的下标值大了16，也就是大了oldCap的值，所以另外一个子链表被放置到新数组j+oldCap下标处，这种巧妙的计算下标方式，可以减少重新计算下标的花销，加快扩容的速度</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p><code>TreeNode</code>的类大概就是这样，很清楚的表明了是个红黑树结构，它的插入，删除，查找等方法被省略了，关于它如果左旋右旋进行rebalance可以去网上搜索相关资料</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-获取元素"><a href="#3-4-获取元素" class="headerlink" title="3.4 获取元素"></a>3.4 获取元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// table数组中已经存在元素且hash对应的下标处有元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// </span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first; <span class="comment">// table数组中hash对应下标的第一个元素，就是要找的元素时返回first</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); <span class="comment">// 如果hash对应的node是一个红黑树结构，从红黑树中查找key</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e; <span class="comment">// 在链表中查找key相等的Node</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-删除元素"><a href="#3-5-删除元素" class="headerlink" title="3.5 删除元素"></a>3.5 删除元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123; <span class="comment">// tab = table; p指向key对应的下标所在的Node，如果tab,p为空，return null</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p; <span class="comment">// key指向的Node的第一个元素就是要remove的key时，node=p</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123; <span class="comment">// 第一个元素存在，但不是所要找的key时，如果p.next存在，进入</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 该下标的Node为红黑树结构</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 该下标的Node为链表，找到对应的key时，node指向key对应的节点，否则node=null</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123; <span class="comment">// matchValue可选，删除时比较value是否相等，默认不比较</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p) <span class="comment">// key对应链表第一个节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// key对应链表非第一个节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// modCount记录添加和删除等操作的次数，不记录修改value的次数</span></span><br><span class="line">            --size; <span class="comment">// size大小减1</span></span><br><span class="line">            afterNodeRemoval(node); <span class="comment">// 方法为空</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空map</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-for-each遍历"><a href="#3-6-for-each遍历" class="headerlink" title="3.6 for-each遍历"></a>3.6 for-each遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123; <span class="comment">// 按照数组下标从小到大遍历</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc) <span class="comment">// 遍历的时候不允许修改数组结构，修改value除外，如果出现，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">maps.forEach((k, v) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"key: "</span> + k + <span class="string">", value: "</span> + v); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>上面差不多把HashMap常用的方法的源码都介绍了一下，其实还不到源码的一半的内容，源码中还有很多关于TreeNode的操作，红黑树相关的操作占了将近一半的篇幅，除此之外还有很多Iterator的类和方法，对于这些Iterator的源码和作用，还没有去研究过，准备把大部分集合代码分析完后，专门写一篇关于迭代器的分析博客。(水平有限，如有错误，欢迎提出，可以发邮件或者关注文章底部的微信公众号，谢谢！)</p>
<h2 id="5-常见面试题"><a href="#5-常见面试题" class="headerlink" title="5.常见面试题"></a>5.常见面试题</h2><p><strong>1. JDK1.7是基于数组+单链表实现（为什么不用双链表）</strong></p>
<p>首先，用链表是为了解决hash冲突。</p>
<p>单链表能实现为什么要用双链表呢?(双链表需要更大的存储空间)</p>
<p><strong>2. 为什么要用红黑树，而不用平衡二叉树？</strong></p>
<blockquote>
<p>插入效率比平衡二叉树高，查询效率比普通二叉树高。所以选择性能相对折中的红黑树。</p>
</blockquote>
<p><strong>3. 重写对象的Equals方法时，要重写hashCode方法，为什么？跟HashMap有什么关系？</strong></p>
<p>equals与hashcode间的关系:</p>
<ol>
<li><p>如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；</p>
</li>
<li><p>如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)</p>
</li>
</ol>
<p>因为在 HashMap 的链表结构中遍历判断的时候，特定情况下重写的 equals 方法比较对象是否相等的业务逻辑比较复杂，循环下来更是影响查找效率。所以这里把 hashcode 的判断放在前面，只要 hashcode 不相等就玩儿完，不用再去调用复杂的 equals 了。很多程度地提升 HashMap 的使用效率。</p>
<p>所以重写 hashcode 方法是为了让我们能够正常使用 HashMap 等集合类，因为 HashMap 判断对象是否相等既要比较 hashcode 又要使用 equals 比较。而这样的实现是为了提高 HashMap 的效率。</p>
<p>附上源码图：在getNode方法和putVal方法中就可以看到</p>
<p><img src="images/20191217164423.png" alt></p>
<p><strong>4. HashMap为什么不直接使用对象的原始hash值呢?</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;    </span><br><span class="line">   <span class="keyword">int</span> h;    </span><br><span class="line">   <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，HashMap的哈希值是通过上面的方式获取，而不是通过<code>key.hashCode()</code>方法获取。</p>
<p>原因：</p>
<blockquote>
<p>通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。</p>
</blockquote>
<p><strong>5. 既然红黑树那么好，为啥hashmap不直接采用红黑树，而是当大于8个的时候才转换红黑树？</strong></p>
<p>因为红黑树需要进行左旋，右旋操作， 而单链表不需要。</p>
<p>以下都是单链表与红黑树结构对比。</p>
<p>如果元素小于8个，查询成本高，新增成本低。</p>
<p>如果元素大于8个，查询成本低，新增成本高。</p>
<p>至于为什么选数字8，是大佬折中衡量的结果-.-，就像loadFactor默认值0.75一样。</p>
<p><strong>6.HashMap的工作原理，其中get()方法的工作原理？</strong></p>
<p>HashMap基于hash原理，通过<code>put()</code>和<code>get()</code>方法存储和获取元素。它内部使用数组+链表或红黑树的结构，通过hash运算找到bucket位置来存储Entey对象，通过 <code>equals()</code>方法找到正确的键值对。HashMap使用链地址法来解决hash碰撞问题，当发生碰撞时，对象会存储在链表的下一个节点处。</p>
<p><code>get()</code>首先通过计算key的hash值找到在数组中的下标，若下标处元素为空则直接返回null，否则判断该下标处元素是否是要查找的元素，是就直接返回，不是就判断该元素节点是否为红黑树节点，是就进行红黑树节点的查找，否则遍历链表进行查找。<br>关键点：HashMap是在bucket中存储键对象和值对象作为<code>Map.Entry</code>。</p>
<p><strong>7.我们能否让HashMap同步？</strong></p>
<p>通过<code>Map m = Collections.synchronizeMap(hashMap)</code>实现同步。在 <code>synchronizeMap</code>中给HashMap的所有操作增加<code>synchronized</code>竞争监视器锁来实现线程同步。<br>关键点：<code>synchronizeMap</code>或 <code>ConcurrentHashMap</code>。</p>
<p><strong>8.关于HashMap中的哈希冲突(哈希碰撞)以及冲突解决办法？</strong></p>
<p>HashMap通过计算key的hash值来确定数组位置，不同的key可能会产生相同hash值，因此会发生hash碰撞，在HashMap中采用链地址法来解决hash冲突，当发生碰撞是，将相同hash值的元素存储在链表的下一个节点处。除此之外还有开放地址法，再散列法。<br>关键点：产生碰撞原因，一个好的hash函数可以降低碰撞。</p>
<p><strong>9.如果HashMap的大小超过负载因子定义的容量会怎么办？</strong></p>
<p>HashMap中默认的负载因子为0.75，当HashMap中数组元素个数超过负载因子乘以数组总容量时会发生扩容，将数组扩展为原来的两倍，对原数组中的元素再进行hash运算，获得在新数组中的位置。<br>关键点：扩容！！！。</p>
<p><strong>10.你了解重新调整HashMap大小存在什么问题吗？</strong></p>
<p>多线程条件下对于HashMap进行操作确实会存在同步问题，看网上说调整HashMap大小会导致在头部添加元素从而避免尾部循环，然后就死循环了…其实我没懂！！！</p>
<p><strong>11.为什么String, Interger这样的wrapper类适合作为键？</strong></p>
<p>HashMap推荐使用不可变变量作为键，其中String最为常用，因为String是不可变的，也是final的，我们通过计算key的hash值在数组中进行查找，如果key是可变类型，那么在插入和获取时返回的hashcode不同，就无法正确获得我们想要的对象。</p>
<p><strong>12.我们可以使用自定义的对象作为键吗？</strong></p>
<p>可以，但是要确保这个对象重写了<code>hashCode()</code>和 <code>equals()</code>方法，并且该对象插入Map后就不再改变，只要遵循了这些，它就已经可以作为键了。</p>
<p><strong>13.我们可以使用CocurrentHashMap来代替Hashtable吗？</strong></p>
<p>可以，并且推荐使用<code>CocurrentHashMap</code>。HashTable采用 <code>synchronized</code>实现同步，对其中所有方法添加监视器锁，问题在于，在一个线程进行put操作时，其他线程无法获得get或其他操作，而<code>CocurrentHashMap</code>采用分段锁技术，比HashTable提供更强的线程安全。</p>
<p><strong>14.HashMap扩容问题？</strong></p>
<p>扩容是是新建了一个HashMap的底层数组，而后调用<code>transfer</code>方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。</p>
<p><strong>15.为什么HashMap是线程不安全的？如何体现出不安全的？</strong></p>
<p>当多个线程对HashMap就行put操作时，如果put的key相同会产生碰撞，那么HashMap会将两个key放在数组的同一位置，其中一个线程的key会被覆盖。</p>
<p>当多个线程检测到数组需要扩容时，都会进行数组中元素hash值的重新计算和数据复制，那么也势必造成最后只有一个线程创建的数组成功赋值给table。</p>
<p><strong>16.能否让HashMap实现线程安全，如何做？</strong></p>
<ol>
<li><p>使用线程安全的HashTable，当一个线程访问HashTable的同步方法时，其他线程会被阻塞。也就是说当一个线程进行get操作，其他线程不能进行任何操作，效率很低。</p>
</li>
<li><p>使用<code>Collections.synchronizeMap(hashMap)</code>。但是它的效率也不高，不信去看源码，看完之后会发现它跟HashTable具有同样的问题。</p>
</li>
<li><p>使用<code>CocurrentHashMap</code>。</p>
</li>
</ol>
<p><strong>17.HashMap中hash函数是怎么实现的？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hash通过计算key自身的<code>hashCode()</code>值，，返回的类型是int，为了减少碰撞产生的几率，将获得的 <code>hashCode()</code>的低16位与高16位右移16位相异或。</p>
<p><strong>18.HashMap什么时候需要重写hashcode和equals方法？</strong></p>
<p>当key值为对象时必须要求重写<code>hashcode()</code>和 <code>equals()</code>方法。因为默认的<code>hashcode()</code>使用的是该值在内存中的地址作为该值的hash值，如果两个具有相同意义的对象进行比较时，由于其地址不同会导致计算出的hash值也不同。而重写 <code>equals()</code>可以确保两个对象具有相同意义的属性。</p>
<p>参考文件：</p>
<ul>
<li><p><a href="https://mp.weixin.qq.com/s/PvbRoSSQBLdemqzX4jELbg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PvbRoSSQBLdemqzX4jELbg</a> </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/vRvMvNktoDSQKMMlnj5T0g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vRvMvNktoDSQKMMlnj5T0g</a> </p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/b4sgRkouaUMYwi3kubL08w" target="_blank" rel="noopener">HashMap源码解析（一）</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Map集合之ConcurrentHashMap源码解析</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Map%E9%9B%86%E5%90%88%E4%B9%8BConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p> ConcurrentHashMap顾名思义就是同步的HashMap，也就是线程安全的HashMap，  本篇继续以JDK1.8版本的源码进行分析，最后在介绍完ConcurrentHashMap之后会对ConcurrentHashMap、Hashtable和HashMap做一个比较和总结。首先看下这三个类之间继承图（可能缺少部分接口显示）如下：</p>
<p><img src="images/20191225164544.png" alt></p>
<h2 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2. 基本介绍"></a>2. 基本介绍</h2><p>ConcurrentHashMap是HashMap的线程安全版本，但是对于JDK1.7和JDK1.8下两者的结构还是存在较大的区别，下面首先回顾下JDK1.7下的ConcurrentHashMap结构。</p>
<p><img src="images/ConCurrentHashMap2.jpg" alt></p>
<p>JDK1.7下，ConcurrentHashMap和HashMap的底层结构相同，均采用的是数组+单链表形式。但是ConcurrentHashMap多采用了一个segment数组， segment数组的大小决定了ConcurrentHashMap的并发度，默认是16，为什么这么说呢？是因为在java7的ConcurrentHashMap实现上，使用了所谓分段锁的方法，而所谓分段锁就是将记录分段存储，不同段的访问互相不影响，某个线程想要访问某一个段的时候就需要对该段上锁，而其他线程不能访问在有其他线程加锁的段，这和对整体加锁的方法相比是一种伟大的进步。 </p>
<p> <a href="https://mp.weixin.qq.com/s/LzQjMsqEiOxBQ7m5fr9eIg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LzQjMsqEiOxBQ7m5fr9eIg</a> </p>
<p> <a href="https://mp.weixin.qq.com/s/wOT2owVBlZ6HJeKbgQ4NQQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wOT2owVBlZ6HJeKbgQ4NQQ</a> </p>
<p> <a href="https://mp.weixin.qq.com/s/rlyoQp4ngTX8mjGDJgJIRA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rlyoQp4ngTX8mjGDJgJIRA</a> </p>
<p> <a href="https://mp.weixin.qq.com/s/_Bf6XcH51lssC0mdF_oW9A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_Bf6XcH51lssC0mdF_oW9A</a> </p>
<p>内部也是使用（数组 + 链表 + 红黑树）的结构来存储元素。相比于同样线程安全的HashTable来说，效率等各方面都有极大地提高。首先看一下ConcurrentHashMap的结构图</p>
<p><img src="images/ConcurrentHashMap.jpg" alt></p>
<div style="text-align:center">
    JDK1.8下ConcurrentHashMap结构图
</div>







<p><strong><em>各种锁简介</em></strong></p>
<p>这里先简单介绍一下各种锁，以便下文讲到相关概念时能有个印象。</p>
<p><strong>（1）synchronized</strong></p>
<p>java中的关键字，内部实现为监视器锁，主要是通过对象监视器在对象头中的字段来表明的。synchronized从旧版本到现在已经做了很多优化了，在运行时会有三种存在方式：偏向锁，轻量级锁，重量级锁。</p>
<ul>
<li><p>偏向锁，是指一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，降低获取锁的代价。</p>
</li>
<li><p>轻量级锁，是指当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁，这个线程会通过自旋的方式尝试获取锁，不会阻塞，提高性能。</p>
</li>
<li><p>重量级锁，是指当锁是轻量级锁时，当自旋的线程自旋了一定的次数后，还没有获取到锁，就会进入阻塞状态，该锁升级为重量级锁，重量级锁会使其他线程阻塞，性能降低。</p>
</li>
</ul>
<p><strong>（2）CAS</strong></p>
<p>CAS，Compare And Swap，它是一种乐观锁，认为对于同一个数据的并发操作不一定会发生修改，在更新数据的时候，尝试去更新数据，如果失败就不断尝试。</p>
<p><strong>（3）volatile（非锁）</strong></p>
<p>java中的关键字，当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。（这里牵涉到java内存模型的知识，感兴趣的同学可以自己查查相关资料）</p>
<p>volatile只保证可见性，不保证原子性，比如 volatile修改的变量 i，针对i++操作，不保证每次结果都正确，因为i++操作是两步操作，相当于 i = i +1，先读取，再加1，这种情况volatile是无法保证的。</p>
<p><strong>（4）自旋锁</strong></p>
<p>自旋锁，是指尝试获取锁的线程不会阻塞，而是循环的方式不断尝试，这样的好处是减少线程的上下文切换带来的开锁，提高性能，缺点是循环会消耗CPU。</p>
<p><strong>（5）分段锁</strong></p>
<p>分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在ConcurrentHashMap中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。</p>
<p><strong>（5）ReentrantLock</strong></p>
<p>可重入锁，是指一个线程获取锁之后再尝试获取锁时会自动获取锁，可重入锁的优点是避免死锁。其实，synchronized也是可重入锁。</p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><h3 id="3-1-属性变量"><a href="#3-1-属性变量" class="headerlink" title="3.1 属性变量"></a>3.1 属性变量</h3><p>在ConcurrentHashMap中的字段要比HashMap的字段多好多，这里一些常量就列出了，只给出几个成员变量，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 在进行扩容是会进行初始化 将table上的数据迁移至该数组，然后将其复制给table</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 当不存在冲突时 用来记录元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">// 用于控制数组的初始化和扩容，不同情况有不同的值</span></span><br><span class="line"><span class="comment">// 0 默认值</span></span><br><span class="line"><span class="comment">// -1 代表有线程在进行初始化</span></span><br><span class="line"><span class="comment">// &gt;0 数组为null时  代表数组的初始化长度</span></span><br><span class="line"><span class="comment">// &gt;0 数组不为null时  代表扩容的临界值  数组长度*0.75</span></span><br><span class="line"><span class="comment">// &lt;0 高十六位代表扩容标记  低十六位表示扩容的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 扩容时使用 代表处理数据的下标</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">// 判断CounterCells数组是否出入初始化或扩容状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="comment">// 在并发的情况下  修改数组元素的值来累加元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是sizeCtl、baseCount、counterCells三个属性，在后面的源码中我们会讲解到这三个字段的用处，这里简单的说一下，<span style="color:red">sizeCtl用来控制数组的初始化和扩容，baseCount和counterCells用来记录元素的个数 </span>，链表的总数等于baseCount + counterCells中元素值的和。</p>
<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h3><p>在ConcurrentHashMap中提供了五种构造方法，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参，采用默认大小16</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定数组长度  调用tableSizeFor计算出数组的初始长度 传递的为 1.5initialCapacity + 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 将数组的初始化值存入sizeCtl中</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过Map创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入数组长度和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入数组长度、负载因子和加权因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">// 数组长度传入sizeCtrl中</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过构造方法我们知道在传递了数组长度的构造方法中，sizeCtl存放的是数组的初始化长度，该变量的其他值我们在后面会一个个的讲解到。</p>
<p>构造方法与HashMap对比可以发现，没有了HashMap中的threshold和loadFactor，而是改用了sizeCtl来控制，而且只存储了容量在里面，那么它是怎么用的呢？官方给出的解释如下：</p>
<p>（1）-1，表示有线程正在进行初始化操作</p>
<p>（2）-(1 + nThreads)，表示有n个线程正在一起扩容</p>
<p>（3）0，默认值，后续在真正初始化的时候使用默认容量</p>
<p>（4）&gt; 0，初始化或扩容完成后下一次的扩容门槛</p>
<p>至于，官方这个解释对不对我们后面再讨论。</p>
<h3 id="3-3-put方法"><a href="#3-3-put方法" class="headerlink" title="3.3 put方法"></a>3.3 put方法</h3><p>在这部分我们开始学习ConcurrentHashMap插入数据的逻辑，我们会了解到数组的初始化、插入、扩容及如何保证的线程安全，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key和value不能为null  否则抛出NullPointException</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 通过key的哈希值计算出node节点的hash属性值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 如果桶未初始化或者桶个数为0，则初始化桶</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果要插入的元素所在的桶还没有元素，则把这个元素插入到这个桶中</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                </span><br><span class="line">				<span class="comment">// 如果使用CAS插入元素时，发现已经有元素了，则进入下一次循环，重新操作</span></span><br><span class="line">				<span class="comment">// 如果使用CAS插入元素成功，则break跳出循环，流程结束</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">			<span class="comment">// 如果要插入的元素所在的桶的第一个元素的hash是MOVED，则当前线程帮忙一起迁移元素</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解决hash冲突</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 同步代码块，锁住的是数组指定位置上的Node对象，不影响其他线程操作别的位置上的数据</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 用于记录插入该数据的链表的长度  最后判断是否需要转换为红黑树</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 链表上存在对应的key  覆盖value值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 不存在key 在链表尾部插入新节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// key不存在新增加节点时进入该逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 链表长度大于等于8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 转为红黑树或者扩容</span></span><br><span class="line">                    <span class="comment">// 数组的长度小于64进行扩容</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 若key存在 返回原值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="comment">// 退出自旋</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 元素数据增加 扩容的逻辑</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们发现在put方法中ConcurrentHashMap是通过自旋加CAS及同步代码块来保证的线程安全，代码块锁住的是数组上的某个元素，这样就允许了对数组上其他元素的操作不被阻塞，可以提高并发。</p>
<p>在了解了put方法的处理过程后，我们再来详细的介绍下几个方法</p>
<ul>
<li><p>initTable  数组初始化</p>
</li>
<li><p>helpTransfer 帮助扩容</p>
</li>
<li><p>treeifyBin  转换为红黑树</p>
</li>
<li><p>addCount  维护集合长度和扩容</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-List集合面试题</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-List%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-ArrayList与LinkedList的区别和适用场景"><a href="#1-ArrayList与LinkedList的区别和适用场景" class="headerlink" title="1. ArrayList与LinkedList的区别和适用场景"></a>1. ArrayList与LinkedList的区别和适用场景</h2><p><strong>相同点：</strong></p>
<p>ArrayList和LinkedList都是实现List接口。List集合的特点：元素有放入顺序，元素可重复。都是线程不安全。</p>
<p><strong>不同点：</strong></p>
<p><strong><em>Arraylist</em></strong>：底层是基于动态数组实现，因为地址连续，一旦数据存储好了，查询操作效率会比较高。但是因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p>
<p><strong><em>LinkedList</em></strong>：由于实现了Deque接口，所以底层的数据结构实际上是一个双向链表。由于在插入和删除数据时，其不需要移动数据，所以进行add和remove操作时比较占优势。（但是如果直接进行add(E e)时，使用ArrayList性能也很高）因为LinkedList要移动指针,所以查询操作性能比较低。需要占用的内存高于ArrayList</p>
<p><strong>适用场景分析：</strong><br>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p>
<h2 id="2-ArrayList与Vector的区别和适用场景"><a href="#2-ArrayList与Vector的区别和适用场景" class="headerlink" title="2. ArrayList与Vector的区别和适用场景"></a>2. ArrayList与Vector的区别和适用场景</h2><p><strong>相同点：</strong></p>
<p>ArrayList与Vector都是实现List接口。List集合的特点：元素有放入顺序，元素可重复。都是基于动态数组实现。在进行访问数据时速度很快，但是增加和删除数据速度慢。ArrayList和Vector的迭代器实现都是fail-fast的。ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。</p>
<p><strong>不同点：</strong></p>
<p><strong><em>ArrayList</em></strong>：默认的扩容为原来的1.5倍，没有提供设置扩容空间大小。线程不安全</p>
<p><strong><em>Vector</em></strong>：默认扩容为原来的2倍，提供了设置扩容大小（即变量capacityIncrement）。在Vector类中的方法前面有synchronization关键字，能够实现同步，所以线程安全。但是由于这种线程安全机制导致Vector类的性能要低于ArrayList。</p>
<p><strong>使用场景</strong></p>
<p>如果希望线程安全，那么使用Vector类。</p>
<h2 id="3-如何实现ArrayList线程安全呢？"><a href="#3-如何实现ArrayList线程安全呢？" class="headerlink" title="3. 如何实现ArrayList线程安全呢？"></a>3. 如何实现ArrayList线程安全呢？</h2><p>通常有三种方法：</p>
<p>（1）使用关键字synchronization</p>
<p>（2）使用线程安全包装方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br></pre></td></tr></table></figure>

<p>（3）使用ArrayList的安全版本类CopyOnWriteArrayList类</p>
<p>参考资料： <a href="https://mp.weixin.qq.com/s/YQyroql8As9tpyRO9-MOsA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YQyroql8As9tpyRO9-MOsA</a> </p>
<h2 id="4-Array-数组-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？"><a href="#4-Array-数组-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？" class="headerlink" title="4.Array(数组) 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？"></a>4.Array(数组) 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</h2><p>答：它们的区别是：</p>
<ol>
<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>
<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>
<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>
</ol>
<p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p>
<h2 id="5-遍历一个List有哪些不同的方式？"><a href="#5-遍历一个List有哪些不同的方式？" class="headerlink" title="5.遍历一个List有哪些不同的方式？"></a>5.遍历一个List有哪些不同的方式？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String obj : strList)&#123;   </span><br><span class="line">	System.out.println(obj); </span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;String&gt; it = strList.iterator(); </span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;   </span><br><span class="line">    String obj = it.next();   </span><br><span class="line">    System.out.println(obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。</p>
<h2 id="6-ArrayList是如何扩容的ArrayList是如何实现自动增加的？"><a href="#6-ArrayList是如何扩容的ArrayList是如何实现自动增加的？" class="headerlink" title="6.ArrayList是如何扩容的ArrayList是如何实现自动增加的？"></a>6.ArrayList是如何扩容的ArrayList是如何实现自动增加的？</h2><p>如果是使用无参构造的话，初始容量是10，当超过了10个容量时，就需要扩容，每次扩容为之前的1.5倍。调用的是Arrays.copy(elementData,newCapacity)。所以扩容涉及到数组的复制和移动，我们应该避免扩容。在初始化的时候预估容量大小。</p>
<h2 id="7-往ArrayList集合加入一万条数据，应该怎么提高效率？"><a href="#7-往ArrayList集合加入一万条数据，应该怎么提高效率？" class="headerlink" title="7.往ArrayList集合加入一万条数据，应该怎么提高效率？"></a>7.往ArrayList集合加入一万条数据，应该怎么提高效率？</h2><p>ArrayList的构造方法有三种。当数据量比较大，这里又已经明确是一万条了，我们应该在初始化的时候就给它设置好容量。</p>
<p>不然使用无参构造器初始容量只有10，后面要扩容，扩容又比较伤性能，因为涉及到数组的复制，将原来的数组复制到新的存储区域中去。</p>
<p>PS:ArrayList动态扩容是一个重点一定要理解好，附上传送门：<a href="https://blog.csdn.net/zymx14/article/details/78324464" target="_blank" rel="noopener">https://blog.csdn.net/zymx14/article/details/78324464</a></p>
<h2 id="8-如何复制某个ArrayList到另一个ArrayList中去？"><a href="#8-如何复制某个ArrayList到另一个ArrayList中去？" class="headerlink" title="8.如何复制某个ArrayList到另一个ArrayList中去？"></a>8.如何复制某个ArrayList到另一个ArrayList中去？</h2><p>一般不直接用“=”赋值，这是将引用指向了同一片地址，一个修改了里面的内容另一个也会跟着变动。</p>
<p>一般采用如下方式：</p>
<p>ArrayList A = new ArrayList();//假设此时A集合已经有了数据。构造器法<br>ArrayList B = new ArrayList(A);</p>
<p>//clone法<br>ArrayList A = new ArrayList();<br>ArrayList B =  (ArrayList) A.clone();</p>
<p>ArrayList A = new ArrayList(); //初始化时最好先预估容量大小<br>ArrayList B = new ArrayList();<br>B.addAll(A);</p>
<p>还可以调用Collections.copy()方法，参考博客：<a href="https://blog.csdn.net/tiantiandjava/article/details/51072173" target="_blank" rel="noopener">https://blog.csdn.net/tiantiandjava/article/details/51072173</a></p>
<h2 id="9-在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？"><a href="#9-在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？" class="headerlink" title="9.在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？"></a>9.在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？</h2><p>查看源代码可以发现，当通过索引去增删元素的时候效率是比较低的，因为要频繁的进行数组的复制和移动，如果经常增删的话我们可以去考虑其他的集合。</p>
<p>通过索引增加过程：1.检查索引是否越界？2.检查容量是否足够？3调用System.arrayCopy(……)操作，效率较低</p>
<p>通过索引删除元素：1.检查索引是否越界？2.调用System.arrayCopy(….)操作</p>
<p>源代码截图如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1490755/201905/1490755-20190503174209019-507472925.png" alt></p>
<p><img src="https://img2018.cnblogs.com/blog/1490755/201905/1490755-20190503174232978-1430386020.png" alt></p>
<h2 id="10-当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？"><a href="#10-当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？" class="headerlink" title="10.当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？"></a>10.当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？</h2><p>首先因为ArrayList当被做参数传递到某个方法中时，传递的是引用，所以对其进行修改会影响到原数组，所以ArrayList在没有被复制的情况下直接被分配给了成员变量，那么就可能发生这种情况*，那么可先进行复制再传递</p>
<p>1.使用clone()方法</p>
<blockquote>
<p>比如ArrayList oldArray= oldArray.clone()</p>
</blockquote>
<p>2.使用ArrayList构造方法</p>
<blockquote>
<p>比如：ArrayList oldArray= new ArrayList(oldArray)</p>
</blockquote>
<p>3.使用Collection的copy方法</p>
<blockquote>
<p>使用Collection的copy方法</p>
</blockquote>
<h2 id="11-关于ArrayList的扩容是如何实现的原理是什么？"><a href="#11-关于ArrayList的扩容是如何实现的原理是什么？" class="headerlink" title="11.关于ArrayList的扩容是如何实现的原理是什么？"></a>11.关于ArrayList的扩容是如何实现的原理是什么？</h2><p>首先明确ArrayList的构造方法有三种，默认的initCapacity容量为10，如果初始化时一开始指定了容量，或者通过集合作为元素，则容量为指定的大小或参数集合的大小。每次扩容为原来的1.5倍，如果扩容后的容量小于所需的最小容量，则数组容量为所需的最小容量。如果扩容后的容量大于所需的最小容量，则数组容量为扩容后的容量。每次扩容后都要调用arraycopy    ,涉及到整个数组的复制和移动。所以要尽量减少扩容的次数提高效率，在数据量比较大的时候初始化时指定容量的大小。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iabltwibXkibicbJfSaEMq3FMm2Hjlp19EeVmz1hdMACtiaQ0o0iaQ9suGJppEdvJOFs0lgrbkM2WrgV1rQ/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="12-LinkedList的底层与常用方法实现的了解"><a href="#12-LinkedList的底层与常用方法实现的了解" class="headerlink" title="12.LinkedList的底层与常用方法实现的了解"></a>12.LinkedList的底层与常用方法实现的了解</h2><p>LinkedList也实现了List接口，有序且允许元素重复和为null值，底层是双向链表，具有链表增删效率高和查询效率慢的特点。虽然它在查询实现时采用了折半查找提高效率的思想，但在查询上还是比不过按索引查的ArrayList.做过单链表，双向链表练习的人应该再看LinkedList源代码感到很熟悉。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-List集合之Vector源码解析</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-List%E9%9B%86%E5%90%88%E4%B9%8BVector%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-List集合介绍"><a href="#1-List集合介绍" class="headerlink" title="1. List集合介绍"></a>1. List集合介绍</h2><p><img src="images/20191217202502.png" alt></p>
<p>在List集合中主要包括有三个主要的实现类：ArrayList、LinkedList和Vector类。这三个类均在<code>java.util</code>包中，均为可伸缩数组，即均可动态改变长度的数组。</p>
<p>由于<code>ArrayList</code>和<code>Vector</code>很相似，所以主要介绍这两个异同点：</p>
<p>（1）相同点</p>
<ul>
<li><p>拥有相同的继承和实现</p>
</li>
<li><p><code>ArrayList</code>和<code>Vector</code> 都是基于存储元素的<code>Object[]array</code>来实现的，由于通过下标进行访问，所以访问速度很快。但是在插入数据时由于需要移动数据，所以对数据的插入操作执行得比较慢。<code>ArrayList</code>和<code>Vector</code>都有一个初始化的容量的大小，当进行动态扩充时Vector默认扩充为原来的2倍（每次扩充空间的大小是可以设置的），而ArrayList默认扩充为原来的1.5倍（没有提供方法来设置空间扩充的方法）。</p>
</li>
</ul>
<p>（2）不同点</p>
<ul>
<li>ArrayList与Vector最大的区别就是synchronization（同步）的使用，没有一个ArrayList的方法是同步的，而Vector的绝大多数方法（例如add、insert、remove、set、equals、hashcode等）都是直接或者间接同步的，所以Vector是线程安全的，ArrayList不是线程安全的。正是由于Vector提供了线程安全的机制，其性能上也要略逊于ArrayList。</li>
</ul>
<p>其次对于LinkedList，LinkedList是采用双向列表来实现的，对数据的索引需要从列表头开始遍历，因此用于随机访问则效率比较低，但是插入元素时不需要对数据进行移动，因此插入效率较高。同时，LinkedList是非线程安全的容器。</p>
<p>那么，在实际使用时，如何从这几种容器中选择合适的使用呢？当对数据的主要操作为索引或只在集合的末端增加、删除元素时，使用ArrayList或Vector效率比较高；当对数据的操作主要为指定位置的插入或删除操作时，使用LinkedList效率比较高；当在多线程中使用容器时（即多个线程会同时访问该容器），选用Vector较为安全。</p>
<h2 id="2-Vector介绍"><a href="#2-Vector介绍" class="headerlink" title="2. Vector介绍"></a>2. Vector介绍</h2><p>在对Vector（向量）做解析前，首先对Vector与ArrayList进行下对比：</p>
<p><strong>相同点：</strong></p>
<p>1.底层都是基于动态Object数组实现的</p>
<p>2.相同的继承与实现</p>
<p>3.初试默认长度都是10</p>
<p><strong>区别：</strong></p>
<p>1.Vector的实现是同步的/线程安全，ArrayList不同步/线程不安全。</p>
<p>2.扩容机制——扩容大小不同,Vector扩大为原来的2倍，ArrayList增长为原来的1.5倍。</p>
<p>3.Vector有三个属性：elementData、elementCount、capacityIncrement，比ArrayList多了一个扩展因子。</p>
<p>4.Vector与ArrayList相同的属性而修饰符却不同。</p>
<p>5.Vector中只有writeObject方法，而ArrayList不仅有writeObject，还有readObject。</p>
<p>6.Vector大小可以改变，ArrayList不能改变</p>
<p>7.Vector可以存储不同类型的对象，无需考虑对象类型，ArrayList只能存储同一种类型的对象。</p>
<p>下面着重解释与ArrayList不同的地方，相同点不做重复解释了，完全一毛一样，请阅读：</p>
<p>[ArrayList源码解析](<a href="https://mp.weixin.qq.com/s?__biz=MzU0ODg4ODQ5Mg==&amp;mid=2247483722&amp;idx=1&amp;sn=8f9e7222417dbd2f002779aa628d17b6&amp;chksm=fbb90b89ccce829ff2779d6a0c1fe7715ee10c79a928d6f211299b3a0fda1cbedbf11f3b1711&amp;scene=21&amp;xtrack=1&amp;key=e6cd5336efd7c7e0b3fd72b2c3c84b4205cba9314f7b3365d439da520151dde3162a1b4828f6b328d453e04af6f50ca500132b4c4179136dd64e89c347cc40012373ec54290376db4ef6e3ae2bf4b0cb&amp;ascene=1&amp;uin=MTM4NzU4MzcyNg==&amp;devicetype=Windows" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0ODg4ODQ5Mg==&amp;mid=2247483722&amp;idx=1&amp;sn=8f9e7222417dbd2f002779aa628d17b6&amp;chksm=fbb90b89ccce829ff2779d6a0c1fe7715ee10c79a928d6f211299b3a0fda1cbedbf11f3b1711&amp;scene=21&amp;xtrack=1&amp;key=e6cd5336efd7c7e0b3fd72b2c3c84b4205cba9314f7b3365d439da520151dde3162a1b4828f6b328d453e04af6f50ca500132b4c4179136dd64e89c347cc40012373ec54290376db4ef6e3ae2bf4b0cb&amp;ascene=1&amp;uin=MTM4NzU4MzcyNg==&amp;devicetype=Windows</a> 10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=NlPx77iAKnrhHbqm7OsyV9 vZaiJPZ pKEO/gXlBVucAxmLyGByu3ay6Ihfj58OM#wechat_redirect)</p>
<hr>
<h2 id="3-Vector源码解析"><a href="#3-Vector源码解析" class="headerlink" title="3. Vector源码解析"></a>3. Vector源码解析</h2><p><strong>一、Vector向量语意</strong>：Vector是一个矢量队列，底层基于数组实现，什么是向量：既有大小又有方向的量。是不是可以这么说呢，只需要考虑Vector中对象的大小且该对象的位置，而不需要考虑该对象的的类型，这里的对象是抽象的。在Java里没有指针这一概念，Vector可能就是为了弥补而设计的吧。</p>
<p><strong>二、Vector中的protected修饰符</strong>：被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。在成员变量中出现了该修饰符，而在ArrayList中对成员变量是用private。由于Vector是在Java1.0就有了，而Vector有自己的内部实现方法，与其他集合有些区别，因为Vector本身比较特殊，例如，Vector使用到了在集合中被遗弃了的枚举，不会检查集合是否在迭代期间被修改。而Vector本身也要逐渐被遗弃了，所以它希望自己的成员变量可以被其他子类继承，而又不想被其他类所访问。这样解释是不是有些牵强呢？我也这么认为！</p>
<h3 id="3-1-成员标量"><a href="#3-1-成员标量" class="headerlink" title="3.1 成员标量"></a>3.1 成员标量</h3><p>被protected修饰的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 数组元素存储缓存区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 向量中最后一个元素后面的任何数组元素都是null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量增长系数：每次需要增长时，值就会增加一倍。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h3><p>Vector中在构建容量大小的时候引入了扩展因子，默认初始化为0。扩展因子的大小可以由用户自己自定义。从而来决定Vector到底是呈几倍来增长的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定数组初始化容量大小和增长系数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) <span class="comment">//初始化容量小于0，抛出异常</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                          initialCapacity);</span><br><span class="line">   <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//为对象数组指定初始化容量</span></span><br><span class="line">   <span class="keyword">this</span>.capacityIncrement = capacityIncrement;<span class="comment">//传参，设置增长系数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定Vector初始化容量大小，默认增长系数为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空的Vector，增长系数为0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化容量为10</span></span><br><span class="line">   <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个包含指定集合C中的元素的数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   elementData = c.toArray();<span class="comment">//获取集合C中的元素，将其放入数组中</span></span><br><span class="line">   elementCount = elementData.length;<span class="comment">//添加成功后，Vector的元素个数就是数组的长度</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)//判断添加进的元素对象是否为对象数组类型</span></span><br><span class="line"><span class="class">  //否则进行浅拷贝将类型转化为对象数组</span></span><br><span class="line"><span class="class">       <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, elementCount, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-Vector的扩容机制"><a href="#3-3-Vector的扩容机制" class="headerlink" title="3.3 Vector的扩容机制"></a>3.3 Vector的扩容机制</h3><p>道理和ArrayList一样，只不过这里的grow()方法，若不对capacityIncrement进行自定义，则默认扩容为原来的2倍大小，若定义了capacityIncrement的大小，则原来的大小 + 定义的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//原Vector容量值</span></span><br><span class="line">   <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">   <span class="comment">//如果有给capacityIncrement设置增长系数的话，就加上该系数值来扩容，否则将原先的数组容量变为2*oldCapacity</span></span><br><span class="line">   <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                    capacityIncrement : oldCapacity);</span><br><span class="line">   <span class="comment">//如果重新的设置的容量值还要小于最小要求的容量值得话</span></span><br><span class="line">   <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">  <span class="comment">//就将最小的容量值赋值给新的容量</span></span><br><span class="line">       newCapacity = minCapacity;</span><br><span class="line">   <span class="comment">//如果谁知道的新容量值比限制的最大容量还要大的话</span></span><br><span class="line">   <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">  	   <span class="comment">//重新设置大小</span></span><br><span class="line">       newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">   <span class="comment">//将原先数组的元素浅拷贝到一个新的数组</span></span><br><span class="line">   elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-4-Vector的线程安全性"><a href="#3-4-Vector的线程安全性" class="headerlink" title="3.4 Vector的线程安全性"></a>3.4 Vector的线程安全性</h3><p>在Vector中大多的方法使用了synchronized来进行修饰，以确保该方法是同步的，也就是这样才导致了Vector的查询没有ArrayList快的原因了，因为多了加锁释放锁的时间。也正是因为同步，所以才导致了Vector中的Iterator在被创建使用时，如果来了另一个线程要来添加或者修改元素，那么Vector中的Iterator就会抛出ConcurrentModificationException异常。</p>
<h3 id="3-5-writeObject-方法"><a href="#3-5-writeObject-方法" class="headerlink" title="3.5 writeObject()方法"></a>3.5 writeObject()方法</h3><p>在阅读Vector源码的时候发现了一个和ArrayList不同的地方，为什么Vector中会比ArrayList少了一个readObject()方法呢？都知道ArrayList的writeObject()方法被将对象进行序列化，而readObject()方法会将对象进行反序列化。难道Vector中的writeObject即序列化又反序列化了？这就要从该方法的源码下手了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将元素写入流中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> java.io.ObjectOutputStream.PutField fields = s.putFields();</span><br><span class="line">   <span class="keyword">final</span> Object[] data;</span><br><span class="line">   <span class="comment">//确保一致性</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       fields.put(<span class="string">"capacityIncrement"</span>, capacityIncrement);</span><br><span class="line">       fields.put(<span class="string">"elementCount"</span>, elementCount);</span><br><span class="line">       data = elementData.clone();</span><br><span class="line">  &#125;</span><br><span class="line">   fields.put(<span class="string">"elementData"</span>, data);</span><br><span class="line">   s.writeFields();<span class="comment">//将缓存字段写入流中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Vector是同步的，所以某一时刻只能有一个线程来进行写入流的操作。而期间又涉及锁的问题，可能该方法是设计初期到现在所留下的缺陷。在ArrayList中重写了writeObject和readObject来个方法，为了提高效率。</p>
<h3 id="3-6-setSize-方法"><a href="#3-6-setSize-方法" class="headerlink" title="3.6 setSize()方法"></a>3.6 setSize()方法</h3><p>Vector也可以通过修改对象个数来实现容量的更改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置Vector的元素个数,同步的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">   modCount++;<span class="comment">//修改次数+1</span></span><br><span class="line">   <span class="keyword">if</span> (newSize &gt; elementCount) &#123;<span class="comment">//如果传进来的新size大小要大于当前的元素个数</span></span><br><span class="line">       ensureCapacityHelper(newSize);<span class="comment">//则选择该值进行扩容操作</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，也就是比它小的话</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">           elementData[i] = <span class="keyword">null</span>;<span class="comment">//小于空出的后面的元素都将设置成null</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   elementCount = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>如果要频繁的对对象进行添加、修改的数目不确定，而且列表成员可以用对象来表示的话可以选择使用Vector。</p>
<p>参考资料</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/c4cIgvoM1v4jZcpyhytutg" target="_blank" rel="noopener">源码解析&amp;&amp;Vector与ArrayList的不同之处</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-List集合之CopyOrWriteArrayList源码解析</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-List%E9%9B%86%E5%90%88%E4%B9%8BCopyOrWriteArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="知道CopyOnWriteArrayList与Arraylist的区别吗？"><a href="#知道CopyOnWriteArrayList与Arraylist的区别吗？" class="headerlink" title="知道CopyOnWriteArrayList与Arraylist的区别吗？"></a>知道CopyOnWriteArrayList与Arraylist的区别吗？</h2><ol>
<li>什么是CopyOnWriteArrayList？</li>
</ol>
<p>​    CopyOnWriteArrayList是线程安全的List变种。其中所有的可变操作(add remove set 等等)都是通过创建底层数组的新副本来实现的。CopyOnWriteArrayList虽然是线程安全的但是会浪费内存。</p>
<p>​    所以说花费的代价太大，当读多写少时 效果很不错，并且在不能或不想同步遍历但需要排除并发线程之间的干扰时非常有用。“snapshot”样式的迭代器方法使用对迭代器创建时数组状态的引用（重新copy了一份新数组）。此数组在迭代器的生命周期内从不更改，因此不可能发生干扰，并且迭代器保证不会抛出{@code concurrentmodificationexception}。（LinkedList list都会出现concurrentmodificationexception）自创建迭代器以来，迭代器不会对列表进行添加、删除或更改。不支持对迭代器本身({@code remove}、{@code set}和{@code add})进行元素更改操作。这些方法抛出{@code UnsupportedOperationException}。copyOnWriteArrayList 可以存储所有的数据，包含null在内。</p>
<p>​    通过jdk中CopyOnWriteArrayList的翻译可以看出来，CopyOnWriteArrayList是ArrayList的线程安全版本，内部也是通过数组实现(实现了List接口 ArrayList中存在的方法它都有在可变操作中都添加了重入锁。（1.5版本中用的ReentrantLock 1.6版本后修复了syn关键字的性能，可以使用这个关键字自己实现一下 试试性能）)，每次对数组的修改都完全拷贝一份新的数组来修改，修改完了再替换掉老数组，这样保证了只阻塞写操作，不阻塞读操作，实现读写分离。</p>
<p><img src="images/20191224104541.png" alt></p>
<p>继承关系:</p>
<p>CopyOnWriteArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable等接口。</p>
<p>CopyOnWriteArrayList实现了List，提供了基础的添加、删除、遍历等操作。</p>
<p>CopyOnWriteArrayList实现了RandomAccess，提供了随机访问的能力。</p>
<p>CopyOnWriteArrayList实现了Cloneable，可以被克隆。</p>
<p>CopyOnWriteArrayList实现了Serializable，可以被序列化。</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *用于可变操作是添加锁 修饰词语是 transient 所以不会自动序列化</span></span><br><span class="line"><span class="comment"> *The lock protecting all mutators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *存储元素的地方，只能通过 getArray/setArray. 访问  修饰词 transient  </span></span><br><span class="line"><span class="comment"> *不会自动序列化 volatile表示一个线程修改另一个线程可见</span></span><br><span class="line"><span class="comment"> *The array, accessed only via getArray/setArray.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>

<p>这个是CopyOnWriteArrayList的两个通用的属性，如果熟悉CopyOnWriteArrayList源码的程序员就会发现没有ArrayList  size元素 、capacity元素 没有LinkedList的size元素 后面看代码分析</p>
<p>CopyOnWriteArrayList的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *创建一个null数组</span></span><br><span class="line"><span class="comment"> * Creates an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *如果c是CopyOnWriteArrayList类型，直接把它的数组赋值给当前list的数组，注意 这里是浅拷贝，两个集合共用同一个数组。*葵花妈妈开课啦: 浅拷贝 “拷贝就是拷贝指向对象的指针，意思就是说：拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间，浅拷贝只是一种简单的拷贝，</span></span><br><span class="line"><span class="comment"> *让几个对象公用一个内存，然而当内存销毁的时候，指向这个内存空间的所有指针需要重新定义，不然会造成野指针错误。”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *如果c不是CopyOnWriteArrayList类型，则进行拷贝把c的元素全部拷贝到当前list的数组中。* Creates a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of initially held elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">elements</span> </span>= ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elements</span> </span>= Arrays.copyOf(elements, elements.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*把toCopyIn的元素拷贝给当前list的数组。* Creates a list holding a copy of the given array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toCopyIn the array (a copy of this array is used as the</span></span><br><span class="line"><span class="comment"> *        internal array)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified array is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[]<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList的add 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *末尾添加一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取老数据</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//把老数据放在newElements总并且长度+1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//把数据e添加到尾部</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在index位置添加一个元素</span></span><br><span class="line"><span class="comment"> * 如果插入位置正好是末尾，只需要拷贝一次。否则，会进行两次拷贝 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//添加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取老数据</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//检查数组越界，copyOnWriteArrayList 没有size的概念所以这块用了</span></span><br><span class="line">        <span class="comment">//elemens.length</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果在尾部添加元素</span></span><br><span class="line">            <span class="comment">// 那么拷贝一个n+1的数组, 其前n个元素与旧数组一致</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果插入的位置不是最后一位</span></span><br><span class="line">            <span class="comment">// 那么新建一个n+1的数组</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//0-index的数据放在新数组中 然后index以后的数据后移动一位</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把新数据放在index位置</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CopyOnWriteArrayList add接口使用了ReentrantLock 重入锁加锁，保证了线程的安全</span></span><br></pre></td></tr></table></figure>

<p>可以发现这个过程可以 分为五步，加锁、新建数组拷贝原来数组、插入数据、给原来数组赋值、解锁 。</p>
<p>CopyOnWriteArrayList 的remove方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定位置的元素，并且指定位置后面的元素往左移动一位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//所有的可变操作都会使用重入锁添加所符合简介</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取老的数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果是末尾一位则那么直接拷贝一份n-1的新数组, 最后一位就自动删除了</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是最后一位新建一个n-1的新数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//将前index的元素拷贝到新数组中</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">//将index后面的元素往前挪一位</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除第一个元素o出现的位置的元素，其实就是删除第一个元素，Arraylist linkedList</span></span><br><span class="line"><span class="comment"> * 的remove方法也是删除第一个元素出现的位置 </span></span><br><span class="line"><span class="comment"> *注意：在获取旧数据的时候没有添加锁，也是所有的的可变操作中唯一没有添加锁的操作。*这个方法设计的特别别扭，完全可以获取当前元素所在的位置index 然后用remove（index）</span></span><br><span class="line"><span class="comment">*类似的方法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在快照中删除指定位置的元素0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//添加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取旧数组</span></span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="comment">//获取旧数据的参数长度 可能与shapshot的长度不一样</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="comment">//如果snapshot的元素与current的元素不一样 查找index</span></span><br><span class="line">                <span class="comment">//如果current没有变动的话则继续</span></span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    <span class="comment">//查找元素所在的位置</span></span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果index大于旧数据的长度则返回失败</span></span><br><span class="line">            <span class="comment">//index可能在snapshot中不一定在current中，因为current中的数据可能会</span></span><br><span class="line">            <span class="comment">//被修改</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">                <span class="comment">//判断idex是否在current中</span></span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除fromIndex与toindex索引之间的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//老规矩加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">//获取数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//验证fromIndex 与toindex 是否合法是否数组越界</span></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="comment">//获取新的数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> newlen = len - (toIndex - fromIndex);</span><br><span class="line">        <span class="comment">//计算toindex数组后面的的元素需要位移多少位</span></span><br><span class="line">        <span class="comment">//如果toIndex正好等于元素的长度直接copy到fromIndex的数据即可</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不等0 先创建一个长度为newLen的数组</span></span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[newlen];</span><br><span class="line">            <span class="comment">//fromIdex之前的数组copy到新数组中</span></span><br><span class="line">            <span class="comment">//在把toindex之后的数组copy到新数组中</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements,</span><br><span class="line">                             fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看得出，删除操作与新增操作类似。分为四步</p>
<p>1、加锁<br>2、判断索引位置，选择不同策略拷贝数组<br>3、给原来数组赋值<br>4、解锁</p>
<p>CopyOnWriteArrayList的addIfAbsent 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the element, if not present.</span></span><br><span class="line"><span class="comment"> *如果元素不存在则添加元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be added to this list, if absent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the element was added</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*跟remove处理的差不多 还是用的快照</span></span><br><span class="line"><span class="comment"> * A version of addIfAbsent using the strong hint that given</span></span><br><span class="line"><span class="comment"> * recent snapshot does not contain e.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//添加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="comment">//判断current是否有变动，</span></span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                <span class="comment">//说明元素有过修改并且元素不存在快照中</span></span><br><span class="line">                <span class="comment">//如果common等于snapshot的长度则说明元数据有新增操作</span></span><br><span class="line">                <span class="comment">//如果common等于current的长度则说明原数据有删除操作，</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拷贝一份n+1的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//元素放在最后一位</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类似ArrayList  size元素 、capacity元素  LinkedList的size元素是通过getArray().length ; ;</p>
<p>因为对CopyOnWriteArrayList的结构修改都添加了锁 。</p>
<p>总结：</p>
<p>（1）CopyOnWriteArrayList使用ReentrantLock重入锁加锁，保证线程安全；</p>
<p>（2）CopyOnWriteArrayList的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是O(n)，性能比较低下；</p>
<p>（3）CopyOnWriteArrayList的读操作支持随机访问，时间复杂度为O(1)；</p>
<p>（4）CopyOnWriteArrayList采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；</p>
<p>（5）CopyOnWriteArrayList只保证最终一致性，不保证实时一致性；</p>
<p>  (6) CopyOnWriteArrayList以为采用写时复制机制所以会占用内存，Yong GC和Full GC可能会发生，并且数据不能保持及时返回，如果需要及时返回插入的数据不建议使用CopyOnWriteArrayList</p>
<p>参考资料：</p>
<p> <a href="https://mp.weixin.qq.com/s/YQyroql8As9tpyRO9-MOsA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YQyroql8As9tpyRO9-MOsA</a> </p>
<p><a href="https://mp.weixin.qq.com/s/Zi5VWLiB_3VU2mCa8_p-5w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Zi5VWLiB_3VU2mCa8_p-5w</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-List集合-ArrayList和LinkedList-总结</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-List%E9%9B%86%E5%90%88-ArrayList%E5%92%8CLinkedList-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-Java集合简述"><a href="#1-Java集合简述" class="headerlink" title="1. Java集合简述"></a>1. Java集合简述</h2><p>作为一个Developer，Java集合类是我们在工作中运用最多的、最频繁的类。相比于数组(Array)来说，集合类的长度可变，更加适合于现代开发需求；</p>
<p>Java集合就像一个容器，可以存储任何类型的数据，也可以结合泛型来存储具体的类型对象。在程序运行时，Java集合可以动态的进行扩展，随着元素的增加而扩大。在Java中，集合类通常存在于java.util包中。</p>
<p>Java集合主要由2大体系构成，分别是Collection体系和Map体系，其中Collection和Map分别是2大体系中的顶层接口。</p>
<p>Collection主要有三个子接口，分别为List(列表)、Set(集)、Queue(队列)。其中，List、Queue中的元素有序可重复，而Set中的元素无序不可重复；</p>
<p>List中主要有ArrayList、LinkedList两个实现类；Set中则是有HashSet实现类；而Queue是在JDK1.5后才出现的新集合，主要以数组和链表两种形式存在。</p>
<p>Map同属于java.util包中，是集合的一部分，但与Collection是相互独立的，没有任何关系。Map中都是以key-value的形式存在，其中key必须唯一，主要有HashMap、HashTable、TreeMap三个实现类。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j0ROiac4adEvxvj298hmQzvPGRHbHFkZtJNhVUejQpAricutuCs4RaLRyF6fhpYj2ibcibkfyDZLOAVFicGm900y9Eg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h2 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2. List集合"></a>2. List集合</h2><p>List集合特点：元素有序，插入的数据可以重复。</p>
<p>在List集合中，我们常用到ArrayList和LinkedList这两个类。</p>
<p>其中，ArrayList底层通过数组实现，随着元素的增加而动态扩容。而LinkedList底层通过链表来实现，随着元素的增加不断向链表的后端增加节点。</p>
<h3 id="2-1-基本比较"><a href="#2-1-基本比较" class="headerlink" title="2.1 基本比较"></a>2.1 基本比较</h3><p><strong>1.ArrayList说明</strong></p>
<p>ArrayList是Java集合框架中使用最多的一个类，是一个数组队列，线程不安全集合。它继承于AbstractList，实现了List, RandomAccess, Cloneable, Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的类或者接口：</p>
<ul>
<li>ArrayList实现List，得到了List集合框架基础功能；</li>
<li>ArrayList实现RandomAccess，获得了快速随机访问存储元素的功能，RandomAccess是一个标记接口，没有任何方法；</li>
<li>ArrayList实现Cloneable，得到了clone()方法，可以实现克隆功能；</li>
<li>ArrayList实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。</li>
</ul>
<p>它具有如下特点：</p>
<ul>
<li><p>容量不固定，随着容量的增加而动态扩容（阈值基本不会达到）</p>
</li>
<li><p>有序集合（插入的顺序==输出的顺序）</p>
</li>
<li><p>插入的元素可以为null</p>
</li>
<li><p>增删改查效率更高（相对于LinkedList来说）</p>
</li>
<li><p>线程不安全</p>
</li>
</ul>
<p>数据结构：（JDK1.7）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j0ROiac4adEvxvj298hmQzvPGRHbHFkZtC3htVpzWuUN5c0ODFpl6Y7fbsLibibbKgoQ9721JPNlQgPCTUqJt2BRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p><strong>2.LinkedList说明</strong></p>
<p>LinkedList是一个双向链表，每一个节点都拥有指向前后节点的引用。相比于ArrayList来说，LinkedList的随机访问效率更低。它继承AbstractSequentialList，实现了List, Deque, Cloneable, Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的类或者接口：</p>
<ul>
<li>LinkedList实现List，得到了List集合框架基础功能；</li>
<li>LinkedList实现Deque，Deque 是一个双向队列，也就是既可以先入先出，又可以先入后出，说简单些就是既可以在头部添加元素，也可以在尾部添加元素；</li>
<li>LinkedList实现Cloneable，得到了clone()方法，可以实现克隆功能；</li>
<li>LinkedList实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。</li>
</ul>
<p>数据结构：（JDK1.7）</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j0ROiac4adEvxvj298hmQzvPGRHbHFkZt8ltNtVNib63ZBz53kSIZuXjTWEPiajRia0wzplGBhqJZOePK1pknkvzRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>可以发现其是一个双向链表结构。</p>
<h4 id="2-1-1-List常用方法"><a href="#2-1-1-List常用方法" class="headerlink" title="2.1.1 List常用方法"></a>2.1.1 List常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A:添加功能</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>:向集合中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span>:在指定位置添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>：向集合中添加一个集合的元素。</span></span><br><span class="line"><span class="function">B:删除功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>：删除集合中的所有元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>：根据指定索引删除元素，并把删除的元素返回</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>：从集合中删除指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>:从集合中删除一个指定的集合元素。</span></span><br><span class="line"><span class="function">C:修改功能</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>:把指定索引位置的元素修改为指定的值，返回修改前的值。</span></span><br><span class="line"><span class="function">D:获取功能</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>：获取指定位置的元素</span></span><br><span class="line"><span class="function">Iterator <span class="title">iterator</span><span class="params">()</span>:就是用来获取集合中每一个元素。</span></span><br><span class="line"><span class="function">E:判断功能</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断集合是否为空。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span>：判断集合中是否存在指定的元素。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span>：判断集合中是否存在指定的一个集合中的元素。</span></span><br><span class="line"><span class="function">F:长度功能</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>:获取集合中的元素个数</span></span><br><span class="line"><span class="function">G:把集合转换成数组</span></span><br><span class="line"><span class="function">Object[] <span class="title">toArray</span><span class="params">()</span>:把集合变成数组。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-ArrayList基本操作"><a href="#2-1-2-ArrayList基本操作" class="headerlink" title="2.1.2 ArrayList基本操作"></a>2.1.2 ArrayList基本操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建ArrayList集合：</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        System.out.println(<span class="string">"ArrayList集合初始化容量："</span>+list.size());</span><br><span class="line">        <span class="comment">//添加功能：</span></span><br><span class="line">        list.add(<span class="string">"Hello"</span>);</span><br><span class="line">        list.add(<span class="string">"world"</span>);</span><br><span class="line">        list.add(<span class="number">2</span>,<span class="string">"!"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ArrayList当前容量："</span>+list.size());</span><br><span class="line">        <span class="comment">//修改功能：</span></span><br><span class="line">        list.set(<span class="number">0</span>,<span class="string">"my"</span>);</span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ArrayList当前内容："</span>+list.toString());</span><br><span class="line">        <span class="comment">//获取功能：</span></span><br><span class="line">        String element = list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        <span class="comment">//迭代器遍历集合：(ArrayList实际的迭代器是Itr对象)</span></span><br><span class="line">        Iterator&lt;String&gt; iterator =  list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            String next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环迭代集合：</span></span><br><span class="line">        <span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断功能：</span></span><br><span class="line">        <span class="keyword">boolean</span> isEmpty = list.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> isContain = list.contains(<span class="string">"my"</span>);</span><br><span class="line">        <span class="comment">//长度功能：</span></span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="comment">//把集合转换成数组：</span></span><br><span class="line">        String[] strArray = list.toArray(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">        <span class="comment">//删除功能：</span></span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">        list.remove(<span class="string">"world"</span>);</span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">"ArrayList当前容量："</span>+list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-LinkedList基本操作"><a href="#2-1-3-LinkedList基本操作" class="headerlink" title="2.1.3 LinkedList基本操作"></a>2.1.3 LinkedList基本操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        System.out.println(<span class="string">"LinkedList初始容量："</span>+linkedList.size());</span><br><span class="line">        <span class="comment">//添加功能：</span></span><br><span class="line">        linkedList.add(<span class="string">"my"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"name"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"is"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        System.out.println(<span class="string">"LinkedList当前容量："</span>+ linkedList.size());</span><br><span class="line">        <span class="comment">//修改功能:</span></span><br><span class="line">        linkedList.set(<span class="number">0</span>,<span class="string">"hello"</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>,<span class="string">"world"</span>);</span><br><span class="line">        System.out.println(<span class="string">"LinkedList当前内容："</span>+ linkedList.toString());</span><br><span class="line">        <span class="comment">//获取功能：</span></span><br><span class="line">        String element = linkedList.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        <span class="comment">//遍历集合：(LinkedList实际的跌倒器是ListItr对象)</span></span><br><span class="line">        Iterator&lt;String&gt; iterator =  linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            String next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环迭代集合：</span></span><br><span class="line">        <span class="keyword">for</span>(String str:linkedList)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断功能：</span></span><br><span class="line">        <span class="keyword">boolean</span> isEmpty = linkedList.isEmpty();</span><br><span class="line">        <span class="keyword">boolean</span> isContains = linkedList.contains(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        <span class="comment">//长度功能：</span></span><br><span class="line">        <span class="keyword">int</span> size = linkedList.size();</span><br><span class="line">        <span class="comment">//删除功能：</span></span><br><span class="line">        linkedList.remove(<span class="number">0</span>);</span><br><span class="line">        linkedList.remove(<span class="string">"jiaboyan"</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        System.out.println(<span class="string">"LinkedList当前容量："</span> + linkedList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-ArrayList和LinkedList性能比较"><a href="#2-1-4-ArrayList和LinkedList性能比较" class="headerlink" title="2.1.4 ArrayList和LinkedList性能比较"></a>2.1.4 ArrayList和LinkedList性能比较</h4><p>（1）元素新增性能比较：</p>
<p>查看了网上很多的例子，很多都说，在新增操作时，ArrayList效率不如LinkedList，因为ArrayList底层是数组实现，在动态扩容时，性能有所损耗，而LinkedList不存在数组扩容机制，所以LinkedList效率更高。那么结果究竟怎样，来看下面的数据！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代次数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ITERATION_NUM = <span class="number">100000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        insertPerformanceCompare();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增性能比较：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertPerformanceCompare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"LinkedList新增测试开始"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        List&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERATION_NUM; x++) &#123;</span><br><span class="line">            linkedList.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        System.out.println(<span class="string">"ArrayList新增测试开始"</span>);</span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERATION_NUM; x++) &#123;</span><br><span class="line">            arrayList.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.nanoTime();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>结果与预想的有些不太一样，ArrayList的新增性能并不低。</p>
<p>究其原因，可能是经过JDK近几年的更新发展，对于数组复制的实现进行了优化，以至于ArrayList的性能也得到了提高。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j0ROiac4adEvxvj298hmQzvPGRHbHFkZtxPLCB6YR3gs5cByFictyvTeRkQ0t8FIG4yVpAxEx4wnDtfibbzvVdrTw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>（2）元素获取比较：</p>
<p>由于LinkedList是链表结构，没有角标的概念，没有实现RandomAccess接口，不具备随机元素访问功能，所以在get方面表现的差强人意，ArrayList再一次完胜。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代次数，集合大小：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ITERATION_NUM = <span class="number">100000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> </span>&#123;</span><br><span class="line">        getPerformanceCompare();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取性能比较：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getPerformanceCompare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">//填充ArrayList集合：</span></span><br><span class="line">        List&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERATION_NUM; x++) &#123;</span><br><span class="line">            arrayList.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//填充LinkedList集合：</span></span><br><span class="line">        List&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERATION_NUM; x++) &#123;</span><br><span class="line">            linkedList.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建随机数对象：</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(<span class="string">"LinkedList获取测试开始"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERATION_NUM; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = random.nextInt(x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> k = linkedList.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">        System.out.println(<span class="string">"ArrayList获取测试开始"</span>);</span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERATION_NUM; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = random.nextInt(x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> k = arrayList.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.nanoTime();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>从结果中可以看到，ArrayList在随机访问方面表现的十分优秀，比LinkedList强了很多，基本上保持在10多倍以上。</p>
<p>LinkedList为什么这么慢呢？这主要是LinkedList的代码实现所致，每一次获取都是从头开始遍历，一个个节点去查找，每查找一次就遍历一次，所以性能自然得不到提升。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/j0ROiac4adEvxvj298hmQzvPGRHbHFkZtUCnPJhp6AxHYndzq3ticsiaAZc5c7LQtMkFC4Fz30WkzKlTHibUht5t9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h3 id="2-1-ArrayList源码分析"><a href="#2-1-ArrayList源码分析" class="headerlink" title="2.1 ArrayList源码分析"></a>2.1 ArrayList源码分析</h3><p>接下来，我们几对ArrayList的源码进行一个解析，其中笔者提出了几个问题？</p>
<p>(1)ArrayList构造</p>
<p>(2)增删改查实现</p>
<p>(3)迭代器-modCount</p>
<p>(4)为什么数组对象要使用transient修饰符</p>
<p>(5)System.arraycopy（）参数含义 Arrays.copyOf（）参数含义</p>
<p>我们通过这这几个问题，来一步步的学习ArrayList！</p>
<ul>
<li>基本属性和构造方法</li>
</ul>
<p>在JDK1.8版本中</p>
<p><span style="color:red"><code>无参构造函数</code>：在调用无参构造函数时，将elementData设置为一个空内容。在后面的<code>add</code>方法中通过判断，如果elementData的值为空，则初始化容量为10。</span></p>
<p><span style="color:red"><code>有参构造函数</code>：给elementData设置是一个指定大小的数组。如果指定的大小为0，则也会设置为一个空内容，在<code>add</code>方法中设置初始默认容量为10</span></p>
<p><span style="color:red"><code>有参构造函数（传入的是集合）</code>：将该集合元素转换为数组后通过Arrays.copyOf()深层拷贝给elementData。</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现Serializable接口，生成的序列版本号：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line">    <span class="comment">//ArrayList初始容量大小：在无参构造中不使用了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//空数组对象：初始化中默认赋值给elementData</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;  </span><br><span class="line">    <span class="comment">//调用无参构造的时候返回该对象。与EMPTY_ELEMENTDATA的区别在于指定容量大小为0返回EMPTY_ELEMENTDATA。默认返回DEFAULTCAPACITY_EMPTY_ELEMENTDATA </span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="comment">//ArrayList中实际存储元素的数组：</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="comment">//集合实际存储元素长度：</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ArrayList有参构造：容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断初试话容量大小</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">//容量大于0，初始化数据：创建Object数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//容量等于0，返回空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//如果传递的初始容量小于0 ，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ArrayList无参构造：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ArrayList有参构造：集合作为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将集合转换为数组：</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//先把转换后的数组长度赋值给size，然后判断size大小</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用Arrays.copyOf进行深层复制</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// size等于0，表示创建的数组是一个空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>add()</li>
</ul>
<p>如果是通过无参构造函数创建的对象或则设置的容量为0，则设置容量为默认的10。</p>
<p><strong>扩容</strong>：当集合中存储的数据量size+1大于集合的容量时，需要扩容。扩容大小为原始的1.5倍大小。</p>
<ul>
<li>如果扩容后的容量大小还是小于size+1，则设置集合的容量设置为size+1；</li>
<li>如果扩容后的容量大小大于int的最大值，则设置集合的容量为int的最大值。</li>
</ul>
<p>利用<code>Arrays.copyOf()</code>方法进行深层复制，复制到一个新的数组中。</p>
<p><strong>fail-fast机制</strong>：当进行增删时，modCount会随着每一次的操作而+1，modCount记录了ArrayList内发生改变的次数。当迭代器在迭代时，会判断expectedModCount的值是否还与modCount的值保持一致，如果不一致则抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加元素e</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将对应角标下的元素赋值为e：</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到最小扩容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了下面两个方法</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否为第一次add操作，如果是需要和默认容量比较取较大值，否则直接返回 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前元素是否等于空 第一次执行add的时候执行才会是true</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">//当前容量和默认容量10比较，取大的值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//操作数+1；该变量主要是用来实现fail-fast机制的</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//当前size+1大于数组容量进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList动态扩容的核心方法:</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取现有数组大小：</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//位运算，得到新的数组容量大小，为原有的1.5倍：</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果新扩容的大小依旧小于传入的容量值，那么将传入的值设为新容器大小：</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果新容器大小，大于ArrayList最大长度：</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//计算出最大容量值：</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//数组复制：</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算ArrayList最大容量：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">//如果新的容量大于MAX_ARRAY_SIZE。将会调用hugeCapacity将int的最大值赋给newCapacity:</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>上面提到一个变量<code>MAX_ARRAY_SIZE</code>,其定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为什么要减去8呢？</span></span><br><span class="line"><span class="comment"> * 因为某些JVM会在数组中保留一些头字，尝试分配这个最大存储容量，可能会导致array容量大于JVM的限制，最终导致OutOfMemoryError。</span></span><br><span class="line"><span class="comment"> * 判断数组容量是否达到Integer.MAX_VALUE - 8,达到就返回Integer.MAX_VALUE - 8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>remove()</li>
</ul>
<p>remove(int index)是针对于角标来进行删除，不需要去遍历整个集合，效率更高；<br>而remove(Object o)是针对于对象来进行删除，需要遍历整个集合进行equals()方法比对，所以效率较低；</p>
<p>不过，无论是哪种形式的删除，最终都会调用System.arraycopy()方法进行数组复制操作，所以效率都会受到影响；</p>
<p><span style="color:red"><code>System.arraycopy()</code>可以设定复制的长度，而<code>Arrays.copyOf()</code>方法时全部复制到一个新数组中。</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在ArrayList的移除index位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查角标是否合法：不合法抛异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//操作数+1：</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取当前角标的value:</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数；</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果移动元素个数大于0 ，也就是说删除的不是最后一个元素：</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将elementData数组index+1位置开始拷贝到elementData从index开始的空间</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">//size减1，并将最后一个元素置为null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//返回被删除的元素：</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在ArrayList的移除对象为O的元素，不返回被删除的元素：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果o==null，则遍历集合，判断哪个元素为null：</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//快速删除，和前面的remove（index）一样的逻辑</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//同理：</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速删除：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//操作数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取需要删除元素 到最后一个元素的长度，也就是删除元素后，后续元素移动的个数；</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果移动元素个数大于0 ，也就是说删除的不是最后一个元素：</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将elementData数组index+1位置开始拷贝到elementData从index开始的空间</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    <span class="comment">//size减1，并将最后一个元素置为null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>set()</li>
</ul>
<p>由于ArrayList实现了RandomAccess，所以具备了随机访问特性，调用elementData()可以获取到对应元素的值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置index位置的元素值了element，返回该位置的之前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index是否合法：判断index是否大于size</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//获取该index原来的元素：</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//替换成新的元素：</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">//返回旧的元素：</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>get()</li>
</ul>
<p>通过elementData()方法获取对应角标元素，在返回时候进行类型转换；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取index位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index是否合法：</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//获取元素：</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取数组index位置的元素：返回时类型转换</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>modCount含义</li>
</ul>
<p>在调用<code>iterator</code>方法时，创建了一个<code>Itr</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Itr对象时，将ArrayList的modCount属性的值赋给expectedModCount。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Itr实现了Iterator接口，是ArrayList集合的迭代器对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">//类似游标，指向迭代器下一个值的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">//迭代器最后一次取出的元素的位置，-1表示没有</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line">	<span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子中，我们可以知道当进行增删时，modCount会随着每一次的操作而+1，modCount记录了ArrayList内发生改变的次数。</p>
<p>当迭代器在迭代时，会判断expectedModCount的值是否还与modCount的值保持一致，如果不一致则抛出异常。</p>
<p>AbstractList类当中定义的变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>迭代器中主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用游标，与size之前的比较，判断迭代器是否还有下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器获取下一个元素：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查modCount是否改变：</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="comment">//游标不会大于等于集合的长度：</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = java.util.ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="comment">//游标不会大于集合中数组的长度：</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="comment">//游标+1</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//取出元素：</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除list集合中最后一个数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="comment">//检查modCount是否改变：防止并发操作集合</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//删除这个元素：</span></span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        <span class="comment">//删除后，重置游标，和当前指向元素的角标 lastRet</span></span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//重置expectedModCount：</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//并发检查：</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8中新增的方法，用于lambda表示使用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(consumer);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">        consumer.accept((E) elementData[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">    cursor = i;</span><br><span class="line">    lastRet = i - <span class="number">1</span>;</span><br><span class="line">    checkForComodification();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>transient</li>
</ul>
<p>transient修饰符是什么含义？</p>
<p>当我们序列化对象时，如果对象中某个属性不进行序列化操作，那么在该属性前添加transient修饰符即可实现；例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>

<p>那么，为什么ArrayList不想对elementData属性进行序列化呢？elementData可是集合中保存元素的数组啊，如果不序列化elementData属性，那么在反序列化时候，岂不是丢失了原先的元素？</p>
<p>ArrayList在添加元素时，可能会对elementData数组进行扩容操作，而扩容后的数组可能并没有全部保存元素。</p>
<p>例如：我们创建了new Object[10]数组对象，但是我们只向其中添加了1个元素，而剩余的9个位置并没有添加元素。当我们进行序列化时，并不会只序列化其中一个元素，而是将整个数组进行序列化操作，那些没有被元素填充的位置也进行了序列化操作，间接的浪费了磁盘的空间，以及程序的性能。</p>
<p>所以，ArrayList才会在elementData属性前加上transient修饰符。</p>
<p>接下来，我们来看下ArrayList的writeObject()、readObject()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化写入：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 序列化读取：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span> <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    s.readInt();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList在序列化时会调用writeObject()，直接将elementData写入ObjectOutputStream；</p>
<p>而反序列化时则调用readObject()，从ObjectInputStream获取elementData；</p>
<ul>
<li>Arrays.copyOf()</li>
</ul>
<p>该方法在内部创建了一个新数组，底层实现是调用System.arraycopy()；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        ? (T[]) new Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>original - 要复制的数组</p>
<p>newLength - 要返回的副本的长度</p>
<p>newType - 要返回的副本的类型</p>
<ul>
<li>System.arraycopy()</li>
</ul>
<p>该方法是用了native关键字，调用的为C++编写的底层函数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>src - 源数组。</p>
<p>srcPos - 源数组中的起始位置。</p>
<p>dest - 目标数组。</p>
<p>destPos - 目标数据中的起始位置。</p>
<p>length - 要复制的数组元素的数量。</p>
<h3 id="2-2-LinkedList源码分析"><a href="#2-2-LinkedList源码分析" class="headerlink" title="2.2 LinkedList源码分析"></a>2.2 LinkedList源码分析</h3><p>在写本篇LinkedList源码之前，笔者也看了网上不少的讲解文章。</p>
<p>发现很多文章在介绍的时候，都说LinkedList是一个环形链表结构，头尾相连。但，当我开始看源码的时候，发现并不是环形链表，是一个直线型链表结构，我一度以为是我理解有误。后来发现，JDK1.7之前的版本是环形链表，而到了JDK1.7以后进行了优化，变成了直线型链表结构；</p>
<ul>
<li>集合基础结构</li>
</ul>
<p>在LinkedList中，内部类Node对象最为重要，它组成了LinkedList集合的整个链表，分别指向上一个点、下一个结点，存储着集合中的元素；</p>
<p>成员变量中，first表明是头结点，last表明是尾结点；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//LinkedList的元素个数：</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//LinkedList的头结点：Node内部类</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">//LinkedList尾结点：Node内部类</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">//空实现：头尾结点均为null，链表不存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用添加方法：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点的数据结构，包含前后节点的引用和当前节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//结点元素：</span></span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">//结点后指针</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        <span class="comment">//结点前指针</span></span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>add()</li>
</ul>
<p>LinkedList的添加方法，主要分为2种，一是直接添加一个元素，二是在指定角标下添加一个元素；</p>
<p>add(E e)底层调用linkLast(E e)方法，就是在链表的最后面插入一个元素；</p>
<p>add(int index, E element)，插入的角标如果==size，则插入到链表最后；否则，按照角标大小插入到对应位置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加元素：添加到最后一个结点；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//last节点插入新元素：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将尾结点赋值个体L:</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//创建新的结点，将新节点的前指针指向l:</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//新节点置为尾结点：</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果尾结点l为null：则是空集合新插入</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//头结点也置为 新节点：</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//l节点的后指针指向新节点：</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//长度+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//操作数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向对应角标添加元素：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查传入的角标 是否正确：</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">//如果插入角标==集合长度，则插入到集合的最后面：</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//插入到对应角标的位置：获取此角标下的元素先</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在succ前插入 新元素e：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取被插入元素succ的前指针元素：</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">//创建新增元素节点，前指针 和 后指针分别指向对应元素：</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="comment">//succ的前指针元素可能为null，为null的话说明succ是头结点，则把新建立的结点置为头结点：</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//succ前指针不为null，则将前指针的结点的后指针指向新节点：</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    <span class="comment">//长度+1</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//操作数+1</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于LinkedList集合增加元素来说，可以简单的概括为以下几点：</p>
<p>将添加的元素转换为LinkedList的Node对象节点；</p>
<p>增加该Node节点的前后引用，即该Node节点的prev、next属性，让其分别指向哪一个节点）；</p>
<p>修改该Node节点的前后Node节点中pre/next属性，使其指向该节点。</p>
<p><img src="/.io//gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt></p>
<ul>
<li>remove()</li>
</ul>
<p>LinkedList的删除也提供了2种形式，其一是通过角标删除元素，其二就是通过对象删除元素；不过，无论哪种删除，最终调用的都是unlink来实现的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除对应角标的元素：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//node()方法通过角标获取对应的元素，在后面介绍</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除LinkedList中的元素，可以删除为null的元素，逐个遍历LinkedList的元素，重复元素只删除第一个：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果删除元素为null：</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果删除元素不为null：</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除LinkedList结点：remove()方法中调用</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取被删除结点的元素E：</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="comment">//获取被删除元素的后指针结点：</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="comment">//获取被删除元素的前指针结点：</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="comment">//被删除结点的 前结点为null的话：</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将后指针指向的结点置为头结点</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//前置结点的  尾结点指向被删除的next结点；</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">//被删除结点前指针置为null:</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对尾结点同样处理：</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>set()</li>
</ul>
<p>LinkedList的set(int index, E element)方法与add(int index,E element)的设计思路基本一致，都是创建新Node节点，插入到对应的角标下，修改前后节点的prev、next属性；</p>
<p>其中，node(int index)方法至关重要，通过对应角标获取到对应的集合元素。</p>
<p>可以看到，node（）中是根据角标的大小是选择从前遍历还是从后遍历整个集合。也可以间接的说明，LinkedList在随机获取元素时性能很低，每次的获取都得从头或者从尾遍历半个集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置对应角标的元素：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//通过node()方法，获取到对应角标的元素：</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取对应角标所属于的结点：</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//位运算：如果位置索引小于列表长度的一半，则从头开始遍历；否则，从后开始遍历；</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="comment">//从头结点开始遍历：遍历的长度就是index的长度，获取对应的index的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从集合尾结点遍历：</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="comment">//同样道理：</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>get()</li>
</ul>
<p>get(int index)</p>
<p>终于到了最后一个方法，也是开发中最常用的方法。其中，核心方法node(int index)在上面已经介绍过。</p>
<p>在通过node(int index)获取到对应节点后，返回节点中的item属性，该属性就是我们所保存的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取相应角标的元素：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查角标是否正确：</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//获取角标所属结点的 元素值：</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>迭代器</li>
</ul>
<p>在LinkedList中，并没有自己实现iterator()方法，而是使用其父类</p>
<p>AbstractSequentialList的iterator()方法;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator =  linkedList.iterator();</span><br></pre></td></tr></table></figure>

<p>父类AbstractSequentialList中的 iterator():</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类AbstractList中的 listIterator()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedList中的 listIterator()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>注：LinkedList实现的Deque队列的方法，等讲到Deque时在阐述；</p>
<h2 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h2><p><strong>1.在利用remove方法时的问题</strong></p>
<p>在使用ArrayList比较常见的一个问题就是在遍历ArrayList的时候调用remove()方法进行元素的删除操作,从而得到意想不到的结果，本人在开发过程中也遇到过这样的问题，所以在这里提出了，希望能够帮助到大家。</p>
<p>（1）实例及分析</p>
<p>如下代码中，在遍历List时，调用了remove方法，删除元素a</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arrayList中的值为 [a,a,c,a,a]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.get(i)==<span class="string">'a'</span>)&#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这段代码看似解决了删除列表中所有的a元素，但是删除后得出List的结果为[a, c, a]，为什么这种方式没有达到想要的效果，其实仔细分析后会发现，在调用remove()方法时List的长度会发生变化而且元素的位置会发生移动，从而在遍历时list实际上是变化的，例如</p>
</li>
<li><p>当i=0时，此时list中的元素为[a,a,c,a,a],</p>
</li>
<li><p>但当i=1时，此时List中的元素为[a,c,a,a],元素的位置发生了移动，从而导致在遍历的过程中不能达到删除的效果</p>
</li>
</ul>
<p>（2）解决方案</p>
<p>通过上述的分析可以看出，出现问题的原因是元素的位置发生了移动，从而导致异常的结果 </p>
<p>方案一、逆向遍历List删除,代码如下，这种做法可行主要是因为remove()方法删除index处的元素时，是将index+1到size-1索引处的元素前移，而逆向遍历可以避免元素位置的移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改方案1；从后往前删除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.get(i)==<span class="string">'a'</span>)&#123;</span><br><span class="line">        list.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方案二、使用迭代器中的remove方法，迭代器具体参考Iterator详解，主要代码如下(这种方式比较推荐)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改方案2：使用迭代器中的remove方法</span></span><br><span class="line">ListIterator&lt;Character&gt; ite = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext())&#123;</span><br><span class="line">    <span class="keyword">if</span> (ite.next()==<span class="string">'a'</span>)&#123;</span><br><span class="line">        ite.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>原文链接： </p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Comparable和Comparator区别</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Comparable%E5%92%8CComparator%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h2 id="1-Comparable-简介"><a href="#1-Comparable-简介" class="headerlink" title="1. Comparable 简介"></a>1. Comparable 简介</h2><p>Comparable 是排序接口。</p>
<p>若一个类实现了Comparable接口，就意味着“该类支持排序”。  即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。</p>
<p>此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。</p>
<p>Comparable 接口仅仅只包括一个函数，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。</p>
<h2 id="2-Comparator-简介"><a href="#2-Comparator-简介" class="headerlink" title="2. Comparator 简介"></a>2. Comparator 简介</h2><p>Comparator 是比较器接口。</p>
<p>我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。</p>
<p>也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。</p>
<p>Comparator 接口仅仅只包括两个个函数，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还存在一个实现了的方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>(01) 若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。</p>
<p>为什么可以不实现 equals(Object obj) 函数呢？ 因为任何类，默认都是已经实现了equals(Object obj)的。 Java中的一切类都是继承于java.lang.Object，在Object.java中实现了equals(Object obj)函数；所以，其它所有的类也相当于都实现了该函数。</p>
<p>(02) int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p>
<h2 id="3-Comparator-和-Comparable-比较"><a href="#3-Comparator-和-Comparable-比较" class="headerlink" title="3. Comparator 和 Comparable 比较"></a>3. Comparator 和 Comparable 比较</h2><p>Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。</p>
<p>而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p>
<p>我们不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p>
<p>我们通过一个测试程序来对这两个接口进行说明。源码如下：</p>
<p>import java.util.*;<br>import java.lang.Comparable;/**<br> * @desc “<br> */</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparator和Comparable的比较程序。</span></span><br><span class="line"><span class="comment"> *   (01) "Comparable"</span></span><br><span class="line"><span class="comment"> *   它是一个排序接口，只包含一个函数compareTo()。</span></span><br><span class="line"><span class="comment"> *   一个类实现了Comparable接口，就意味着“该类本身支持排序”，它可以直接通过Arrays.sort() 或 Collections.sort()进行排序。</span></span><br><span class="line"><span class="comment"> *   (02) "Comparator"</span></span><br><span class="line"><span class="comment"> *   它是一个比较器接口，包括两个函数：compare() 和 equals()。</span></span><br><span class="line"><span class="comment"> *   一个类实现了Comparator接口，那么它就是一个“比较器”。其它的类，可以根据该比较器去排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   综上所述：Comparable是内部比较器，而Comparator是外部比较器。</span></span><br><span class="line"><span class="comment"> *   一个类本身实现了Comparable比较器，就意味着它本身支持排序；若它本身没实现Comparable，也可以通过外部比较器Comparator进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparableAndComparatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        </span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"ccc"</span>, <span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"AAA"</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"bbb"</span>, <span class="number">10</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"ddd"</span>, <span class="number">40</span>));        </span><br><span class="line">        System.out.println(<span class="string">"原始排序列表为："</span>+list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">"根据name排序结果为："</span>+list);</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> AscAgeComparator());</span><br><span class="line">        System.out.println(<span class="string">"根据age升序结果为："</span>+ list);</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> DescAgeComparator());</span><br><span class="line">        System.out.println(<span class="string">"根据age降序结果为："</span>+list);</span><br><span class="line">        testEquals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断两个对象是否相同，这里需要看看Person类的equals方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEquals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (p1.equals(p2)) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s EQUAL %s\n"</span>, p1, p2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s NOT EQUAL %s\n"</span>, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Person实现了Comparable接口，这意味着Person本身支持排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">" - "</span> +age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较两个Person是否相等：若它们的name和age都相等，则认为它们相等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.age == person.age &amp;&amp; <span class="keyword">this</span>.name == person.name) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 实现 “Comparable&lt;String&gt;” 的接口，即重写compareTo&lt;T t&gt;函数。</span></span><br><span class="line"><span class="comment">         *  这里是通过“person的名字”进行比较的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.compareTo(person.name);</span><br><span class="line">            <span class="comment">//return this.name - person.name;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> AscAgeComparator比较器</span></span><br><span class="line"><span class="comment">     *       它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AscAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> DescAgeComparator比较器</span></span><br><span class="line"><span class="comment">     *       它是“Person的age的升序比较器”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DescAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">原始排序列表为：[ccc - 20,<span class="built_in"> AAA </span>- 30, bbb - 10, ddd - 40]</span><br><span class="line">根据name排序结果为：[AAA - 30, bbb - 10, ccc - 20, ddd - 40]</span><br><span class="line">根据age升序结果为：[bbb - 10, ccc - 20,<span class="built_in"> AAA </span>- 30, ddd - 40]</span><br><span class="line">根据age降序结果为：[ddd - 40,<span class="built_in"> AAA </span>- 30, ccc - 20, bbb - 10]</span><br><span class="line">eee - 100 EQUAL eee - 100</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4-集合-Java基础-Collections工具类</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-4-%E9%9B%86%E5%90%88-Java%E5%9F%BA%E7%A1%80-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>Java提供了一个操作Set、List和Map等集合的工具类：Collections，该工具类提供了大量方法对集合进行排序、查询和修改等操作，还提供了将集合对象置为不可变、对集合对象实现同步控制等方法</p>
<h2 id="1-排序操作"><a href="#1-排序操作" class="headerlink" title="1. 排序操作"></a>1. 排序操作</h2><p>void reverse(List list)：反转指定List集合中元素的顺序</p>
<ul>
<li><p>void shuffle(List list)：对List集合元素进行随机排序（shuffle方法模拟了“洗牌”动作）</p>
</li>
<li><p>void sort(List list)：根据元素的自然顺序对指定List集合的元素按升序进行排序</p>
</li>
<li><p>void sort(List list, Comparator c)：根据指定Comparator比较器产生的顺序对List集合元素进行排序</p>
</li>
<li><p>void swap(List list, int i, int j)：在指定List集合中的i处元素和j处元素进行交换</p>
</li>
<li><p>void rotate(List list, int distance)：当distance为正数时，将List集合的后distance个元素“整体”移到前面；当distance为负数时，将list集合的前distance个元素“整体”移到后边。该方法不会改变集合的长度</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList nums = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        nums.add(<span class="number">2</span>);</span><br><span class="line">        nums.add(-<span class="number">5</span>);</span><br><span class="line">        nums.add(<span class="number">3</span>);</span><br><span class="line">        nums.add(<span class="number">0</span>);</span><br><span class="line">        System.out.println(nums); <span class="comment">// 输出:[2, -5, 3, 0]</span></span><br><span class="line">        Collections.reverse(nums); <span class="comment">// 将List集合元素的次序反转</span></span><br><span class="line">        System.out.println(nums); <span class="comment">// 输出:[0, 3, -5, 2]</span></span><br><span class="line">        Collections.sort(nums); <span class="comment">// 将List集合元素的按自然顺序排序</span></span><br><span class="line">        System.out.println(nums); <span class="comment">// 输出:[-5, 0, 2, 3]</span></span><br><span class="line">        Collections.shuffle(nums); <span class="comment">// 将List集合元素的按随机顺序排序</span></span><br><span class="line">        System.out.println(nums); <span class="comment">// 每次输出的次序不固定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-查找、替换操作"><a href="#2-查找、替换操作" class="headerlink" title="2. 查找、替换操作"></a>2. 查找、替换操作</h2><ul>
<li><p>int binarySearch(List list, Object key)：使用二分搜索法搜索指定列表，以获得指定对象在List集合中的索引。<br>此前必须保证List集合中的元素已经处于有序状态</p>
</li>
<li><p>Object max(Collection coll)：根据元素的自然顺序，返回给定collection中的最大元素</p>
</li>
<li><p>Object max(Collection coll, Comparator comp)：根据指定Comparator比较器产生的顺序，返回给定collection中的最大元素</p>
</li>
<li><p>Object min(Collection coll)：根据元素的自然顺序，返回给定collection中的最小元素</p>
</li>
<li><p>Object min(Collection coll, Comparator comp)：根据指定Comparator比较器产生的顺序，返回给定 collection中的最小元素</p>
</li>
<li><p>void fill(List list, Object obj)：使用指定元素obj替换指定List集合中的所有元素</p>
</li>
<li><p>int frequency(Collection c, Object o)：返回指定collection中指定元素的出现次数</p>
</li>
<li><p>int indexOfSubList(List source, List target)：返回子List对象在父List对象中第一次出现的位置索引；如果没有出现这样的列表，则返回-1</p>
</li>
<li><p>int lastIndexOfSubList(List source, List target)：返回子List对象在父List对象中最后一次出现的位置索引；如果没有出现这样的列表，则返回-1</p>
</li>
<li><p>boolean replaceAll(List list, Object oldVal, Object newVal)：使用一个新值newVal替换List对象的所有旧值oldVal</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList nums = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        nums.add(<span class="number">23</span>);</span><br><span class="line">        nums.add(<span class="number">0</span>);</span><br><span class="line">        nums.add(<span class="number">9</span>);</span><br><span class="line">        nums.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(nums); <span class="comment">// 输出:[23, 0, 9, 3]</span></span><br><span class="line">        System.out.println(Collections.max(nums)); <span class="comment">// 输出最大元素，将输出23</span></span><br><span class="line">        System.out.println(Collections.min(nums)); <span class="comment">// 输出最小元素，将输出0</span></span><br><span class="line">        Collections.replaceAll(nums , <span class="number">0</span> , <span class="number">1</span>); <span class="comment">// 将nums中的0使用1来代替</span></span><br><span class="line">        System.out.println(nums); <span class="comment">// 输出:[23, 1, 9, 3]</span></span><br><span class="line">        <span class="comment">// 判断-5在List集合中出现的次数，返回1</span></span><br><span class="line">        System.out.println(Collections.frequency(nums , <span class="number">23</span>));</span><br><span class="line">        Collections.sort(nums); <span class="comment">// 对nums集合排序</span></span><br><span class="line">        System.out.println(nums); <span class="comment">// 输出:[1, 3, 9, 23]</span></span><br><span class="line">        <span class="comment">//只有排序后的List集合才可用二分法查询，输出3</span></span><br><span class="line">        System.out.println(Collections.binarySearch(nums , <span class="number">23</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-同步控制"><a href="#3-同步控制" class="headerlink" title="3. 同步控制"></a>3. 同步控制</h2><p>Collectons提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题</p>
<p>Java常用的集合框架中的实现类HashSet、TreeSet、ArrayList、LinkedList、HashMap、TreeMap都是线程不安全的。Collections提供了多个静态方法可以把他们包装成线程同步的集合</p>
<ul>
<li><p>Collection synchronizedCollection(Collection c)：返回指定collection支持的同步（线程安全的）collection</p>
</li>
<li><p>List synchronizedList(List list)：返回指定List支持的同步（线程安全的）List</p>
</li>
<li><p>Map synchronizedMap(Map m)：返回由指定Map支持的同步（线程安全的）Map</p>
</li>
<li><p>Set synchronizedSet(Set s)：返回指定Set支持的同步（线程安全的）Set</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 下面程序创建了四个线程安全的集合对象</span></span><br><span class="line">        Collection c = Collections</span><br><span class="line">            .synchronizedCollection(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">        Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line">        Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-设置不可变集合"><a href="#4-设置不可变集合" class="headerlink" title="4. 设置不可变集合"></a>4. 设置不可变集合</h2><p>Collections提供了如下三个方法来返回一个不可变集合：</p>
<p>emptyXxx()：返回一个空的、不可变的集合对象，此处的集合既可以是List、SortedSet、Set、SortedMap、Map</p>
<p>singletonXxx()：返回一个只包含指定对象（只有一个或一个元素）的、不可变的集合对象，此处的集合可以是List和Map</p>
<p>unmodifiableXxx()：返回指定集合对象的不可变视图，此处的集合可以是：List、SortedSet、Set、SortedMap、Map</p>
<p>通过上面Collections提供的三类方法，可以生成“只读”的Collection或Map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个空的、不可改变的List对象</span></span><br><span class="line">        List unmodifiableList = Collections.emptyList();</span><br><span class="line">        <span class="comment">// 创建一个只有一个元素，且不可改变的Set对象</span></span><br><span class="line">        Set unmodifiableSet = Collections.singleton(<span class="string">"MVP"</span>);</span><br><span class="line">        <span class="comment">// 创建一个普通Map对象</span></span><br><span class="line">        Map player = <span class="keyword">new</span> HashMap();</span><br><span class="line">        player.put(<span class="string">"勒布朗詹姆斯"</span>, <span class="number">23</span>);</span><br><span class="line">        player.put(<span class="string">"克莱汤普森"</span>, <span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 返回普通Map对象对应的不可变版本</span></span><br><span class="line">        Map unmodifiableMap = Collections.unmodifiableMap(player);</span><br><span class="line">        <span class="comment">// 下面任意一行代码都将引发UnsupportedOperationException异常</span></span><br><span class="line">        unmodifiableList.add(<span class="string">"德怀恩韦德"</span>);   <span class="comment">//①</span></span><br><span class="line">        unmodifiableSet.add(<span class="string">"克里斯波什"</span>);    <span class="comment">//②</span></span><br><span class="line">        unmodifiableMap.put(<span class="string">"语伊戈达拉"</span>, <span class="number">9</span>);   <span class="comment">//③</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可变的集合对象只能访问集合元素，不可修改集合元素，上述①、②、③处代码都将引发UnsupportedOperationException异常</p>
<p>参考原文：</p>
<p> <a href="https://segmentfault.com/a/1190000007982915" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007982915</a> </p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>1.Collections类是什么？</p>
<p>Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。</p>
<p>2.ArrayList实现排序功能？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="string">"aa"</span>);</span><br><span class="line">    list.add(<span class="string">"dd"</span>);</span><br><span class="line">    list.add(<span class="string">"cc"</span>);</span><br><span class="line">    list.add(<span class="string">"aaa"</span>);</span><br><span class="line">    list.add(<span class="string">"ww"</span>);</span><br><span class="line">    list.add(<span class="string">"ee"</span>);</span><br><span class="line"></span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-3-函数-3-Java基础：参数变量可变的方法</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-3-%E5%87%BD%E6%95%B0-3-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-问题提出"><a href="#1-问题提出" class="headerlink" title="1. 问题提出"></a>1. 问题提出</h2><p>今天在复习Java基础相关的内容时，发现了类似下面的这种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>... values)</span></span></span><br></pre></td></tr></table></figure>

<p>查阅了，在JDK1.5之后，出现了一个可变参数的定义。</p>
<h2 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span>... values)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> largest = Double.NEGATIVE_INFINITY;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> v : values)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v&gt;largest)&#123;</span><br><span class="line">            largest = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> largest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">System.out.println(<span class="string">"最大值："</span>+max(<span class="number">3.1</span>, <span class="number">40.3</span>, -<span class="number">5</span>)); <span class="comment">// 输出40.3</span></span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p><code>max(3.1, 40.3, -5)</code>等价于使用了<code>new double[]{3.1,40.3,-5}</code></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-3-函数-2-Java基础：重写和重载</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-3-%E5%87%BD%E6%95%B0-2-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="java中重载与重写的区别"><a href="#java中重载与重写的区别" class="headerlink" title="java中重载与重写的区别"></a>java中重载与重写的区别</h2><h3 id="1-重载-Overloading"><a href="#1-重载-Overloading" class="headerlink" title="1. 重载(Overloading)"></a>1. 重载(Overloading)</h3><ul>
<li>方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<span style="color:red">重载Overloading是一个类中多态性的一种表现。</span></li>
<li>Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。<span style="color:red">调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。</span></li>
<li>重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。</li>
</ul>
<p>总结：</p>
<p><strong>而重载的规则：</strong></p>
<p>1、必须具有不同的参数列表；</p>
<p>2、可以有不同的返回类型，只要参数列表不同就可以了；</p>
<p>3、可以有不同的访问修饰符；</p>
<p>4、可以抛出不同的异常；</p>
<h3 id="2-重写-Overriding）"><a href="#2-重写-Overriding）" class="headerlink" title="2. 重写(Overriding）"></a>2. 重写(Overriding）</h3><ul>
<li>父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)，在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。</li>
<li>若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。</li>
<li>子类函数的访问修饰权限不能少于父类的；</li>
</ul>
<p><strong>重写方法的规则</strong>：</p>
<p>1、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p>2、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p>
<p>3、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p>
<p>4、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：</p>
<p>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p>
<p><strong>重写与重载的区别在于：</strong></p>
<p>重写多态性起作用，对调用被重载过的方法可以大大减少代码的输入量，同一个方法名只要往里面传递不同的参数就可以拥有不同的功能或返回值。</p>
<p>用好重写和重载可以设计一个结构清晰而简洁的类，可以说重写和重载在编写代码过程中的作用非同一般.</p>
<p>原文地址：<a href="https://www.cnblogs.com/bluestorm/archive/2012/03/01/2376236.html" target="_blank" rel="noopener">https://www.cnblogs.com/bluestorm/archive/2012/03/01/2376236.html</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-3-函数-1-Java基础：值传递和引用传递</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-3-%E5%87%BD%E6%95%B0-1-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>通常方法参数有两种类型：</p>
<ul>
<li>基本数据类型（数字、布尔值）</li>
<li>对象引用</li>
</ul>
<p>上面两种类型代表着两种值传递类型，便是值传递和引用传递。</p>
<h2 id="2-基本数据类型作为参数传递"><a href="#2-基本数据类型作为参数传递" class="headerlink" title="2. 基本数据类型作为参数传递"></a>2. 基本数据类型作为参数传递</h2><p><strong>基本数据类型作为参数传递时都是传递值的拷贝。</strong> 指的是方法调用中，传递的是值的拷贝，无论怎么改变这个拷贝，原值是不会改变的。</p>
<p>也即是说实参把它的值传递给形参，对形参的改变不会影响实参的值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Test test1 = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"调用前的i="</span> + i);</span><br><span class="line">        test1.testPassParameter(i);</span><br><span class="line">        <span class="comment">//传递后,testPassParameter方法中对形参i的改变不会影响这里的i</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"调用后的i="</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPassParameter</span>(<span class="params"><span class="keyword">int</span> i</span>)</span> &#123;</span><br><span class="line">        i = <span class="number">10</span>;<span class="comment">//这里只是对形参的改变</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"tpp方法中的i="</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用前的i&#x3D;5</span><br><span class="line">tpp方法中的i&#x3D;10</span><br><span class="line">调用后的i&#x3D;5</span><br></pre></td></tr></table></figure>

<h2 id="3-对象引用作为参数传递"><a href="#3-对象引用作为参数传递" class="headerlink" title="3. 对象引用作为参数传递"></a>3. 对象引用作为参数传递</h2><p>对象作为参数传递时，在方法内改变对象的值，有时原对象跟着改变，而有时又没有改变。就会让人对“传值”和“传引用”产生疑惑。</p>
<p>先看看两种情况的例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">        changeStringBuffer(s1, s2);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"s1="</span> + s1);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"s2="</span> + s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeStringBuffer</span>(<span class="params">StringBuffer ss1, StringBuffer ss2</span>)</span> &#123;</span><br><span class="line">        ss1.append(<span class="string">"world"</span>);</span><br><span class="line">        ss2 = ss1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1&#x3D;helloworld</span><br><span class="line">s2&#x3D;hello</span><br></pre></td></tr></table></figure>

<p><strong>分析如下：</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(1)s1,s2指向字符串的地址不同，假设为地址1，地址2</span></span><br><span class="line"><span class="built_in">StringBuffer</span> s1 = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">StringBuffer</span> s2 = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6133202-958eef824c42a247.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/439/format/webp" alt></p>
<p>image</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(2)调用changeStringBuffer方法</span></span><br><span class="line">changeStringBuffer(s1, s2);</span><br><span class="line"><span class="comment">//调用后会将s1,s2的地址(地址1，地址2)传给ss1,ss2，即现在ss1也指向地址1，ss2也指向地址2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6133202-07eb0334ed6989cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/406/format/webp" alt></p>
<p>image</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(3)ss1所指向字符串的值变为helloworld,调用者s1的值相应变化。</span></span><br><span class="line">ss1.<span class="built_in">append</span>(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//ss2将指向ss1指向的地址(地址1),但此时s2依旧指向地址2，s2的值在调用前后不变。</span></span><br><span class="line">ss2 = ss1;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6133202-b8071bc1fb5898b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/407/format/webp" alt></p>
<p>所以，s1的输出为helloworld,s2的输出结果为hello。</p>
<p>（注意，这里为了区分，s1,s2和ss1,ss2用了不同的名称，但有时候形参与实参的名字相同，其实两者变量是完全不同的，一个是main方法中的变量，一个是changeStringBuffer()中的变量。）</p>
<p>可以看出，在java中对象作为参数传递时，<strong>传递的是引用的地址，是把对象在内存中的地址拷贝了一份传给了参数</strong>。</p>
<h2 id="4-拓展"><a href="#4-拓展" class="headerlink" title="4. 拓展"></a>4. 拓展</h2><p>基本数据类型的包装类型在传递参数时其实也是“按引用传递的”，只是因为包装类型变量都是不可变量，容易误解。</p>
<p>String是final类型，是个特殊的类，对它的一些操作符是<strong>重载</strong>的。比如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>;<span class="comment">//等价于String str=new String("hello");</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">"world"</span>;<span class="comment">//等价于str = new String(new StringBuffer(str).append("world"));</span></span><br></pre></td></tr></table></figure>

<p>从以上分析，现在可以更易理解下面的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static void <span class="function"><span class="title">fun</span><span class="params">(String str, char ch[])</span></span> &#123;</span><br><span class="line">        str = <span class="string">"world"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'d'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        String str = new String(<span class="string">"hello"</span>);</span><br><span class="line">        char[] ch = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">        <span class="function"><span class="title">fun</span><span class="params">(str, ch)</span></span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(str);</span><br><span class="line">        System.<span class="keyword">out</span>.println(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">dbc</span><br></pre></td></tr></table></figure>

<p>方法调用时，名称相同的实参和形参并不一样，一个是main()中的str,指向存放”hello”的内存地址。一个是fun()中的str，str=”world”,相当于new String(“world”)。String是final类型，将在堆中重新分配一个内存空间存放”world”。ch[0]=’d’,对象的内容发生改变。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6133202-c0e7ac6f4a16d914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/398/format/webp" alt></p>
<p>image</p>
<p>所以main()中str变量存放的对象内容依然是”hello”。ch从”abc”变为”dbc”。</p>
<p><strong>参考</strong></p>
<ul>
<li><p><a href="https://link.jianshu.com?t=http%3A%2F%2Fdepp.wang%2F2017%2F07%2F26%2FString-Parameter-passing%2F" target="_blank" rel="noopener">String的参数传递</a></p>
</li>
<li><p><a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fqq_16633405%2Farticle%2Fdetails%2F52818487" target="_blank" rel="noopener">java基础中按值传递和引用传递详解</a></p>
</li>
<li><p><a href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fdove_knowledge%2Farticle%2Fdetails%2F71038511" target="_blank" rel="noopener">Java中的值传递与引用传递详解</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-9-12</title>
    <url>/2020/Java%E5%9F%BA%E7%A1%80-1-%E5%85%B3%E9%94%AE%E5%AD%97-3-Java%E5%9F%BA%E7%A1%80%EF%BC%9Athis%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>看了几篇关于this关键字的文章，感觉跟多人初学者对于this关键字的使用都是云里雾里，我觉得主要还是要结合代码来看吧。这样理解的更快一点。</p>
<h4 id="1-引用成员变量"><a href="#1-引用成员变量" class="headerlink" title="1. 引用成员变量"></a>1. 引用成员变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Public Class Student &#123;</span><br><span class="line">	String name; &#x2F;&#x2F;定义一个成员变量name</span><br><span class="line">	private void SetName(String name) &#123; &#x2F;&#x2F;定义一个参数(局部变量)name</span><br><span class="line">  		this.name&#x3D;name; &#x2F;&#x2F;将局部变量的值传递给成员变量</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this这个关键字代表的就是对象中的成员变量或者方法。也就是说，如果在某个变量前面加上一个this关键字，其指的就是这个对象的成员变量或者方法，而不是指成员方法的形式参数或者局部变量。</p>
<h4 id="2-调用类的构造方法"><a href="#2-调用类的构造方法" class="headerlink" title="2. 调用类的构造方法"></a>2. 调用类的构造方法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span> <span class="comment">//定义一个类，类的名字为student。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123; <span class="comment">//定义一个方法，名字与类相同故为构造方法</span></span><br><span class="line">  		<span class="keyword">this</span>(“Hello!”);</span><br><span class="line"> 	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123; <span class="comment">//定义一个带形式参数的构造方法</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于对构造方法的理解，原博写的非常清楚，有需要的小伙伴去原博看就好啦，地址在文章最后。</p>
<p>Student方法有两个构造方法，一个没有参数，一个有参数。<br>在第一个没有带参数的构造方法中，使用了this(“Hello!”)这句代码，这句代码表示使用this关键字调用类中的有一个参数的构造方法。</p>
<h4 id="3-返回对象的值"><a href="#3-返回对象的值" class="headerlink" title="3. 返回对象的值"></a>3. 返回对象的值</h4><p>this关键字除了可以引用变量或者构造方法之外，还有一个重大的作用就是返回类的引用。如在代码中，可以使用return this，来返回某个类的引用。此时这个this关键字就代表类的名称。</p>
<p>如代码在上面student类中使用return this，那么代码代表的含义就是return student。</p>
<p>可见，这个this关键字除了可以引用变量或者成员方法之外，还可以作为类的<strong>返回值</strong>，这才是this关键字最引人注意的地方。</p>
<p><strong>参考原文：</strong></p>
<ul>
<li><a href="https://www.jianshu.com/p/4469d5bbff7b" target="_blank" rel="noopener">https://www.jianshu.com/p/4469d5bbff7b</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-8-设计模式-桥接模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><p>桥接模式一共只有三个成员：</p>
<ul>
<li>抽象类（Abstraction）：<strong>抽象类</strong>维护一个实现部分的对象的引用，并声明调用实现部分的对象的接口。</li>
<li>扩展抽象类（RefinedAbstraction）：<strong>扩展抽象类</strong>定义跟实际业务相关的方法。</li>
<li>实现类接口（Implementor）：<strong>实现类接口</strong>定义实现部分的接口。</li>
<li>具体实现类（ConcreteImplementor）：<strong>具体实现类</strong>具体实现类是实现实现类接口的对象。</li>
</ul>
<p>下面通过类图来看一下各个成员之间的关系：</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-7-设计模式-适配器模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-7-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><strong>对象适配器模式</strong></p>
<p>在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。</p>
<p><strong>类适配器模式</strong></p>
<p>这种适配器模式下，适配器继承自已实现的类（一般多重继承）。</p>
<p>二者区别仅在于适配器角色对于被适配角色的适配是通过继承还是组合来实现的，由于Java中不支持多继承，而且类适配器模式有破坏封装之嫌，而且我们也提倡多用组合少用继承。<strong>所以本文主要介绍对象适配器。</strong></p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><p>适配器模式包含如下角色：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Target：目标抽象类</span><br><span class="line"></span><br><span class="line">Adapter：适配器类</span><br><span class="line"></span><br><span class="line">Adaptee：适配者类</span><br><span class="line"></span><br><span class="line"><span class="built_in">Client</span>：客户类</span><br></pre></td></tr></table></figure>

<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200402162956.jpg" alt></p>
<p>使用经典的适配器模式进行说明。</p>
<p><strong>情景</strong>：当我们使用充电时器充电式，通常有不同的不同的数据线，比如<code>MicroUsb</code>、<code>Lightning</code>和<code>TypeC</code>三种，现在需要一种适配模式，能够实现用<code>MicroUsb</code>来给iPhone充电。</p>
<h3 id="2-1-定义目标抽象类Target"><a href="#2-1-定义目标抽象类Target" class="headerlink" title="2.1 定义目标抽象类Target"></a>2.1 定义目标抽象类Target</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MicroUsb充电器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MicroUsbInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithMicroUsb</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lightning充电器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LightningInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-定义适配者类Adaptee"><a href="#2-2-定义适配者类Adaptee" class="headerlink" title="2.2 定义适配者类Adaptee"></a>2.2 定义适配者类Adaptee</h3><p>这里是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安卓设备的充电器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidCharger</span> <span class="keyword">implements</span> <span class="title">MicroUsbInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithMicroUsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用MicroUsb型号的充电器充电..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-定义适配器Adapter"><a href="#2-3-定义适配器Adapter" class="headerlink" title="2.3 定义适配器Adapter"></a>2.3 定义适配器Adapter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器,将MicroUsb接口转成Lightning接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">LightningInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MicroUsbInterface microUsbInterface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参和无参省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithLightning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        microUsbInterface.chargeWithMicroUsb();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// microUsbInterface的set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该适配器的功能是把一个MicroUsb转换成Lightning。实现方式是实现目标类的接口（<code>LightningInterface</code>），然后使用组合的方式，在该适配器中定义microUsb。然后在重写的<code>chargeWithLightning（）</code>方法中，采用microUsb的方法来实现具体细节。</p>
<h3 id="2-4-定义客户端Client"><a href="#2-4-定义客户端Client" class="headerlink" title="2.4 定义客户端Client"></a>2.4 定义客户端Client</h3><p>首先我们定义一个对象手机<code>Iphone6Plus</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone6Plus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LightningInterface lightningInterface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参和无参函数省略</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始给我的Iphone6Plus手机充电..."</span>);</span><br><span class="line">        lightningInterface.chargeWithLightning();</span><br><span class="line">        System.out.println(<span class="string">"结束给我的Iphone6Plus手机充电..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lightningInterface的set和get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义手机的作用是为了更方便的理解适配器模式，在该模式中他不扮演任何角色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 由于是使用的为适配器，所以传入的实际上还是AndroidCharge</span></span><br><span class="line">        Adapter adapter  = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> AndroidCharger());</span><br><span class="line">        Iphone6Plus newIphone = <span class="keyword">new</span> Iphone6Plus();</span><br><span class="line">        newIphone.setLightningInterface(adapter);</span><br><span class="line">        newIphone.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200402171623.jpg" alt></p>
<h2 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h2><p><strong>优点</strong></p>
<p>适配器模式（对象适配器模式），是一种组合优于集成的思想的实现。通过使用适配器模式，我们可以最大程度的复用已有的了类和代码。他主要有以下有点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<p><strong>缺点</strong></p>
<p>当然，适配器模式并不是完美的，过度使用还是会带来一些问题的。缺点如下：</p>
<ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</p>
<p>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<p>适配器模式包含四个角色：</p>
<blockquote>
<p>目标抽象类定义客户要用的特定领域的接口；</p>
<p>适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；</p>
<p>适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；</p>
<p>在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</p>
</blockquote>
<p>在对象适配器模式中，适配器类继承了目标抽象类(或实现接口)并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</p>
<p>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</p>
<p>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</p>
<p>参考资料</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/E9qNhO0fpk4md1ERK7Ix_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/E9qNhO0fpk4md1ERK7Ix_A</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>设计模式-6-设计模式-单例模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><h2 id="2-具体分析"><a href="#2-具体分析" class="headerlink" title="2. 具体分析"></a>2. 具体分析</h2><p>现在我们需要设计一个单实例的应用。可以按照下面三步进行：</p>
<p>第一、<strong>把自己的构造方法设置为private的</strong>，不让别人new你的实例；</p>
<p>第二、<strong>在类的内部创建实例</strong>。</p>
<p>第三、<strong>提供一个static方法给别人获取你的实例</strong>，你在这个方法里面返回你自己创建的实例就行”。</p>
<h3 id="2-1-饿汉式"><a href="#2-1-饿汉式" class="headerlink" title="2.1 饿汉式"></a>2.1 饿汉式</h3><p>根据上面的步骤，我们就可以轻松完成创建单例对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java3y</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.将构造函数私有化，不可以通过new的方式来创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Java3y</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.在类的内部创建自行实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Java3y java3y = <span class="keyword">new</span> Java3y();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供获取唯一实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getJava3y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java3y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们可以发现，当加载的类<code>Java3y</code>后就立马创建了实例。<strong>如果该实例从始至终都没被使用过，则会造成内存浪费</strong>。这种代码我们称之为：“<strong>饿汉式</strong>”。</p>
<h3 id="2-2-简单懒汉式"><a href="#2-2-简单懒汉式" class="headerlink" title="2.2 简单懒汉式"></a>2.2 简单懒汉式</h3><p>既然说一上来就创建对象，如果没有用过会造成内存浪费：</p>
<ul>
<li>那么我们就设计<strong>用到的时候再创建对象</strong>！</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIO</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.将构造函数私有化，不可以通过new的方式来创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileIO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1先不创建对象，等用到的时候再创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">FileIO</span> <span class="built_in">FileIO</span> = null;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1调用到这个方法了，证明是要被用到的了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">FileIO</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果这个对象引用为null，我们就创建并返回出去</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">FileIO</span> == null) &#123;</span><br><span class="line">            <span class="built_in">FileIO</span> = <span class="keyword">new</span> <span class="built_in">FileIO</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FileIO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的简单懒汉式线程不安全，如果存在两个线程</p>
<blockquote>
<p>线程1：FileIO.getInstance()</p>
<p>（FileIO：判断FileIO为null，所以进行fileIO实例的初始化）</p>
<p>线程1：FileIO.getInstance()</p>
<p>（FileIO：还没初始化完，依然为null, 于是进行另外一个fileIO实例的初始化）</p>
</blockquote>
<p>等到两个线程都返回的时候，其实是创建了两个FileIO的实例。</p>
<p><strong>改进：</strong></p>
<p>我们可能会想到加一把锁来解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.将构造函数私有化，不可以通过new的方式来创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileIO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1先不创建对象，等用到的时候再创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileIO FileIO = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1调用到这个方法了，证明是要被用到的了</span></span><br><span class="line">    <span class="comment">// 增加一把锁 synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> FileIO <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 如果这个对象引用为null，我们就创建并返回出去</span></span><br><span class="line">        <span class="keyword">if</span> (FileIO == <span class="keyword">null</span>) &#123;</span><br><span class="line">            FileIO = <span class="keyword">new</span> FileIO();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FileIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，当有两个线程同时执行getInstance()方法的时候，<strong>一旦线程一获取到FileIO.class锁，线程二只能在外面等待着</strong>。</p>
<p>在线程一执行完getInstance()的逻辑后释放FileIO.class锁，其他线程才能获取这个锁进入getInstance()方法中。</p>
<p>这样就避免了创建两个FileIO的实例。</p>
<h3 id="2-3-双重检测机制-DCL-懒汉式"><a href="#2-3-双重检测机制-DCL-懒汉式" class="headerlink" title="2.3 双重检测机制(DCL)懒汉式"></a>2.3 双重检测机制(DCL)懒汉式</h3><p>这种方式实际上是对上面的优化。因为我们想想，如果<code>fileIO</code>实例不为空时，还需要使用synchronized来限制执行时只能一个线程进入吗? 所以进行下面的修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.将构造函数私有化，不可以通过new的方式来创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileIO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1先不创建对象，等用到的时候再创建</span></span><br><span class="line">    <span class="comment">// 增加关键字voiatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> voiatile FileIO FileIO = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1调用到这个方法了，证明是要被用到的了</span></span><br><span class="line">    <span class="comment">// 增加一把锁 synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileIO <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先判断一遍</span></span><br><span class="line">        <span class="keyword">if</span> (fileIO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(FileIO<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                 <span class="comment">// 3. 如果这个对象引用为null，我们就创建并返回出去</span></span><br><span class="line">                <span class="keyword">if</span> (FileIO == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    FileIO = <span class="keyword">new</span> FileIO();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> FileIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的模式也称为<strong>双重检验锁</strong>。</p>
<p>“老司机就是复杂，好端端的，被你弄了那么多个fileIO == null的判断，还用volatile关键字修饰fileIO，这样真的能提升性能吗？”</p>
<p>“you look，当有多有线程调用getInstance()方法的时候，不管三七二十一，先让他们进来。如果fileIO实例不为空，那最好了，直接return实例fileIO，跟synchronized一点都扯不上关系，所以也不会影响到性能。这是双重检验中的第一次检验。”</p>
<p>“oh，I know，如果fileIO是null的，就进入synchronized语句块，在synchronized语句块里面初始化对象。但为什么在synchronized语句中需要再次检查fileIO实例是否为null？”</p>
<p>“这就是第二次检验了，当有多个线程通过第一次检验时，假设线程拿到锁进入synchronized语句块，对fileIO实例进行初始化，释放FileIO.class锁之后，线程二持有这个锁进入synchronized语句块，此时又对fileIO对象就行初始化。所以在这里进行第二次检验防止这种意外发生。”</p>
<p>“我理解了，但我不明白fileIO为什么要用volatile关键字修饰？”</p>
<p>“我们假设线程一进入第二次检验之后就执行FileIO fileIO = new FIleIO()操作，在这个操作中，JVM主要干了三件事</p>
<p>1、在堆空间里分配一部分空间；</p>
<p>2、执行FileIO的构造方法进行初始化；</p>
<p>3、把fileIO对象指向在堆空间里分配好的空间。</p>
<p>但是，当我们编译的时候，编译器在生成汇编代码的时候会对流程顺序进行优化。优化的结果是有可能按照1-2-3顺序执行，也可能按照1-3-2顺序执行。</p>
<p>我们知道，执行完3的时候就fileIO对象就已经不为空了，如果是按照1-3-2的顺序执行，恰巧在执行到3的时候（还没执行2），突然跑来了一个线程，进来getInstance()方法之后判断fileIO不为空就返回了fileIO实例。</p>
<p>此时fileIO实例虽不为空，但它还没执行构造方法进行初始化。又恰巧构造方法里面需要对某些参数进行初始化。后来闯进来的线程糊里糊涂对那些需要初始化的参数进行操作就有可能报错奔溃了。”</p>
<h3 id="2-4-静态内部类懒汉式"><a href="#2-4-静态内部类懒汉式" class="headerlink" title="2.4 静态内部类懒汉式"></a>2.4 静态内部类懒汉式</h3><p>首先我们通过一个例子再看看”饿汉式”的弊端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_MP3=<span class="string">".mp3"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FileIO INSTANCE = <span class="keyword">new</span> FileIO();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileIO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileIO <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们不想获取<code>FileIO</code>的实例而是想获取其中一个全局变量<code>TYPE_MP3</code>的时候，在类加载的时候还是会对<code>INSTANCE</code>实例也会被初始化，导致时间比较久，这显然不是我们需要的。</p>
<p>因此可以使用<strong>静态内部类这种巧妙的方式</strong>来实现单例模式！它的原理是这样的：</p>
<ul>
<li>当任何一个线程<strong>第一次调用</strong><code>getInstance()</code>时，都会使SingletonHolder被加载和被初始化，此时静态初始化器将执行Singleton的初始化操作。(<strong>被调用时才进行初始化</strong>！)</li>
<li><strong>初始化静态数据时，Java提供了的线程安全性保证</strong>。(所以不需要任何的同步)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIO</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_MP3=<span class="string">".mp3"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FileIO FileIOHolder &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FileIO INSTANCE = <span class="keyword">new</span> FileIO();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileIO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileIO <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行<code>getInstance()</code>方法的时候就去调用<code>FileIOHolder</code>内部类里面的<code>INSTANCE</code>实例，此时<code>FileIOHolder</code>内部类会被加载到内存里，在类加载的时候就对INSTANCE实例进行初始化。和饿汉式一个道理，保证了只有一个实例，而且在调用<code>getInstance()</code>方法的时候才进行<code>INSTANCE</code>实例的初始化，又具有懒汉式的部分特性。</p>
<h3 id="2-5枚举方式实现"><a href="#2-5枚举方式实现" class="headerlink" title="2.5枚举方式实现"></a>2.5枚举方式实现</h3><p>虽然单例看起来简单， 但是要弄一个完美的单例模式还是比较麻烦的！但是使用枚举就非常简单了：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">FileIO</span> &#123;</span></span><br><span class="line">	INSTANCE;</span><br><span class="line">	/<span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">	public FieopenFile(String fileName)&#123;</span></span><br><span class="line"><span class="regexp">		return getFile(fileName);</span></span><br><span class="line"><span class="regexp">	&#125;	</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在是枚举类型，但实际上反编译可知枚举实际上就是一个继承Enum的类。所以你的本质还是一个类，因为枚举的特点，你只会有一个实例，同时保证了线程安全、反射安全和反序列化安全。</p>
<p>那这种有啥好处？？枚举的方式实现：</p>
<ul>
<li>简单，直接写就行了</li>
<li><strong>防止多次实例化</strong>，即使是在面对复杂的序列化或者反射攻击的时候(安全)！</li>
</ul>
<p>这种也较为推荐使用！</p>
<h2 id="3-单例模式的破坏"><a href="#3-单例模式的破坏" class="headerlink" title="3. 单例模式的破坏"></a>3. 单例模式的破坏</h2><p>黑客通常会通过下面两种方式破坏单例模式。</p>
<p><strong>方法1：</strong>反射调用构造方法初始化新的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileIO fileIO = FileIO<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>对于通过反射调用构造方法的破坏方式我们可以通过在增加全局变量flag，在第一次初始化的时候就设置为true，第二次初始化的时候判断到flag为true就抛出异常。但这种办法也只能避免破坏，无法彻底阻止，因为他们可以反射flag来修改flag的值。</p>
<p>方法2：序列化和反序列化产生新的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把单例写入到文件中</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件，形成新的FileIO对象</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">FileIO fileIO = (FileIO)ois.readObject();</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p>对于使用序列化和反序列化产生新的实例的方式就容易避免了，可以增加readResolve()方法来预防。我们使用静态内部类的方式来演示如何避免：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIO</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIOHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> INSTANCE = <span class="keyword">new</span> FileIO();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FileIO</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileIO <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileIOHolder.INSATNCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileIOHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么增加readResolve()方法并在里面返回之前创建好的实例就可以避免被反序列破坏呢？</p>
<p>这是反序列化机制决定的， 在反序列化的时候会判断如果实现了serializable 或者 externalizable接口的类中又包含readResolve()方法的话，会直接调用readResolve()方法来获取实例。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-5-设计模式-建造者模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在学习建造模式时，前先阅读这篇文章<a href="https://mp.weixin.qq.com/s/pypLqXd8puRy_3lbMhJvew" target="_blank" rel="noopener">Java 帝国之建造者模式</a>对建造者模式写得很形象，十分推荐。后面案例中对这篇文章的内容进行了简化。</p>
<h2 id="2-模式定义"><a href="#2-模式定义" class="headerlink" title="2. 模式定义"></a>2. 模式定义</h2><p>造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p>
<h2 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h2><p>建造者模式包含如下角色：</p>
<ul>
<li>Builder：抽象建造者</li>
<li>ConcreteBuilder：具体建造者</li>
<li>Director：指挥者</li>
<li>Product：产品角色</li>
</ul>
<p>结构图如下：</p>
<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200401223102.png" alt></p>
<h2 id="4-案例"><a href="#4-案例" class="headerlink" title="4. 案例"></a>4. 案例</h2><p>（1）需求</p>
<p>假设存在一个客户，需要设计一个正方形。由于你的设计水平十分高超，因此越来越多的人找你设计正方形</p>
<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200401223709.jpg" alt></p>
<p>各种正方形都不一样，因此需要设计一个结构。</p>
<p>（2）基本设计</p>
<p>用户需要什么样的图形，只需要把对应的属性（长、宽、颜色…）告诉我就行…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> color)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> color, <span class="keyword">int</span> borderColor)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> color, <span class="keyword">int</span> borderColor, <span class="keyword">float</span> radius)</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> color, <span class="keyword">int</span> borderColor, <span class="keyword">float</span> radius, <span class="keyword">float</span> strokeDashGap)</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> color, <span class="keyword">int</span> borderColor, <span class="keyword">float</span> radius, <span class="keyword">float</span> strokeDashGap, <span class="keyword">float</span> shadow)</span> </span>&#123; ... &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为此，一个Square的构造函数， 我整整重载了99次！<strong>缺点：</strong><span style="color:red">重载的次数太多，不仅复杂，而且使用不方便。</span></p>
<p>（3）改进——使用set方法</p>
<p>修改上面的<code>Square</code>类，使用set方法，让使用者只有调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;...&#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;...&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPadding</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;...&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户只需要进行下面的操作即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Square square = <span class="keyword">new</span> Square();</span><br><span class="line">square.setColor(Color.Blue);</span><br><span class="line">square.setBorderSize(<span class="number">5</span>);</span><br><span class="line">square.setBorderColor(Color.Black);</span><br></pre></td></tr></table></figure>

<p><strong>不足：</strong><span style="color:red">但是存在一种情况，就是某个属性依赖另外一个属性的情况。如果在创建该对象时，只赋值了其中一个，那么创建对象将会产生错误。</span></p>
<p>（4）改进——静态内部类专门用来与外界打交道</p>
<p>开放一个静态内部类专门用来与外界打交道，来收集用户想要设置的参数并且做检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> color;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> borderSize;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">//private，让外面无法直接创建</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Square</span><span class="params">(Builder builder)</span> </span>&#123;    </span><br><span class="line">		<span class="keyword">this</span>.color = builder.color;</span><br><span class="line">		<span class="keyword">this</span>.borderSize = builder.borderSize;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> color;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> borderSize;</span><br><span class="line">		......</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; &#125;    <span class="comment">//边框大小</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123; &#125;    <span class="comment">//边框颜色</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPadding</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123; &#125;</span><br><span class="line">		...</span><br><span class="line">            </span><br><span class="line">		<span class="function"><span class="keyword">public</span> Square <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">//检查参数之间的关系是否设置正确...</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Square(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是便可以进行如下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Square.Builder builder = <span class="keyword">new</span> Square.Builder();</span><br><span class="line">builder.setSize(<span class="number">50</span>);</span><br><span class="line">builder.setColor(Color.Blue);</span><br><span class="line">builder.setBorderSize(<span class="number">5</span>);</span><br><span class="line">builder.setBorderColor(Color.Black); </span><br><span class="line"><span class="comment">//在build方法中会检查参数是否正确。</span></span><br><span class="line">Square square = builder.build();</span><br></pre></td></tr></table></figure>

<p>可是这个调用方式可是比我之前提供的API复杂得多呀！如果旧的API，只用一行代码就可以可以了！</p>
<p>（5）改进——增加链式调用</p>
<p>如果将静态内部类set方法的返回值由之前的<code>void</code>更改为<code>Builder</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setBorderSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setBorderColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setPadding</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Square <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...检查参数之间的关系是否设置正确...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时就可以进行如下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Square square = <span class="keyword">new</span> Square.Builder()</span><br><span class="line">	.setSize(<span class="number">50</span>)</span><br><span class="line">	.setColor(Color.Blue)</span><br><span class="line">	.setBorderSize(<span class="number">5</span>)</span><br><span class="line">	.setBorderColor(Color.Black)</span><br><span class="line">	.build();</span><br></pre></td></tr></table></figure>

<p>获取会发现，上述代码并没有按照上面建造者模式创建，那是因为进行了部分简化。</p>
<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200401225952.png" alt></p>
<p>其中的clinet（等同于Director：指挥者），Builder的接口省略了，其他都一样。</p>
<h2 id="5-优缺点分析"><a href="#5-优缺点分析" class="headerlink" title="5. 优缺点分析"></a>5. 优缺点分析</h2><p><strong>优点：</strong></p>
<ul>
<li>在建造者模式中， <strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</strong></li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong> 。</li>
<li><strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<h2 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. 使用场景</h2><p>在以下情况下可以使用建造者模式：</p>
<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ul>
<li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li>
<li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li>
<li>在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li>
<li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
<li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li>
</ul>
<p>参考资料</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/pypLqXd8puRy_3lbMhJvew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pypLqXd8puRy_3lbMhJvew</a></li>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html#id10" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html#id10</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>设计模式-4-设计模式-三种工厂模式比较</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><strong>简单工厂模式的优缺点</strong></p>
<ul>
<li><p>优点：</p>
</li>
<li><ul>
<li>1、屏蔽产品的具体实现，调用者只关心产品的接口。</li>
<li>2、实现简单</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>1、增加产品，需要修改工厂类，不符合开放-封闭原则</li>
<li>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</li>
</ul>
</li>
</ul>
<p><strong>工厂方法模式的优缺点</strong></p>
<ul>
<li><p>优点：</p>
</li>
<li><ul>
<li>1、继承了简单工厂模式的优点</li>
<li>2、符合开放-封闭原则</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
<li><ul>
<li>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<p><strong>抽象工厂模式的优缺点</strong></p>
<ul>
<li><p>优点：</p>
</li>
<li><ul>
<li>1、隔离了具体类的生成，使得客户并不需要知道什么被创建</li>
<li>2、每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；</li>
</ul>
</li>
<li><p>缺点</p>
</li>
<li><ul>
<li>增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
</ul>
</li>
</ul>
<p><strong>三种工厂模式的对比与转换</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5Iic7OatjvZftDTDlfaVDXMy48AJ5BibhZbKcL3h5icJhicpnsvsGibLJbqyr7fv2Vx7XtjDwNTQv2icqeA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，主要是新增产品，就要修改工厂类。符合单一职责原则。不符合开放-封闭原则）</p>
<p>工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品，新增产品时不需要更改已有的工厂，需要增加该产品对应的工厂。符合单一职责原则、符合开放-封闭原则。但是引入了复杂性）</p>
<p>抽象工厂 ：用来生产不同产品族的全部产品。（增加新产品时，需要修改工厂，增加产品族时，需要增加工厂。符合单一职责原则，部分符合开放-封闭原则，降低了复杂性）</p>
<p>最后，三种工厂模式各有优缺点，没有最好的，只有最合适的！</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-3-设计模式-抽象工厂模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-为什么要抽象工厂模式"><a href="#1-为什么要抽象工厂模式" class="headerlink" title="1. 为什么要抽象工厂模式"></a>1. 为什么要抽象工厂模式</h2><p>我们首先不妨回忆下前面学习的两种工厂模式：简单工厂模式、工厂方法模式</p>
<p><strong>简单工厂模式优缺点</strong>：</p>
<blockquote>
<p><strong>优点：</strong></p>
<p>1、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>2、实现简单</p>
<p><strong>缺点：</strong></p>
<p>1、增加产品，需要修改工厂类，不符合开放-封闭原则</p>
<p>2、工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则</p>
</blockquote>
<p><strong>工厂方法模式优缺点</strong>：</p>
<blockquote>
<p><strong>优点：</strong></p>
<p>1、继承了简单工厂模式的优点</p>
<p>2、符合开放-封闭原则</p>
<p><strong>缺点：</strong></p>
<p>1、增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
</blockquote>
<p>而抽象工厂模式是上面两种模式的延伸，我们需要学习。</p>
<h2 id="2-什么是抽象工厂模式？"><a href="#2-什么是抽象工厂模式？" class="headerlink" title="2. 什么是抽象工厂模式？"></a>2. 什么是抽象工厂模式？</h2><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。</p>
<p><strong>产品族</strong></p>
<p>来认识下什么是产品族: 位于不同产品等级结构中,功能相关的产品组成的家族。如下面的例子，就有两个产品族：跑车族和商务车族。</p>
<p>关系图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5Iic7OatjvZftDTDlfaVDXMy4eBhBniabicYsaeIpcNicWNa7JWEj219iasbXzbF2M71PqPdQE2OzZO1Mg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<h2 id="3-用途"><a href="#3-用途" class="headerlink" title="3. 用途"></a>3. 用途</h2><p>抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，<span style="color:red;font-weight:solid">工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂</span>。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。</p>
<p>在以下情况下可以使用抽象工厂模式：</p>
<ul>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li>
<li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
<h2 id="4-案例"><a href="#4-案例" class="headerlink" title="4. 案例"></a>4. 案例</h2><h3 id="4-1-抽象工厂模式实现方式"><a href="#4-1-抽象工厂模式实现方式" class="headerlink" title="4.1 抽象工厂模式实现方式"></a>4.1 抽象工厂模式实现方式</h3><p>抽象工厂模式包含如下角色：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">AbstractFactory</span><span class="params">(抽象工厂)</span></span>：用于声明生成抽象产品的方法</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">ConcreteFactory</span><span class="params">(具体工厂)</span></span>：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">AbstractProduct</span><span class="params">(抽象产品)</span></span>：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">Product</span><span class="params">(具体产品)</span></span>：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</span><br></pre></td></tr></table></figure>



<h3 id="4-2-实例"><a href="#4-2-实例" class="headerlink" title="4.2 实例"></a>4.2 实例</h3><p>本文的例子采用一个汽车代工厂造汽车的例子。假设我们是一家汽车代工厂商，我们负责给奔驰和特斯拉两家公司制造车子。</p>
<p>我们简单的把奔驰车理解为需要加油的车，特斯拉为需要充电的车。其中奔驰车中包含跑车和商务车两种，特斯拉同样也包含奔驰车和商务车。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5Iic7OatjvZftDTDlfaVDXMy3BL1uibhzMcQ4KtCyqicK5xW4rTnibibRt5GXR2TBic1x1Dl19y8qfrse2Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>以上场景，我们就可以把跑车和商务车分别对待，对于跑车有单独的工厂创建，商务车也有单独的工厂。</p>
<p>这样，以后无论是再帮任何其他厂商造车，只要是跑车或者商务车我们都不需要再引入工厂。同样，如果我们要增加一种其他类型的车，比如越野车，我们也不需要对跑车或者商务车的任何东西做修改。</p>
<p>下面是抽象产品，奔驰车和特斯拉车：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BenzCar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加汽油</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gasUp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TeslaCar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是具体产品，奔驰跑车、奔驰商务车、特斯拉跑车、特斯拉商务车：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzSportCar</span> <span class="keyword">implements</span> <span class="title">BenzCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gasUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给我的奔驰跑车加最好的汽油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzBusinessCar</span> <span class="keyword">implements</span> <span class="title">BenzCar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gasUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给我的奔驰商务车加一般的汽油"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaSportCar</span> <span class="keyword">implements</span> <span class="title">TeslaCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给我特斯拉跑车冲满电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeslaBusinessCar</span> <span class="keyword">implements</span> <span class="title">TeslaCar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"不用给我特斯拉商务车冲满电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BenzCar <span class="title">getBenzCar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TeslaCar <span class="title">getTeslaCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SportCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BenzCar <span class="title">getBenzCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BenzSportCar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TeslaCar <span class="title">getTeslaCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TeslaSportCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BenzCar <span class="title">getBenzCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BenzBusinessCar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TeslaCar <span class="title">getTeslaCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TeslaBusinessCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>“开闭原则”的倾斜性</strong></p>
<p>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p>
<ul>
<li>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</li>
<li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。（感觉是增加新的方式，假设存在油电混合、烧汽等，就需要修改抽象工厂以及具体工厂）</li>
</ul>
<p><span style="color:red">抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</span></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。</p>
<p><span style="color:red">抽象工厂模式的主要<strong>优点</strong>是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要<strong>缺点</strong>在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</span></p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-2-设计模式-工厂方法模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-为什么需要工厂方法模式"><a href="#1-为什么需要工厂方法模式" class="headerlink" title="1. 为什么需要工厂方法模式"></a>1. 为什么需要工厂方法模式</h2><p>在前面我们学习简单工厂模式时，发现简单工厂模式破坏了<span style="color:red">开放-封闭原则</span>（当我们需要增加一种计算时，需要先继承抽象类并且还需要在工厂类中添加一个case）。而本文将介绍一种新的模式——工厂方法模式</p>
<h2 id="2-什么是工厂方法模式"><a href="#2-什么是工厂方法模式" class="headerlink" title="2. 什么是工厂方法模式"></a>2. 什么是工厂方法模式</h2><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于<strong>类创建型模式</strong>。<span style="text-decoration:underline">在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象</span>，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<h2 id="3-用途"><a href="#3-用途" class="headerlink" title="3. 用途"></a>3. 用途</h2><p><strong>工厂方法模式在设计上完全完全符合“开闭原则”。</strong>下面是其使用情况</p>
<ul>
<li><p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p>
</li>
<li><p>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p>
</li>
<li><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p>
</li>
</ul>
<h2 id="4-案例"><a href="#4-案例" class="headerlink" title="4. 案例"></a>4. 案例</h2><p>工厂方法模式包含如下角色：</p>
<ul>
<li>Product：抽象产品（<code>Operation</code>）</li>
<li>ConcreteProduct：具体产品(<code>OperationAdd</code>)</li>
<li>Factory：抽象工厂(<code>IFactory</code>)</li>
<li>ConcreteFactory：具体工厂(<code>AddFactory</code>)</li>
</ul>
<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200401205734.jpg" alt></p>
<p>这里的抽象产品（<code>Operation</code>）和具体产品（<code>OperationAdd</code>、<code>OperationDiv</code>、<code>OperationSub</code>、<code>OperationMul</code>等方法保持不变），去掉之前的的工厂类<code>OperationFactory</code>。 创建如下的抽象工厂和具体工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Operation <span class="title">CreateOption</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法类工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operation <span class="title">CreateOption</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在客户端中想要执行加法运算时，需要以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> AddFactory();</span><br><span class="line">        Operation operationAdd =  factory.CreateOption();</span><br><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span><br><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span><br><span class="line">        System.out.println(operationAdd.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，一个工厂方法模式就已经写好了。</p>
<h2 id="5-模式优缺点"><a href="#5-模式优缺点" class="headerlink" title="5. 模式优缺点"></a>5. 模式优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li><strong>封装了对象创建的内部细节</strong>；基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。<strong>它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。</strong>工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>符合<span style="color:red">开放-封闭原则</span>。在前面学习简单工厂模式，可以发现如果增加新的方法，需要对工厂类进行修改。而使用该模式可以进一步解耦代码。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>需要添加的新的具体产品类和具体工厂类</strong>，代码复杂度变高。</li>
<li>增加了抽象层，增加了系统实现难度。</li>
</ul>
<h2 id="6-JDK中的工厂方法模式"><a href="#6-JDK中的工厂方法模式" class="headerlink" title="6. JDK中的工厂方法模式"></a>6. JDK中的工厂方法模式</h2><p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200401212556.jpg" alt></p>
<p>使用不同的具体工厂类中的<code>iterator</code>方法能得到不同的具体产品的实例。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>工厂方法模式是简单工厂模式的进一步抽象和推广。</p>
<p>由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<p>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式-1-设计模式-简单工厂模式</title>
    <url>/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1-为什么需要简单工厂模式"><a href="#1-为什么需要简单工厂模式" class="headerlink" title="1. 为什么需要简单工厂模式"></a>1. 为什么需要简单工厂模式</h2><p>场景：假设需要设计一个计算器，我们只希望能够输入运算符和具体数字，就能得到运行结果，不需要知道内部的具体细节，最后返回运算结果即可。那么可以考虑的设计模式——<strong>简单工厂模式</strong>。</p>
<h2 id="2-什么是简单工厂模式"><a href="#2-什么是简单工厂模式" class="headerlink" title="2. 什么是简单工厂模式"></a>2. 什么是简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于<strong>类创建型模式</strong>。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><h3 id="3-1-基础设计"><a href="#3-1-基础设计" class="headerlink" title="3.1 基础设计"></a>3.1 基础设计</h3><p>在介绍简单工厂模式之前，我们尝试解决以下问题：</p>
<p>现在我们要使用面向对象的形式定义计算器，为了实现各算法之间的解耦。主要的用到的类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算类的基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> value1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> value2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue1</span><span class="params">(<span class="keyword">double</span> value1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value1 = value1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue2</span><span class="params">(<span class="keyword">double</span> value2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value2 = value2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getResule</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getResule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getValue1() + getValue2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getResule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getValue1() - getValue2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getResule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getValue1() * getValue2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> <span class="keyword">extends</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getResule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getValue2() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getValue1() / getValue2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"除数不能为零"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我想要执行加法运算时，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OperationAdd operationAdd = <span class="keyword">new</span> OperationAdd();</span><br><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span><br><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span><br><span class="line">        System.out.println(operationAdd.getResule());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面当我们需要进行<code>&quot;+&quot;</code>运算时，只需要创建一个<code>OperationAdd</code>对象；同理需要进行<code>&quot;-&quot;</code>运算时，只需要创建一个<code>OperationSub</code>对象。</p>
<h3 id="3-2-优点"><a href="#3-2-优点" class="headerlink" title="3.2 优点"></a>3.2 优点</h3><ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<p>但是上面还是存在问题，那就是必须知道类的名称，能够改进呢？那就需要引入工厂类了。</p>
<h3 id="3-3-改进"><a href="#3-3-改进" class="headerlink" title="3.3 改进"></a>3.3 改进</h3><p>首先看看简单工厂模式的组成：</p>
<blockquote>
<p>1) <span style="color:red;font-weight:bold">工厂类角色</span>：这是本模式的核心,含有一定的商业逻辑和判断逻辑。在java中它往往由 一个具体类实现。（OperationFactory）</p>
<p>2) <span style="color:red;font-weight:bold">抽象产品角色</span>：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）</p>
<p>3) <span style="color:red;font-weight:bold">具体产品角色</span>：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 来用类图来清晰的表示下的它们之间的关系（OperationAdd\OperationSub等）</p>
</blockquote>
<p><img src="../../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20200401172207.jpg" alt></p>
<p>在原有类的基础上，定义工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">createOperation</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line">        Operation oper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationAdd();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationSub();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationMul();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                oper = <span class="keyword">new</span> OperationDiv();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持该操作"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了工厂类之后，可以使用工厂创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单工厂方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OperationAdd operationAdd = <span class="keyword">new</span> OperationAdd();</span><br><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span><br><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span><br><span class="line">        System.out.println(operationAdd.getResule());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个工厂类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun2</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Operation operationAdd = OperationFactory.createOperation(<span class="string">"+"</span>);</span><br><span class="line">        operationAdd.setValue1(<span class="number">10</span>);</span><br><span class="line">        operationAdd.setValue2(<span class="number">5</span>);</span><br><span class="line">        System.out.println(operationAdd.getResule());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过简单工厂模式，该计算器的使用者不需要关系实现加法逻辑的那个类的具体名字，他只要知道该类对应的参数”+”就可以了。</p>
<h3 id="3-4-缺点"><a href="#3-4-缺点" class="headerlink" title="3.4 缺点"></a>3.4 缺点</h3><p>下面我们从开闭原则(对扩展开放;对修改封闭)上来分析下简单工厂模式。当我们需要增加一种计算时，例如开平方。这个时候我们需要先定义一个类继承<code>Operation</code>类，其中实现平方的代码。除此之外我们还要修改<code>OperationFactory</code>类的代码，增加一个case。这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>工厂类是整个简单工厂模式的关键。包含了必要的逻辑判断，根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过使用工厂类，外界可以从直接创建具体产品对象的尴尬局面摆脱出来，仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的。明确了各自的职责和权利，有利于整个软件体系结构的优化。</p>
<p>但是</p>
<p>由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。</p>
<p>当系统中的具体产品类不断增多时候，可能会出现要求工厂类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系统的维护和扩展非常不利；</p>
<p>参考资料</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/-HV0Be8NJiGZA6H9bE6n_w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-HV0Be8NJiGZA6H9bE6n_w</a></li>
<li>《大话设计模式》</li>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html" target="_blank" rel="noopener">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot-4-SpringBoot基础4-SpringApplication运行阶段原理分析</title>
    <url>/2020/SpringBoot-4-SpringBoot%E5%9F%BA%E7%A1%804-SpringApplication%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在前面的学习中，我们<code>run</code>方法的前面一段，依也就是<code>SpringApplication</code>的准备阶段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在准备阶段主要的内容：</p>
<ul>
<li>推断web应用的类型</li>
<li>加载应用上下文初始器ApplicationContextInitializer</li>
<li>加载应用事件监听器ApplicationListener</li>
<li>推断应用引导类</li>
</ul>
<p>现在分析一下<code>run(args)</code>方法中发生了什么？</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是 Spring 的一个计时器，计算代码的执行时间(ms级别)</span></span><br><span class="line">		StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">		stopWatch.start();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 这俩变量在后面赋值处进行说明</span></span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">		Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 用来设置java.awt.headless属性值</span></span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 该对象属于组合模式的实现，核心是内部关联的 SpringApplicationRunListener 集合，SpringApplicationRunListener 是 Spring Boot 的运行时监听器</span></span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 会在不同的阶段调用对应的方法，这里表示启动run方法被调用</span></span><br><span class="line">        listeners.starting();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 用来获取 SpringApplication.run(args)传入的参数</span></span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">					args);</span><br><span class="line">            <span class="comment">// 获取 properties 配置文件</span></span><br><span class="line">			ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">					applicationArguments);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 设置 spring.beaninfo.ignore 的属性值，判断是否跳过搜索BeanInfo类</span></span><br><span class="line">            configureIgnoreBeanInfo(environment);</span><br><span class="line">			Banner printedBanner = printBanner(environment);</span><br><span class="line">			context = createApplicationContext();</span><br><span class="line">			exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">					SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">					new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">			prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">					printedBanner);</span><br><span class="line">			refreshContext(context);</span><br><span class="line">			afterRefresh(context, applicationArguments);</span><br><span class="line">			stopWatch.stop();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">				<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">						.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">			&#125;</span><br><span class="line">			listeners.started(context);</span><br><span class="line">			callRunners(context, applicationArguments);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			listeners.running(context);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> context;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-3-SpringBoot基础3-SpringApplication准备阶段原理分析</title>
    <url>/2020/SpringBoot-3-SpringBoot%E5%9F%BA%E7%A1%803-SpringApplication%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>前面我们学习了SpringBoot的自动配置原理，但是在一个主配置类中还存在一个SpringApplication类，这是什么呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplication1<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带着上面的问题，我们对其源码进行讨论。</p>
<h2 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h2><p>其中对于<code>run</code>方法，我们通过其源码进一步分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数对应的就是DemoApplication.class以及main方法中的args</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource,String... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终运行的是这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources,String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到， 通过入参 <code>primarySources</code> 构造 <code>SpringApplication</code> 类，然后在调用 run 方法，其中，准备阶段的工作皆在 <code>SpringApplication</code> 的构造器中处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际调用的是下面分构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个是实际调用的方法</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// resourceLoader 主要用来获取 Resource 及 ClassLoader。这里值为 null</span></span><br><span class="line">		<span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">		<span class="comment">// 断言主要加载资源类不能为 null，否则报错</span></span><br><span class="line">        Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">        <span class="comment">// primarySources是SpringApplication.run的参数，存放的是主配置类</span></span><br><span class="line">		<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">        <span class="comment">// 进行Web应用的类型推断</span></span><br><span class="line">		<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">		<span class="comment">// 加载应用上下文初始化器 initializer</span></span><br><span class="line">        setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">				ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">		<span class="comment">// 加载应用事件监听器 listener</span></span><br><span class="line">        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="comment">// 推断引导类，也就是找到入口类</span></span><br><span class="line">		<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，对构造器中的重点部分进行详细说明。</p>
<h3 id="2-1-推断-Web-应用类型"><a href="#2-1-推断-Web-应用类型" class="headerlink" title="2.1 推断 Web 应用类型"></a>2.1 推断 Web 应用类型</h3><p><code>SpringApplication</code>允许指定应用的类型，大体上包括Web应用和非Web应用。从 Spring Boot 2.0开始，Web应用又可分<code>为Servlet Web</code>和<code>Reactive Web</code>。而在准备阶段，是通过检查当前<code>ClassPath</code>下某些Class是否存在，从而推导应用的类型。我们进入 <code>WebApplicationType.deduceFromClasspath()</code> 方法查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> WebApplicationType &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 非web项目</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NONE,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * servlet web项目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SERVLET,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * reactive web项目</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	REACTIVE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = &#123; <span class="string">"javax.servlet.Servlet"</span>,</span><br><span class="line">			<span class="string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBMVC_INDICATOR_CLASS = <span class="string">"org.springframework."</span></span><br><span class="line">			+ <span class="string">"web.servlet.DispatcherServlet"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBFLUX_INDICATOR_CLASS = <span class="string">"org."</span></span><br><span class="line">			+ <span class="string">"springframework.web.reactive.DispatcherHandler"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JERSEY_INDICATOR_CLASS = <span class="string">"org.glassfish.jersey.servlet.ServletContainer"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_APPLICATION_CONTEXT_CLASS = <span class="string">"org.springframework.web.context.WebApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REACTIVE_APPLICATION_CONTEXT_CLASS = <span class="string">"org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果DispatcherHandler存在、而DispatcherServlet和ServletContainer不存在，则推断为Reactive Web方式</span></span><br><span class="line">		<span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">            <span class="comment">// 如果Servlet和ConfigurableWebApplicationContext不存在，则当前应用为非Web类型</span></span><br><span class="line">			<span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 其他则为servlet web类型</span></span><br><span class="line">		<span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reavtive web</code>是在Spring5之后提出的概念，其中重点是 <code>DispatcherHandler</code>表示请求的总控制器，类似于WebMVC中的<code>DispatcherServlet</code></p>
<h3 id="2-2-加载应用上下文初始器-ApplicationContextInitializer"><a href="#2-2-加载应用上下文初始器-ApplicationContextInitializer" class="headerlink" title="2.2 加载应用上下文初始器 ApplicationContextInitializer"></a>2.2 加载应用上下文初始器 ApplicationContextInitializer</h3><p>接着进入加载Spring应用上下文初始器的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (9)最后添加到SpringApplication的initializers集合变量中</span></span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">				ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>setInitializers</code>方法和<code>getSpringFactoriesInstances</code>方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] &#123;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">			Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">		ClassLoader classLoader = getClassLoader();</span><br><span class="line">		<span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">        <span class="comment">//(1) 使用 Spring 工厂加载机制，我们知道，该方法是从所有的 META-INF/spring.factories 资源中获取key为 ApplicationContextInitializer 的实现类集合</span></span><br><span class="line">		Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</span><br><span class="line">				SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (2)初始化这些实现类</span></span><br><span class="line">		List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">				classLoader, args, names);</span><br><span class="line">        <span class="comment">// (7)进行排序操作</span></span><br><span class="line">		AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">		<span class="comment">// (8)返回该list </span></span><br><span class="line">        <span class="keyword">return</span> instances;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">			Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">			Set&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">		List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size());</span><br><span class="line">		<span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">				Assert.isAssignable(type, instanceClass);</span><br><span class="line">				Constructor&lt;?&gt; constructor = instanceClass</span><br><span class="line">						.getDeclaredConstructor(parameterTypes);</span><br><span class="line">				<span class="comment">// (4)先通过 BeanUtils.instantiate 初始化这些类，然后，并，。至此，该流程结束。</span></span><br><span class="line">                T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">				<span class="comment">// (5)将初始化的类保存至List</span></span><br><span class="line">                instances.add(instance);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">						<span class="string">"Cannot instantiate "</span> + type + <span class="string">" : "</span> + name, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// (6)返回该list</span></span><br><span class="line">		<span class="keyword">return</span> instances;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitializers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.initializers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">this</span>.initializers.addAll(initializers);</span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中（1）处，在<code>spring-boot-autoconfigure</code> 包下的 <code>spring.factories</code> 文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br></pre></td></tr></table></figure>

<p>这里获取的就是 <code>SharedMetadataReaderFactoryContextInitializer</code> 和 <code>ConditionEvaluationReportLoggingListener</code> 上下文初始化器。</p>
<p>我们不妨看看上面列举的<code>SharedMetadataReaderFactoryContextInitializer</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedMetadataReaderFactoryContextInitializer</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">      <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"org.springframework.boot.autoconfigure."</span></span><br><span class="line">         + <span class="string">"internalCachingMetadataReaderFactory"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 在上下文中加入了 CachingMetadataReaderFactoryPostProcessor bean工厂后置处理器。   </span></span><br><span class="line">       applicationContext.addBeanFactoryPostProcessor(</span><br><span class="line">            <span class="keyword">new</span> CachingMetadataReaderFactoryPostProcessor());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContextInitializer</code> 接口的主要作用是在 <code>ConfigurableApplicationContext</code>#<code>refresh()</code> 方法调用之前做一些初始化工作。</p>
<h3 id="2-3-加载应用事件监听器-ApplicationListener"><a href="#2-3-加载应用事件监听器-ApplicationListener" class="headerlink" title="2.3 加载应用事件监听器 ApplicationListener"></a>2.3 加载应用事件监听器 ApplicationListener</h3><p>接着加载应用事件监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载应用事件监听器 listener</span></span><br><span class="line">        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br></pre></td></tr></table></figure>

<p>过程与“加载应用上下文初始器”基本一致，同样是调用 <code>getSpringFactoriesInstances</code> 方法，不过这里获取的是 key 为 <code>ApplicationListener</code> 的对象集合，如下是 <code>spring-boot-autoconfigure</code> 包下的 <code>spring.factories</code> 文件：：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br></pre></td></tr></table></figure>

<p>最后，将获取的 <code>BackgroundPreinitializer</code> 对象通过 <code>setListeners</code> 方法放入 <code>listeners</code> 属性变量中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListeners</span><span class="params">(Collection&lt;? extends ApplicationListener&lt;?&gt;&gt; listeners)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.listeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">this</span>.listeners.addAll(listeners);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，我们看看<code>BackgroundPreinitializer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order</span>(LoggingApplicationListener.DEFAULT_ORDER + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPreinitializer</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">SpringApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(SpringApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Boolean.getBoolean(IGNORE_BACKGROUNDPREINITIALIZER_PROPERTY_NAME)</span><br><span class="line">				&amp;&amp; event <span class="keyword">instanceof</span> ApplicationStartingEvent</span><br><span class="line">				&amp;&amp; preinitializationStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			performPreinitialization();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((event <span class="keyword">instanceof</span> ApplicationReadyEvent</span><br><span class="line">				|| event <span class="keyword">instanceof</span> ApplicationFailedEvent)</span><br><span class="line">				&amp;&amp; preinitializationStarted.get()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				preinitializationComplete.await();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">				Thread.currentThread().interrupt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>ApplicationListener</code>接口的主要功能是另起一个后台线程触发那些耗时的初始化，包括验证器、消息转换器等等。</p>
<p>目前spring boot中支持的事件类型如下：</p>
<ul>
<li>ApplicationFailedEvent：该事件为spring boot启动失败时的操作</li>
<li>ApplicationPreparedEvent：上下文context准备时触发</li>
<li>ApplicationReadyEvent：上下文已经准备完毕的时候触发</li>
<li>ApplicationStartedEvent：spring boot 启动监听类</li>
<li>SpringApplicationEvent：获取SpringApplication</li>
<li>ApplicationEnvironmentPreparedEvent：环境事先准备</li>
</ul>
<h3 id="2-4-推断应用引导类"><a href="#2-4-推断应用引导类" class="headerlink" title="2.4 推断应用引导类"></a>2.4 推断应用引导类</h3><p>准备阶段的最后一步是推断应用的引导类，也就是获取启动 main 方法的类，执行的是 <code>deduceMainApplicationClass()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断引导类，也就是找到入口类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br></pre></td></tr></table></figure>

<p>不妨看看该源码的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程的执行栈</span></span><br><span class="line">        StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            <span class="comment">// 通过getMethodName()判断是否为main方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                <span class="comment">// 最后返回 main 方法的所在类。</span></span><br><span class="line">                <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// Swallow and continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-SpringApplication-配置"><a href="#3-SpringApplication-配置" class="headerlink" title="3. SpringApplication 配置"></a>3. SpringApplication 配置</h2><p>​    <code>SpringApplication</code> 准备阶段结束后，按道理应该进入运行阶段，但运行阶段之前还有一个操作，就是可以修改 <code>SpringApplication</code> 默认配置。开头的代码示例可以看到，应用程序主类中的main方法中写的都是<code>SpringApplication.run(xx.class)</code>，可能这种写法不满足我们的需求，我们可以对<code>SpringApplication</code>进行一些配置，例如关闭<code>Banner</code>，设置一些默认的属性等。下面则是利用 <code>SpringApplicationBuilder</code> 的方式来添加配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiveInSpringBootApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(DiveInSpringBootApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				// 设置当前应用类型</span></span><br><span class="line"><span class="class">				.<span class="title">web</span>(<span class="title">WebApplicationType</span>.<span class="title">SERVLET</span>)</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				// 设置 <span class="title">banner</span> 横幅打印方式、有关闭、日志、控制台</span></span><br><span class="line"><span class="class">				.<span class="title">bannerMode</span>(<span class="title">Banner</span>.<span class="title">Mode</span>.<span class="title">OFF</span>)</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				// 设置自定义的 <span class="title">banner</span></span></span><br><span class="line"><span class="class">				.<span class="title">banner</span>()</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				// 追加自定义的 <span class="title">initializer</span> 到集合中 </span></span><br><span class="line"><span class="class">				.<span class="title">initializers</span>()</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				// 追加自定义的 <span class="title">listeners</span> 到集合中</span></span><br><span class="line"><span class="class">				.<span class="title">listeners</span>()</span></span><br><span class="line"><span class="class">				.<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用该方式实现的<code>SpringApplication</code>可以对其添加自定义的配置。当然配置远远不止这么点，其它的还请自行观看源码。</p>
<p>至此，<code>SpringApplication</code> 的准备工作结束，其实主要是对<code>primarySources</code>、<code>webApplicationType</code>、<code>initializers</code>、<code>listeners</code>、<code>mainApplicationClass</code> 这几个属性进行初始化，以及对 <code>SpringApplication</code> 进行自定义配置 。下篇文章，就来讲讲<code>SpringApplication</code>运行阶段，在运行阶段中这些 <code>SpringApplication</code>的配置和应用初始化器、监听器等如何被使用。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/dm_vincent/article/details/76735888" target="_blank" rel="noopener">https://blog.csdn.net/dm_vincent/article/details/76735888</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-1-SpringBoot基础1-自动装配基础</title>
    <url>/2020/SpringBoot-1-SpringBoot%E5%9F%BA%E7%A1%801-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="1、起源"><a href="#1、起源" class="headerlink" title="1、起源"></a>1、起源</h1><p>​    我们先来简单的聊聊Spring注解的发展史。Spring1.x时代，那时候注解的概念刚刚兴起，仅支持如 <code>@Transactional</code>等注解。到了2.x时代Spring的注解体系有了雏形，引入了 <code>@Autowired</code>、 <code>@Controller</code>这一系列骨架式的注解。3.x是黄金时代，它除了引入 <code>@Enable</code>模块驱动概念，加快了Spring注解体系的成型，还引入了配置类 <code>@Configuration</code>及<code>@ComponentScan</code> ，使我们可以抛弃XML配置文件的形式，全面拥抱Spring注解，但Spring并未完全放弃XML配置文件，它提供了<code>@ImportResource</code> 允许导入遗留的XML配置文件。此外还提供了 <code>@Import</code> 允许导入一个或多个Java类成为Spring Bean。4.X则趋于完善，引入了条件化注解<code>@Conditional</code> ，使装配更加的灵活。当下是5.X时代，是SpringBoot2.0的底层核心框架，目前来看，变化不是很大，但也引入了一个 <code>@Indexed</code> 注解，主要是用来提升启动性能的。好了，以上是Spring注解的发展史，接下来我们对Spring注解体系的几个议题进行讲解。</p>
<h1 id="2、Spring-模式注解"><a href="#2、Spring-模式注解" class="headerlink" title="2、Spring 模式注解"></a>2、Spring 模式注解</h1><p>​    模式注解是一种用于声明在应用中扮演“组件”角色的注解。如 Spring 中的 @Repository 是用于扮演仓储角色的模式注解，用来管理和存储某种领域对象。还有如@Component 是通用组件模式、@Service 是服务模式、@Configuration 是配置模式等。其中@Component 作为一种由 Spring 容器托管的通用模式组件，任何被 @Component 标注的组件均为组件扫描的候选对象。类似地，凡是被 @Component 标注的注解，如@Service ，当任何组件标注它时，也被视作组件扫描的候选对象。<br>举例：</p>
<table>
<thead>
<tr>
<th>Spring注解</th>
<th>场景说明</th>
<th>起始版本</th>
</tr>
</thead>
<tbody><tr>
<td>@Componnt</td>
<td>通用组件模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Repository</td>
<td>数据仓储模式注解</td>
<td>2.0</td>
</tr>
<tr>
<td>@Service</td>
<td>服务模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Controller</td>
<td>Web 控制器模式注解</td>
<td>2.5</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类模式注解</td>
<td>3.0</td>
</tr>
</tbody></table>
<p>那么，被这些注解标注的类如何交由Spring来管理呢，或者说如何被Spring所装配呢？接下来我们就来看看Spring的两种装配方式。</p>
<h3 id="2-1、装配方式"><a href="#2-1、装配方式" class="headerlink" title="2.1、装配方式"></a>2.1、装配方式</h3><ul>
<li><h5 id="context-component-scan-方式"><a href="#context-component-scan-方式" class="headerlink" title="context:component-scan 方式"></a><a href="context:component-scan">context:component-scan</a> 方式</h5></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.loong.spring.boot"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一种是XML配置文件的方式，通过 base-package 这个属性指定扫描某个范围内所有被 @Component 或者其派生注解标记的类(Class)，将它们注册为 Spring Bean。</p>
<p>我们都知道XML Schema 规范，标签需要显示地关联命名空间，如配置文件中的 xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a> ，且需要与其处理类建立映射关系，而该关系维护在相对于 classpath 下的/META-INF/spring.handlers 文件中。如下：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\<span class="symbol">://www</span>.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>可以看到， context 所对应的处理器为 ContextNamespaceHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    .....</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">		.....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里当Spring启动时，init方法被调用，随后注册该命名空间下的所有 Bean 定义解析器，可以看到 &lt;context:component-scan /&gt; 的解析器为 ComponentScanBeanDefinitionParser 。具体的处理过程就在此类中，感兴趣的同学可以去深入了解，这里不再赘述。</p>
<ul>
<li><h5 id="ComponentScan-方式"><a href="#ComponentScan-方式" class="headerlink" title="@ComponentScan 方式"></a>@ComponentScan 方式</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.loong.spring.boot"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是注解的形式，同样也是依靠 basePackages 属性指定扫描范围。</p>
<p>Spring 在启动时，会在某个生命周期内创建所有的配置类注解解析器，而 @ComponentScan 的处理器为 ComponentScanAnnotationParser ，感兴趣的同学可以去深入了解，这里同样不再赘述。</p>
<h3 id="2-2、派生性"><a href="#2-2、派生性" class="headerlink" title="2.2、派生性"></a>2.2、派生性</h3><p>我们用自定义注解的方式来看一看文中提到的派生性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FirstLevelRepository &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们自定义了一个<br>@FirstLevelRepository 注解，当前注解又标注了 @Repository，而 @Repository 又标注了 @Component 并且注解属性一致（String value() default””），那么就可以表示当前注解包含了<br>@Repository 及 @Component 的功能。</p>
<blockquote>
<p>派生性其实可以分为多层次的，如<br>@SprintBootApplication -&gt; @SpringBootConfiguration -&gt; @Configuration -&gt; @Component 可以看到@Component被派生了多个层次，但这种多层次的派生性Spring 4.0版本才开始支持，Spring3.0仅支持两层。</p>
</blockquote>
<h1 id="3、Spring-Enable-模块驱动"><a href="#3、Spring-Enable-模块驱动" class="headerlink" title="3、Spring @Enable 模块驱动"></a>3、Spring @Enable 模块驱动</h1><p>​    前文提到Spring3.X是一个黄金时代，它不仅全面拥抱注解模式，还开始支持“@Enable模块驱动”。所谓“模块”是指具备相同领域的功能组件集合，组合所形成的一个独立的单元，比如 Web MVC 模块、AspectJ代理模块、Caching(缓存)模块、JMX(Java 管理扩展)模块、Async(异步处理)模块等。这种“模块”理念在后续的Spring 、Spring Boot和Spring Cloud版本中都一直被使用，这种模块化的注解均以 @Enable 作为前缀，如下所示：</p>
<table>
<thead>
<tr>
<th>框架实现</th>
<th>@Enable注解模块</th>
<th>激活模块</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Framework</td>
<td>@EnableWebMvc</td>
<td>Web Mvc 模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableTransactionManagement</td>
<td>事物管理模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableWebFlux</td>
<td>Web Flux 模块</td>
</tr>
<tr>
<td>Spring Boot</td>
<td>@EnableAutoConfiguration</td>
<td>自动装配模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableConfigurationProperties</td>
<td>配置属性绑定模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableOAuth2Sso</td>
<td>OAuth2 单点登陆模块</td>
</tr>
<tr>
<td>Spring Cloud</td>
<td>@EnableEurekaServer</td>
<td>Eureka 服务器模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableFeignClients</td>
<td>Feign 客户端模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableZuulProxy</td>
<td>服务网关 Zuul 模块</td>
</tr>
<tr>
<td>/</td>
<td>@EnableCircuitBreaker</td>
<td>服务熔断模块</td>
</tr>
</tbody></table>
<p>引入模块驱动的意义在于简化装配步骤，屏蔽了模块中组件集合装配的细节。但该模式必须手动触发，也就是将该注解标注在某个配置Bean中，同时理解原理和加载机制的成本较高。那么，Spring是如何实现 @Enable 模块呢？主要有以下两种方式。</p>
<h3 id="3-1、Spring框架中-Enable实现方式"><a href="#3-1、Spring框架中-Enable实现方式" class="headerlink" title="3.1、Spring框架中@Enable实现方式"></a>3.1、Spring框架中@Enable实现方式</h3><ul>
<li><h5 id="基于-Import-注解"><a href="#基于-Import-注解" class="headerlink" title="基于 @Import 注解"></a>基于 @Import 注解</h5></li>
</ul>
<p>首先，参考 @EnableWebMvc 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableWebMvc</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现模式主要是通过 @Import 导入配置类 DelegatingWebMvcConfiguration ，而该类标注了 @Configuration 注解，表明这是个配置类，我们都知道 @EnableWebMvc 是用来激活Web MVC模块，所以如HandlerMapping 、HandlerAdapter这些和MVC相关的组件都是在这个配置类中被组装，这也就是所谓的模块理念。</p>
<ul>
<li><h5 id="基于接口编程"><a href="#基于接口编程" class="headerlink" title="基于接口编程"></a>基于接口编程</h5></li>
</ul>
<p>基于接口编程同样有两种实现方式，第一种参考 @EnableCaching的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(CachingConfigurationSelector<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableCaching</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableCaching</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (adviceMode) &#123; <span class="comment">//switch语句选择实现模式</span></span><br><span class="line">            <span class="keyword">case</span> PROXY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;AutoProxyRegistrar<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">ProxyCachingConfiguration</span>.<span class="title">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br><span class="line">            <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;AnnotationConfigUtils.CACHE_ASPECT_CONFIGURATION_CLASS_NAME&#125;;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式主要是继承 ImportSelector 接口（AdviceModeImportSelector实现了ImportSelector接口），然后实现 selectImports 方法，通过入参进而动态的选择一个或多个类进行导入，相较于注解驱动，此方法更具有弹性。</p>
<p>第二种参考 @EnableApolloConfig 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(ApolloConfigRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableApolloConfig</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloConfigRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, PropertySourcesPlaceholderConfigurer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),</span></span><br><span class="line"><span class="class">        <span class="title">PropertySourcesPlaceholderConfigurer</span>.<span class="title">class</span>, <span class="title">propertySourcesPlaceholderPropertyValues</span>)</span>;</span><br><span class="line"></span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, PropertySourcesProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),</span></span><br><span class="line"><span class="class">        <span class="title">PropertySourcesProcessor</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, ApolloAnnotationProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),</span></span><br><span class="line"><span class="class">        <span class="title">ApolloAnnotationProcessor</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, SpringValueProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">SpringValueProcessor</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, SpringValueDefinitionProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">SpringValueDefinitionProcessor</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, ApolloJsonValueProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(),</span></span><br><span class="line"><span class="class">            <span class="title">ApolloJsonValueProcessor</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式主要是通过 @Import 导入实现了 ImportBeanDefinitionRegistrar 接口的类，在该类中重写 registerBeanDefinitions 方法，通过 BeanDefinitionRegistry 直接手动注册和该模块相关的组件。接下来，我们用这两种方式实现自定义的 @Enable 模块。</p>
<h3 id="3-2、自定义-Enable模块实现"><a href="#3-2、自定义-Enable模块实现" class="headerlink" title="3.2、自定义@Enable模块实现"></a>3.2、自定义@Enable模块实现</h3><ul>
<li><h5 id="基于-Import-注解-1"><a href="#基于-Import-注解-1" class="headerlink" title="基于 @Import 注解"></a>基于 @Import 注解</h5></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableHelloWorld</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以做一些组件初始化的操作。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableHelloWorldBootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(EnableHelloWorldBootstrap<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">web</span>(<span class="title">WebApplicationType</span>.<span class="title">NONE</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">        String helloWorld = context.getBean(<span class="string">"helloWorld"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(helloWorld );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们自定义了一个 @EnableHelloWorld 注解，再用 @Import 导入一个自定义的配置类 HelloWorldConfiguration，在这个配置类中初始化 helloWorld 。</p>
<ul>
<li><h5 id="基于接口编程-1"><a href="#基于接口编程-1" class="headerlink" title="基于接口编程"></a>基于接口编程</h5></li>
</ul>
<p>第一种基于 ImportSelector 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableHelloWorld</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这种方法比较有弹性：</span></span><br><span class="line"><span class="comment">     *  可以调用importingClassMetadata里的方法来进行条件过滤</span></span><br><span class="line"><span class="comment">     *  具体哪些方法参考：https://blog.csdn.net/f641385712/article/details/88765470</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (importingClassMetadata.hasAnnotation(<span class="string">"com.loong.case3.spring.annotation.EnableHelloWorld"</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;HelloWorldConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以做一些组件初始化的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableHelloWorldBootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(EnableHelloWorldBootstrap<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">web</span>(<span class="title">WebApplicationType</span>.<span class="title">NONE</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">        String helloWorld = context.getBean(<span class="string">"helloWorld"</span>,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(helloWorld );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们同样是自定义 @EnableHelloWorld 注解，通过 @Import 导入 HelloWorldImportSelector 类，该类实现了 ImportSelector 接口，在重写的方法中通过 importingClassMetadata.hasAnnotation(“com.loong.case3.spring.annotation.EnableHelloWorld”) 判断该类是否标注了 @EnableHelloWorld 注解，从而导入 HelloWorldConfiguration 类，进行初始化工作。</p>
<p>第二种基于 ImportBeanDefinitionRegistrar 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableHelloWorld</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (annotationMetadata.hasAnnotation(<span class="string">"com.loong..case4.spring.annotation.EnableHelloWorld"</span>)) &#123;</span><br><span class="line">            RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(HelloWorldConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            beanDefinitionRegistry.registerBeanDefinition(HelloWorldConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">beanDefinition</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorldConfiguration初始化...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableHelloWorldBootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(EnableHelloWorldBootstrap<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">web</span>(<span class="title">WebApplicationType</span>.<span class="title">NONE</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是在 HelloWorldRegistrar 中利用 BeanDefinitionRegistry 直接注册 HelloWorldConfiguration。</p>
<h1 id="4、Spring-条件装配"><a href="#4、Spring-条件装配" class="headerlink" title="4、Spring 条件装配"></a>4、Spring 条件装配</h1><p>​    条件装配指的是通过一些列操作判断是否装配 Bean ，也就是 Bean 装配的前置判断。实现方式主要有两种：@Profile 和 @Conditional，这里我们主要讲 @Conditional 的实现方式，因为 @Profile 在 Spring 4.0 后也是通过 @Conditional 来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conditional</span>(HelloWorldCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Component</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldConditionConfiguration</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorldConfiguration初始化。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过自定义一个 HelloWorldConfiguration 配置类，再标注 @Conditional 注解导入 HelloWorldCondition类，该类必须实现 Condition 接口，然后重写 matches 方法，在方法中可以通过两个入参来获取一系列的上下文数据和元数据，最终返回ture或false来判定该类是否初始化，</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/loongk/p/11970246.html" target="_blank" rel="noopener">SpringBoot（一）自动装配基础 - @Component、@ComponentScan、@Enable 模块</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-2-SpringBoot基础2-自动装配原理分析</title>
    <url>/2020/SpringBoot-2-SpringBoot%E5%9F%BA%E7%A1%802-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在创建完成SpringBoot应用后，我们通常在启动类中发现如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplication1<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的注解<code>@SpringBootApplication</code>便是表明该类是一个启动类。我们不禁好奇，其内部是怎样的？</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-SpringBootApplication注解"><a href="#2-1-SpringBootApplication注解" class="headerlink" title="2.1 @SpringBootApplication注解"></a>2.1 @SpringBootApplication注解</h3><p>说到 Spring Boot 启动类就不得不介绍一下 <strong><code>@SpringBootApplication</code> 注解</strong>了，这个注解的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">	<span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出大概可以把 <code>@SpringBootApplication</code>看作是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>注解的集合。根据 SpringBoot官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@SpringBootConfiguration</code>：标注在某个类上，表示这是一个Spring Boot的配置类；</li>
</ul>
<p>所以说 <code>@SpringBootApplication</code>就是几个重要的注解的组合，为什么要有它？当然是为了省事，避免了我们每次开发 Spring Boot 项目都要写一些必备的注解。这一点在我们平时开发中也经常用到，比如我们通常会提一个测试基类，这个基类包含了我们写测试所需要的一些基本的注解和一些依赖。下面将对上面三个注解分析。</p>
<p>允许在上下文中注册额外的bean或导入其他配置类。</p>
<h3 id="2-2-SpringBootConfiguration注解"><a href="#2-2-SpringBootConfiguration注解" class="headerlink" title="2.2 @SpringBootConfiguration注解"></a>2.2 @SpringBootConfiguration注解</h3><p>我们可以看看其源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现其实际上就是一个<code>@Configuration</code>注解。在Spring中我们知道标注这个注解的该类表示其是一个注解类。配置类也是容器（<code>@Componnet</code>）的一个组件，还有其他组件如下：</p>
<ul>
<li><p><code>@Service</code>用于标注业务层组件</p>
</li>
<li><p><code>@Controller</code>用于标注控制层组件（如struts中的action）</p>
</li>
<li><p><code>@Repository</code>用于标注数据访问组件，即DAO组件</p>
</li>
<li><p><code>@Component</code>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
</li>
</ul>
<p>但是需要注意的是，在使用<code>@Componnet</code>和<code>@Configuration</code>使用上存在差别</p>
<p><a href="https://blog.csdn.net/long476964/article/details/80626930?utm_source=blogkpcl7" target="_blank" rel="noopener">@Component和@Configuration作为配置类的差别</a></p>
<p>总结起来就是：<span style="color:red">@Configuration是随容器启动开始加载的,始终存在的单例模式。 @Component是使用一次即实例化一次</span></p>
<h3 id="2-3-EnableAutoConfiguration注解"><a href="#2-3-EnableAutoConfiguration注解" class="headerlink" title="2.3 @EnableAutoConfiguration注解"></a>2.3 @EnableAutoConfiguration注解</h3><p>同样我们看看其源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line">	<span class="comment">// 指定排除那些指定配置类，值为class</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定排除那些指定配置类,值为String类型</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">功能：开启自动配置功能</span>。以前我们需要配置的东西，默认是自动配置其默认的全部类（后面有分析），Spring Boot帮我们自动配置。</p>
<ul>
<li><p><code>@AutoConfigurationPackage</code>：自动导包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部还是通过<code>@Import</code>注解，该注解的作用是给容器导入一个组件。<code>@Import(AutoConfigurationPackages.Registrar.class)</code>，它就是将<code>Registrar</code>这个组件类导入到容器中，可查看<code>Registrar</code>类中<code>registerBeanDefinitions</code>方法，这个方法就是导入组件类的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将注解标注的元信息传入，获取到相应的包名</span></span><br><span class="line">    register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这一行设置一个断点，利用debug运行。</p>
<p><img src="../../images/springboot/20200331212013.jpg" alt></p>
<p>可以发现，扫描的包就是<code>com.xfcy</code>下的全部内容。</p>
</li>
<li><p><code>AutoConfigurationImportSelector</code>：导入哪些组件的选择器；将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</p>
<p>不妨看一下该类的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>,</span></span><br><span class="line"><span class="class">      <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//  加载自动装配的元信息</span></span><br><span class="line">      AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">            .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">      <span class="comment">// 该方法返回的就是自动装配的组件,进入该方法</span></span><br><span class="line">      AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(</span><br><span class="line">				autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>getAutoConfigurationEntry</code>方法的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">			<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 获取 @EnableAutoConfigoration 标注类的元信息，也就是获取该注解 exclude 和 excludeName 属性值 </span></span><br><span class="line">		AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 该方法就是获取自动装配的类名集合</span></span><br><span class="line">		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">				attributes);</span><br><span class="line">    	<span class="comment">// 去除重复的自动装配组件，就是将List转为Set进行去重</span></span><br><span class="line">		configurations = removeDuplicates(configurations);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 这部分就是根据上面获取的 exclude 及 excludeName 属性值，排除指定的类</span></span><br><span class="line">    	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">		checkExcludedClasses(configurations, exclusions);</span><br><span class="line">		configurations.removeAll(exclusions);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">// 这里是过滤那些依赖不满足的自动装配 Class</span></span><br><span class="line">    	configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">		fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="comment">// 返回的就是经过一系列去重、排除、过滤等操作后的自动装配组件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中对于<code>getCandidateConfigurations</code>方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">				getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations,</span><br><span class="line">				<span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">						+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">		<span class="keyword">return</span> configurations;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>getSpringFactoriesLoaderFactoryClass()</code>返回的是<code>EnableAutoConfiguration.class</code>。</p>
<p>继续往下，执行的是 <code>SpringFactoriesLoader#loadFactoryNames</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 前面可以看到，这里的 factoryClass 是 EnableAutoConfiguration.class</span></span><br><span class="line">		String factoryClassName = factoryClass.getName();</span><br><span class="line">		<span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">		MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">			result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">				URL url = urls.nextElement();</span><br><span class="line">				UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">				Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">				<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">					String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">					<span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">						result.add(factoryClassName, factoryName.trim());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cache.put(classLoader, result);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">					FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的实现逻辑都在这里，主要过程如下：</p>
<p>（1）搜索classpath路径下以及所有外部jar包下的META-INF文件夹中的<code>spring.factories</code>文件。主要是<code>spring-boot-autoconfigur</code>包下的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line">//....</span><br></pre></td></tr></table></figure>

<p>可以看到其中内容，存储的是key-value格式的数据，且key是一个类的全路径名称，value是多个类的全路径名称，且以逗号分割。</p>
<p>（2）将所有的<code>spring.factories</code>文件转成<code>Properties</code>格式，将里面key-value格式的数据转成Map，该Map的value是一个List，之后将相同Key的value合并到List中，将该Map作为方法返回值返回。</p>
<p>（3）返回到 <code>loadFactoryNames</code> 方法，通过上面得知<code>factoryClassName</code>的值为<code>EnableAutoConfiguration</code>，所以通过 <code>getOrDefault(factoryClassName, Collections.emptyList())</code>方法，获取 key 为<code>EnableAutoConfiguration</code>的类名集合。</p>
<blockquote>
<p>ps：<code>getOrDefault</code>第一个入参是key的name，如果key不存在，则直接返回第二个参数值</p>
</blockquote>
<p>至此，流程结束，最后返回的就是自动装配的组件，其中有我们比较熟悉的Redis、JDBC、SpringMVC等，可以看到一个特点，这些自动装配的组件都是以 <code>AutoConfiguration</code> 结尾。但该组件列表只是候选组件，因为后面还有去重、排除、过滤等一系列操作，这里就不再详细述说。下面我们来看看自动装配的组件内部是怎么样的。</p>
</li>
</ul>
<h3 id="2-4-自动装配的内部实现"><a href="#2-4-自动装配的内部实现" class="headerlink" title="2.4 自动装配的内部实现"></a>2.4 自动装配的内部实现</h3><p>就拿比较熟悉的 Web MVC 来看，看看是如何实现 Web MVC 自动装配的。先来代码组成部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>, <span class="title">WebMvcConfigurer</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">TaskExecutionAutoConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import</span>(EnableWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">EnableConfigurationProperties</span>(</span>&#123;WebMvcProperties<span class="class">.<span class="keyword">class</span>, <span class="title">ResourceProperties</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Order</span>(0)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean</span>(View<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        @<span class="title">ConditionalOnMissingBean</span></span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">BeanNameViewResolver</span> <span class="title">beanNameViewResolver</span>() </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title">requestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@Primary</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解部分：<ul>
<li><code>@Configuration</code>：这个大家都比较熟悉，标识该类是一个配置类</li>
<li><code>@ConditionalXXX</code>：这是上篇文章所讲的 Spring 条件装配，只不过经由 Spring Boot 扩展形成了自己的条件化自动装配，且都是<code>@Conditional</code>的派生注解。<ul>
<li><code>@ConditionalOnWebApplication</code>：参数值是 Type 类型的枚举，当前项目类型是任意、Web、Reactive其中之一则实例化该 Bean。这里指定如果为 Web 项目才满足条件。</li>
<li><code>@ConditionalOnClass</code>：参数是 Class 数组，当给定的类名在类路径上存在，则实例化当前Bean。这里当<code>Servlet.class</code>、 <code>DispatcherServlet.class</code>、 <code>WebMvcConfigurer.class</code>存在才满足条件。</li>
<li><code>@ConditionalOnMissingBean</code>：参数是也是 Class 数组，当给定的类没有实例化时，则实例化当前Bean。这里指定当 <code>WebMvcConfigurationSupport</code> 该类没有实例化时，才满足条件。</li>
</ul>
</li>
<li>装配顺序<ul>
<li><code>@AutoConfigureOrder</code>：参数是int类型的数值，数越小越先初始化。</li>
<li><code>@AutoConfigureAfter</code>：参数是 Class 数组，在指定的配置类初始化后再加载。</li>
<li><code>@AutoConfigureBefore</code>：参数同样是 Class 数组，在指定的配置类初始化前加载。</li>
</ul>
</li>
</ul>
</li>
<li>代码部分：<ul>
<li>这部分就比较直接了，实例化了和 Web MVC 相关的Bean，如 <code>HandlerAdapter</code>、<code>HandlerMapping</code>、<code>ViewResolver</code>等。其中，出现了 <code>DelegatingWebMvcConfiguration</code> 类，这是上篇文章所讲的 <code>@EnableWebMvc</code> 所 <code>@Import</code>导入的配置类。</li>
</ul>
</li>
</ul>
<p>可以看到，在<code>Spring Boot</code> 自动装配的类中，经过了一系列的 <code>@Conditional</code> 条件判断，然后实例化某个模块需要的Bean，且无需我们配置任何东西，当然，这都是默认实现，当这些不满足我们的要求时，我们还得手动操作。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-1-数据结构-二叉搜索树</title>
    <url>/2020/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二、二叉搜索树-BST"><a href="#二、二叉搜索树-BST" class="headerlink" title="二、二叉搜索树 BST"></a><strong>二、二叉搜索树 BST</strong></h3><p>顾名思义，二叉树上又加了个搜索的限制。其要求：<strong><span style="color:red">每个节点比其左子树元素大，比其右子树元素小。</span></strong><br><img src="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3EiaTTxDQoN4EmiaEXfQCicWhKys4miaaRibJJDcjYeytfNzMkibxEp4GCDIIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<h3 id="三、BST-Java实现"><a href="#三、BST-Java实现" class="headerlink" title="三、BST Java实现"></a><strong>三、BST Java实现</strong></h3><p>直接上代码，对应代码分享在 Github 主页</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinarySearchTree.java</span><br><span class="line"><span class="keyword">package</span> org.algorithm.tree;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright [2015] [Jeff Lee]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树(BST)实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by bysocket on 16/7/7.</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode root;    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span> </span>&#123;        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">    &#125;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找</span></span><br><span class="line"><span class="comment">     *      树深(N) O(lgN)</span></span><br><span class="line"><span class="comment">     *      1. 从root节点开始</span></span><br><span class="line"><span class="comment">     *      2. 比当前节点值小,则找其左节点</span></span><br><span class="line"><span class="comment">     *      3. 比当前节点值大,则找其右节点</span></span><br><span class="line"><span class="comment">     *      4. 与当前节点值相等,查找到返回TRUE</span></span><br><span class="line"><span class="comment">     *      5. 查找完毕未找到,</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">search</span> <span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        TreeNode current = root;        <span class="keyword">while</span> (current != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; key != current.value) &#123;                   <span class="keyword">if</span> (key &lt; current.value )</span><br><span class="line">                current = current.left;                              <span class="keyword">else</span></span><br><span class="line">                current = current.right;</span><br><span class="line">        &#125;        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     *      1. 从root节点开始</span></span><br><span class="line"><span class="comment">     *      2. 如果root为空,root为插入值</span></span><br><span class="line"><span class="comment">     *      循环:</span></span><br><span class="line"><span class="comment">     *      3. 如果当前节点值大于插入值,找左节点</span></span><br><span class="line"><span class="comment">     *      4. 如果当前节点值小于插入值,找右节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;        <span class="comment">// 新增节点</span></span><br><span class="line">        TreeNode newNode = <span class="keyword">new</span> TreeNode(key);        <span class="comment">// 当前节点</span></span><br><span class="line">        TreeNode current = root;        <span class="comment">// 上个节点</span></span><br><span class="line">        TreeNode parent  = <span class="keyword">null</span>;        <span class="comment">// 如果根节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = newNode;            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            parent = current;             <span class="keyword">if</span> (key &lt; current.value) &#123;</span><br><span class="line">                current = current.left;                 <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.left = newNode;                    <span class="keyword">return</span> newNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current = current.right;                    <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.right = newNode;                    <span class="keyword">return</span> newNode;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *      1.找到删除节点</span></span><br><span class="line"><span class="comment">     *      2.如果删除节点左节点为空 , 右节点也为空;</span></span><br><span class="line"><span class="comment">     *      3.如果删除节点只有一个子节点 右节点 或者 左节点</span></span><br><span class="line"><span class="comment">     *      4.如果删除节点左右子节点都不为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">delete</span> <span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        TreeNode parent  = root;</span><br><span class="line">        TreeNode current = root;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">false</span>;        <span class="comment">// 找到删除节点 及 是否在左子树</span></span><br><span class="line">        <span class="keyword">while</span> (current.value != key) &#123;</span><br><span class="line">            parent = current;            <span class="keyword">if</span> (current.value &gt; key) &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">                current = current.right;</span><br><span class="line">            &#125;            <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;                <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        <span class="comment">// 如果删除节点左节点为空 , 右节点也为空</span></span><br><span class="line">        <span class="keyword">if</span> (current.left == <span class="keyword">null</span> &amp;&amp; current.right == <span class="keyword">null</span>) &#123;            <span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125;            <span class="comment">// 在左子树</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild == <span class="keyword">true</span>) &#123;</span><br><span class="line">                parent.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        <span class="comment">// 如果删除节点只有一个子节点 右节点 或者 左节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current.right == <span class="keyword">null</span>) &#123;            <span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">                root = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                parent.left = current.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = current.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;                   <span class="keyword">else</span> <span class="keyword">if</span> (current.left == <span class="keyword">null</span>) &#123;                  <span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">                root = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                parent.left = current.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = current.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        <span class="comment">// 如果删除节点左右子节点都不为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current.left != <span class="keyword">null</span> &amp;&amp; current.right != <span class="keyword">null</span>) &#123;            <span class="comment">// 找到删除节点的后继者</span></span><br><span class="line">            TreeNode successor = getDeleteSuccessor(current);            <span class="keyword">if</span> (current == root) &#123;</span><br><span class="line">                root = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLeftChild) &#123;</span><br><span class="line">                parent.left = successor;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right = successor;</span><br><span class="line">            &#125;</span><br><span class="line">            successor.left = current.left;</span><br><span class="line">        &#125;        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取删除节点的后继者</span></span><br><span class="line"><span class="comment">     *      删除节点的后继者是在其右节点树种最小的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deleteNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getDeleteSuccessor</span><span class="params">(TreeNode deleteNode)</span> </span>&#123;        <span class="comment">// 后继者</span></span><br><span class="line">        TreeNode successor = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode successorParent = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode current = deleteNode.right;            <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            successorParent = successor;</span><br><span class="line">            successor = current;</span><br><span class="line">            current = current.left;</span><br><span class="line">        &#125;        <span class="comment">// 检查后继者(不可能有左节点树)是否有右节点树</span></span><br><span class="line">        <span class="comment">// 如果它有右节点树,则替换后继者位置,加到后继者父亲节点的左节点.</span></span><br><span class="line">        <span class="keyword">if</span> (successor != deleteNode.right) &#123;</span><br><span class="line">            successorParent.left = successor.right;</span><br><span class="line">            successor.right = deleteNode.right;</span><br><span class="line">        &#125;        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toString</span><span class="params">(TreeNode root)</span> </span>&#123;            <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            toString(root.left);</span><br><span class="line">            System.out.print(<span class="string">"value = "</span> + root.value + <span class="string">" -&gt; "</span>);</span><br><span class="line">            toString(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点</span></span><br><span class="line"><span class="comment"> */</span><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> value;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode left;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode right;     <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;        <span class="keyword">this</span>.value = value;</span><br><span class="line">        left  = <span class="keyword">null</span>;</span><br><span class="line">        right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、节点数据结构</strong></p>
<p>首先定义了节点的数据接口，节点分左节点和右节点及本身节点值。如图</p>
<p><a href="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3E6S1OwXpBpXwjL67wGJM37UP3eXkr0JzOiaibuJ0aPfWFFwgygUqTSvtg/0?wx_fmt=png" target="_blank" rel="noopener">图片下载：右键此处另存为可保存此图片</a><br><img src="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3E6S1OwXpBpXwjL67wGJM37UP3eXkr0JzOiaibuJ0aPfWFFwgygUqTSvtg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">value</span>;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode left;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        left  = <span class="literal">null</span>;</span><br><span class="line">        right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、插入</strong></p>
<p>插入，和删除一样会引起二叉搜索树的动态变化。插入相对删处理逻辑相对简单些。如图插入的逻辑：</p>
<p><a href="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3EjRBBEfrBzr4uTqY8UF6iaBibMHicnJpdoM86eOPmvhH6KfzYEB3vdAcGA/0?wx_fmt=png" target="_blank" rel="noopener">图片下载：右键此处另存为可保存此图片</a><br><img src="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3EjRBBEfrBzr4uTqY8UF6iaBibMHicnJpdoM86eOPmvhH6KfzYEB3vdAcGA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>a. 从root节点开始<br>b.如果root为空,root为插入值<br>c.循环:<br>d.如果当前节点值大于插入值,找左节点<br>e.如果当前节点值小于插入值,找右节点</p>
<p><strong>代码对应：</strong></p>
<p><strong>3、查找</strong></p>
<p>其算法复杂度 : O(lgN),树深(N)。如图查找逻辑：</p>
<p><a href="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3EccjvFjXdw8GWfutrmYtXZ34aJl0lp2f4zh8TELBArmm4iaqCQZRAOGQ/0?wx_fmt=png" target="_blank" rel="noopener">图片下载：右键此处另存为可保存此图片</a><br><img src="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3EccjvFjXdw8GWfutrmYtXZ34aJl0lp2f4zh8TELBArmm4iaqCQZRAOGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>a.从root节点开始<br>b.比当前节点值小,则找其左节点<br>c.比当前节点值大,则找其右节点<br>d.与当前节点值相等,查找到返回TRUE<br>e.查找完毕未找到</p>
<p><strong>代码对应：</strong></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">value</span>;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode left;    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode right;    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;       <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">        left  = <span class="literal">null</span>;</span><br><span class="line">        right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、删除</strong></p>
<p>首先找到删除节点，其寻找方法：删除节点的后继者是在其右节点树种最小的节点。如图删除对应逻辑：</p>
<p><a href="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3ExyibegehPiaIy8NxfibCYQTLmTTd3a19y8Pw5allibOLFFgRyztAibtMmGQ/0?wx_fmt=png" target="_blank" rel="noopener">图片下载：右键此处另存为可保存此图片</a><br><img src="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3ExyibegehPiaIy8NxfibCYQTLmTTd3a19y8Pw5allibOLFFgRyztAibtMmGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p><strong>结果为：</strong></p>
<p><a href="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3Efux4241Y2TouI0P35YAyRE5oV4l5vrexTLNk6ZcWcv9CzuY1u6mCJA/0?wx_fmt=png" target="_blank" rel="noopener">图片下载：右键此处另存为可保存此图片</a><br><img src="http://mmbiz.qpic.cn/mmbiz/vpWlcHcJUIDFok3JP8531uIm93mBQa3Efux4241Y2TouI0P35YAyRE5oV4l5vrexTLNk6ZcWcv9CzuY1u6mCJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>a.找到删除节点<br>b.如果删除节点左节点为空 , 右节点也为空;<br>c.如果删除节点只有一个子节点 右节点 或者 左节点<br>d.如果删除节点左右子节点都不为空</p>
<p>代码对应见上面完整代码。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">案例测试代码如下，BinarySearchTreeTest.java</span><br><span class="line">package org.algorithm.tree;<span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright [2015] [Jeff Lee]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉搜索树(BST)测试案例 &#123;@link BinarySearchTree&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by bysocket on 16/7/10.</span></span><br><span class="line"><span class="comment"> */</span><span class="built_in">public</span> <span class="keyword">class</span> BinarySearchTreeTest &#123;    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        BinarySearchTree b = <span class="built_in">new</span> BinarySearchTree();</span><br><span class="line">        b.<span class="keyword">insert</span>(<span class="number">3</span>);b.<span class="keyword">insert</span>(<span class="number">8</span>);b.<span class="keyword">insert</span>(<span class="number">1</span>);b.<span class="keyword">insert</span>(<span class="number">4</span>);b.<span class="keyword">insert</span>(<span class="number">6</span>);</span><br><span class="line">        b.<span class="keyword">insert</span>(<span class="number">2</span>);b.<span class="keyword">insert</span>(<span class="number">10</span>);b.<span class="keyword">insert</span>(<span class="number">9</span>);b.<span class="keyword">insert</span>(<span class="number">20</span>);b.<span class="keyword">insert</span>(<span class="number">25</span>);        // 打印二叉树</span><br><span class="line">        b.toString(b.root);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println();        // 是否存在节点值<span class="number">10</span></span><br><span class="line">        TreeNode node01 = b.<span class="keyword">search</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("是否存在节点值为10 =&gt; " + node01.<span class="keyword">value</span>);        // 是否存在节点值<span class="number">11</span></span><br><span class="line">        TreeNode node02 = b.<span class="keyword">search</span>(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("是否存在节点值为11 =&gt; " + node02);        // 删除节点<span class="number">8</span></span><br><span class="line">        TreeNode node03 = b.<span class="keyword">delete</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("删除节点8 =&gt; " + node03.<span class="keyword">value</span>);</span><br><span class="line">        b.toString(b.root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果如下：</strong></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">value</span> = <span class="number">1</span> -&gt; <span class="keyword">value</span> = <span class="number">2</span> -&gt; <span class="keyword">value</span> = <span class="number">3</span> -&gt; <span class="keyword">value</span> = <span class="number">4</span> -&gt; <span class="keyword">value</span> = <span class="number">6</span> -&gt; <span class="keyword">value</span> = <span class="number">8</span> -&gt; <span class="keyword">value</span> = <span class="number">9</span> -&gt; <span class="keyword">value</span> = <span class="number">10</span> -&gt; <span class="keyword">value</span> = <span class="number">20</span> -&gt; <span class="keyword">value</span> = <span class="number">25</span> -&gt;</span><br><span class="line">是否存在节点值为<span class="number">10</span> =&gt; <span class="number">10</span>是否存在节点值为<span class="number">11</span> =&gt; null</span><br><span class="line">删除节点<span class="number">8</span> =&gt; <span class="number">8</span><span class="keyword">value</span> = <span class="number">1</span> -&gt; <span class="keyword">value</span> = <span class="number">2</span> -&gt; <span class="keyword">value</span> = <span class="number">3</span> -&gt; <span class="keyword">value</span> = <span class="number">4</span> -&gt; <span class="keyword">value</span> = <span class="number">6</span> -&gt; <span class="keyword">value</span> = <span class="number">9</span> -&gt; <span class="keyword">value</span> = <span class="number">10</span> -&gt; <span class="keyword">value</span> = <span class="number">20</span> -&gt; <span class="keyword">value</span> = <span class="number">25</span> -&gt;</span><br></pre></td></tr></table></figure>

<h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a><strong>四、小结</strong></h3><p>与偶尔吃一碗“老坛酸菜牛肉面”一样的味道，品味一个算法，比如BST，的时候，总是那种说不出的味道。</p>
<p>树，二叉树的概念</p>
<p>BST算法</p>
<p>相关代码分享在 Github 主页 <a href="https://github.com/JeffLi1993/algorithm\-core\-learning" target="_blank" rel="noopener">https://github.com/JeffLi1993/algorithm\-core\-learning</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringSecurity-11-SpringSecurity-HTTp认证</title>
    <url>/2020/SpringSecurity-11-SpringSecurity-HTTp%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h2 id="1-HHTP基本认证"><a href="#1-HHTP基本认证" class="headerlink" title="1. HHTP基本认证"></a>1. HHTP基本认证</h2><p>HTTP基本认证是在RFC2616中定义的一种认证模式，其基本认证有4个步骤：</p>
<blockquote>
<p>（1）客户端发起一条没有携带认证信息的请求。<br>（2）服务器返回一条401 Unauthorized响应，并在WWW-Authentication首部说明认证形式，当进<br>行HTTP基本认证时，WWW-Authentication会被设置为Basic realm=”被保护页面”。<br>（3）客户端收到401 Unauthorized 响应后，弹出对话框，询问用户名和密码。当用户完成后，客<br>户端将用户名和密码使用冒号拼接并编码为Base64形式，然后放入请求的Authorization首部发送给服<br>务器。<br>（4）服务器解码得到客户端发来的用户名和密码，并在验证它们是正确的之后，返回客户端请求<br>的报文。</p>
</blockquote>
<p><img src="../images/11.SpringSecurity-HTTp%E8%AE%A4%E8%AF%81/20200316203829.jpg" alt></p>
<p>如果不使用浏览器访问 HTTP 基本认证保护的页面，则自行在请求头中设置 Authorization也是可<br>以的。</p>
<p><strong>优点：</strong>优点是使用简单、没有复杂页面交互。</p>
<p><strong>缺点：</strong>总体而言，HTTP基本认证是一种无状态的认证方式，与表单认证相比，HTTP基本认证是一种基<br>于HTTP层面的认证方式，无法携带session，即无法实现Remember-me功能。另外，用户名和密码在传<br>递时仅做一次简单的Base64编码，几乎等同于明文传输，极易出现密码被窃听和重放攻击等安全性问<br>题，在实际系统开发中很少使用这种方式来进行安全验证。如果有必要，也应使用加密的传输层（例<br>如HTTPS）来保障安全。</p>
]]></content>
  </entry>
  <entry>
    <title>SpringSecurity-10-SpringSecurity-单点登录与CAS</title>
    <url>/2020/SpringSecurity-10-SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/</url>
    <content><![CDATA[<h2 id="2-搭建CAS-Server"><a href="#2-搭建CAS-Server" class="headerlink" title="2. 搭建CAS Server"></a>2. 搭建CAS Server</h2><p>前提示确保自己的jdk已经配置到环境变量中。</p>
<h3 id="2-1-创建SSL"><a href="#2-1-创建SSL" class="headerlink" title="2.1 创建SSL"></a>2.1 创建SSL</h3><p>（1）制作本地密码库</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">keytool <span class="literal">-genkey</span> <span class="literal">-alias</span> casserver <span class="literal">-keyalg</span> RSA <span class="literal">-keystore</span> E:\keystore</span><br></pre></td></tr></table></figure>

<p>可以通过在控制台<code>keytool</code>和<code>keytool -genkeypair -help</code>查看命令含义。上述命令中的含义解释如下：</p>
<p><code>-alias</code>指要处理条目的别名，可根据个人喜好设定</p>
<p><code>-keyalg</code>用来指定证书密钥算法名称，支持DSA和RSA</p>
<p><code>-keystore</code>用来指定密钥库名称，若不存在，则需要新建。</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311145706.jpg" alt></p>
<p>【问题】密钥库口令和密钥口令</p>
<p>如果在生成密钥时，<code>keystore</code>指定的密钥库已经存在，则新生成的密钥就会添加到该密钥库，否则将生成一个新的密钥库用户存放新生成的密钥。所以当指定的密钥库已经存在时，则必须填写指定密钥库的口令；如果密钥库不存在，则可以设定一个新口令。</p>
<p>（2）导出证书和导入证书</p>
<p>因为Spring Security需要接入CAS server，作为客户端，在与HTTPS服务进行通信时，不得不考虑SSL证书的问题。我们只需要将证书导入JDK中即可。导入的位置<code>jdk安装的位置/jre/lib/security/cacerts</code>中。</p>
<ul>
<li>首先从密钥库中导出证书</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">keytool <span class="literal">-export</span> <span class="literal">-trustcacerts</span> <span class="literal">-alias</span> casserver <span class="operator">-file</span> E:\cas.cer <span class="literal">-keystore</span> E:\keystore</span><br></pre></td></tr></table></figure>

<p>从E:\keystore这个密钥库中，导出别名为casserver的证书到E:\cas.cer文件中</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311151329.jpg" alt></p>
<ul>
<li>导入证书到cacerts文件中</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">keytool <span class="literal">-import</span> <span class="literal">-trustcacerts</span> <span class="literal">-alias</span> casserver <span class="operator">-file</span> E:\cas.cer <span class="literal">-keystore</span> <span class="string">"E:\javatool\Java\jdk1.8.0_231\jre\lib\security\cacerts"</span></span><br></pre></td></tr></table></figure>

<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311151610.jpg" alt></p>
<p>输入密钥口令：changeit（这里是cacerts的默认口令）</p>
<h3 id="2-2-下载Cas-Server"><a href="#2-2-下载Cas-Server" class="headerlink" title="2.2 下载Cas Server"></a>2.2 下载Cas Server</h3><p>访问 <a href="https://github.com/apereo/cas-overlay-template" target="_blank" rel="noopener">https://github.com/apereo/cas-overlay-template</a> 由于默认的版本为master，并且使用的是jdk11，因此选择5.2版本下载。</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311142659.jpg" alt></p>
<p>（注意：在github页面上有相关使用说明，请先阅读一遍。）</p>
<p>（1）首先用<code>terminal</code>进入项目文件夹，使用如下命令（注意在linux环境下使用<code>build.sh</code>，windows下使用<code>build.cmd</code>），将项目打包</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">build.<span class="keyword">cmd</span><span class="bash"> package</span></span><br></pre></td></tr></table></figure>

<p>将打包后的文件<code>cas.war</code>中<code>WEB-INF\classess</code>中的<code>application.properties</code>复制一份。</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311205507.jpg" alt></p>
<p>（2）在项目文件夹中创建目录<code>src\main\resources</code>，并将复制的<code>application.properties</code>文件和前面生成的<code>keystore</code>保存到该目录中。</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311205940.jpg" alt></p>
<p>修改<code>application.properties</code></p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311210141.jpg" alt></p>
<p>（3）启动项目</p>
<p>启动CAS server可以有多中方式，有很多人使用的是将生成的war包放在tomcat中；还有使用maven构建；还有以<code>springboot</code>方式，前面说的那个github页面有说明。这是使用的最简便的springboot方式。</p>
<p>使用命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">build.<span class="keyword">cmd</span><span class="bash"> bootrun</span></span><br></pre></td></tr></table></figure>

<p>启动过程中存在报错，可以忽略。当现实<code>ready</code>大标志时，表示启动成功</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311210915.jpg" alt></p>
<p>（4）访问Cas server</p>
<p>由于在配置密钥库时设定了域名为<code>cas.xfcy.cn</code>，所以在这需要到host文件中设置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">csa</span><span class="selector-class">.xfcy</span><span class="selector-class">.cn</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">cient</span><span class="selector-class">.cas</span><span class="selector-class">.xfcy</span><span class="selector-class">.cn</span>  # 方面后期测试单点登录</span><br></pre></td></tr></table></figure>

<p>在浏览器中访问<code>https://cas.xfcy.cn:8443/cas</code></p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311211304.jpg" alt></p>
<p>其中默认账号名为 <code>casuser</code> 密码为<code>Mellon</code>，在application.properties中有说明。</p>
<p><img src="../../images/SpringSecurity/10.SpringSecurity-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B8%8ECAS/20200311211435.jpg" alt></p>
]]></content>
  </entry>
  <entry>
    <title>SpringSecurity-9-SpringSecurity-跨域请求伪造的防护</title>
    <url>/2020/SpringSecurity-9-SpringSecurity-%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E7%9A%84%E9%98%B2%E6%8A%A4/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>​        跨域请求伪造（<code>Cross Site Request Forgery</code>，简称<code>CSRF</code>）是一种利用用户带登录态的cookie进行安全操作的攻击方式。 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p>
<h3 id="1-1-CSRF攻击过程"><a href="#1-1-CSRF攻击过程" class="headerlink" title="1.1 CSRF攻击过程"></a>1.1 CSRF攻击过程</h3><p>1、<code>用户C</code>打开浏览器，访问受信任<code>网站A</code>，输入用户名和密码请求登录<code>网站A</code>；</p>
<p>2、在用户信息通过验证后，<code>网站A</code>产生Cookie信息并返回给浏览器，此时用户登录<code>网站A</code>成功，可以正常发送请求到<code>网站A</code>；</p>
<p>3、用户未退出<code>网站A</code>之前，在同一浏览器中，打开一个TAB页访问<code>网站B</code>；</p>
<p>4、<code>网站B</code>接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方<code>站点A</code></p>
<p>5、浏览器在接收到这些攻击性代码后，根据<code>网站B</code> 的请求，在用户不知情的情况下携带Cookie信息，向<code>网站A</code> 发出请求。<code>网站A</code>并不知道该请求其实是由<code>网站B</code>发起的，所以会根据<code>用户C</code>的Cookie信息以<code>用户C</code>的权限处理该请求，导致来自网站B 的恶意代码被执行。</p>
<p>（这篇博客中有一个实例，可以参考：<a href="https://blog.csdn.net/xiaoxinshuaiga/article/details/80766369" target="_blank" rel="noopener">CSRF攻击与防御</a>）</p>
<h3 id="1-2-CSRF漏洞检测"><a href="#1-2-CSRF漏洞检测" class="headerlink" title="1.2 CSRF漏洞检测"></a>1.2 CSRF漏洞检测</h3><p>​        检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p>
<p>​         随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如<code>CSRFTester</code>，<code>CSRF Request Builder</code>等。 以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p>
<h3 id="1-3-防御CSRF攻击"><a href="#1-3-防御CSRF攻击" class="headerlink" title="1.3 防御CSRF攻击"></a>1.3 防御CSRF攻击</h3><p>目前防御CSRF攻击的策略主要有如下3种方式：</p>
<blockquote>
<ul>
<li>验证<code>HTTP Referer</code>字段</li>
<li>在请求地址中添加token并验证</li>
<li>在HTTP头中自定义属性并验证</li>
</ul>
</blockquote>
<p>（1）验证<code>HTTP Referer</code>字段</p>
<p>假设存在某个<code>用户A</code>要进行转账操作。如果转账之前，其当前的地址为<code>http://bank.example</code>，而执行转账时地址为<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。很明显，这里的<code>Referer</code>便是当前地址。在一个银行系统中，可以认为这是银行自己的系统，因此无需担心CSRF攻击。但是如果存在一个黑客，他有一个网站<code>http://heike.example</code>，<code>用户A</code>通过黑客的网站向银行系统发送请求，由于黑客网站中存在用户信息，所以银行会认为是<code>用户A</code>的正常登录，从而造成黑客的入侵。</p>
<p>如果银行系统在最后的操作中对<code>Referer</code>部分添加控制，如果发现该值是银行内部的，则直接放行，否则将拦截，那么就能够很好处理上述问题的发生，这也就是该方法的原理。</p>
<p><strong>问题</strong>：上述方法同样存在问题，那就是首先<code>Referer</code>的值让浏览器保存，无法确定浏览器是否能够安全保证（比如在IE6中，就可以对<code>Referer</code>修改）；另外有些组织担心<code>Referer</code>会泄露个人信息，因此用户可以设置在发送请求的同时不提供<code>Referer</code>值，这样对于合法的网站也会因为没有<code>Referer</code>值而拒绝用户访问。</p>
<p>（2）在请求地址中添加 token 并验证</p>
<p> CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。而对于" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。而对于</a> POST 请求来说，要在 form 的最后加上<code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<p>（3）在 HTTP 头中自定义属性并验证</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在Spring Security中，<code>CsrfToken</code>是一个用于描述Token值，以及验证时应当获取哪个请求参数或者请求头字段的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CsrfToken</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取http头部</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getHeaderName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取必须包含token的参数名称</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getParameterName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取token的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">getToken</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CsrfTokenRepository</code>则定义了如何生成、保存以及加载<code>CsrfToken</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 产生CsrfToken</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">CsrfToken <span class="title">generateToken</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 保存CsrfToken，如果CsrfToken为null，则表示删除它</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">saveToken</span><span class="params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">         HttpServletResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从HttpServeletResponse中加载CsrfToken</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">CsrfToken <span class="title">loadToken</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在默认情况下，Spring Security加载的是一个<code>HttpSessionCsrfTokenRepository</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionCsrfTokenRepository</span> <span class="keyword">implements</span> <span class="title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CSRF_PARAMETER_NAME = <span class="string">"_csrf"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CSRF_HEADER_NAME = <span class="string">"X-CSRF-TOKEN"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CSRF_TOKEN_ATTR_NAME = HttpSessionCsrfTokenRepository<span class="class">.<span class="keyword">class</span></span></span><br><span class="line">			.getName().concat(".CSRF_TOKEN");</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String parameterName = DEFAULT_CSRF_PARAMETER_NAME;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String headerName = DEFAULT_CSRF_HEADER_NAME;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String sessionAttributeName = DEFAULT_CSRF_TOKEN_ATTR_NAME;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 保存CsrfToken</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveToken</span><span class="params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">			HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">				session.removeAttribute(<span class="keyword">this</span>.sessionAttributeName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			HttpSession session = request.getSession();</span><br><span class="line">            <span class="comment">// 将CsrfToken存储到session中</span></span><br><span class="line">			session.setAttribute(<span class="keyword">this</span>.sessionAttributeName, token);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CsrfToken <span class="title">loadToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (CsrfToken) session.getAttribute(<span class="keyword">this</span>.sessionAttributeName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CsrfToken <span class="title">generateToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DefaultCsrfToken(<span class="keyword">this</span>.headerName, <span class="keyword">this</span>.parameterName,</span><br><span class="line">				createNewToken());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameterName</span><span class="params">(String parameterName)</span> </span>&#123;</span><br><span class="line">		Assert.hasLength(parameterName, <span class="string">"parameterName cannot be null or empty"</span>);</span><br><span class="line">		<span class="keyword">this</span>.parameterName = parameterName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeaderName</span><span class="params">(String headerName)</span> </span>&#123;</span><br><span class="line">		Assert.hasLength(headerName, <span class="string">"headerName cannot be null or empty"</span>);</span><br><span class="line">		<span class="keyword">this</span>.headerName = headerName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionAttributeName</span><span class="params">(String sessionAttributeName)</span> </span>&#123;</span><br><span class="line">		Assert.hasLength(sessionAttributeName,</span><br><span class="line">				<span class="string">"sessionAttributename cannot be null or empty"</span>);</span><br><span class="line">		<span class="keyword">this</span>.sessionAttributeName = sessionAttributeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">createNewToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式将<code>CsrfToken</code>存储在<code>HttpSession</code>中。并指定前端把<code>CsrfToken</code>值放在名为<code>_csrf</code>的请求参数或名为<code>X-CSRF-TOKEN</code>的请求头字段里（可以调用相应的设置方法来重新设定）。校验时，通过对比<code>HttpSession</code>内存储的<code>CsrfToken</code>值与前端携带的<code>CsrfToken</code>值是否一致，便能断定本次请求是否为<code>CSRF</code>攻击。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieCsrfTokenRepository</span> <span class="keyword">implements</span> <span class="title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CSRF_COOKIE_NAME = <span class="string">"XSRF-TOKEN"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CSRF_PARAMETER_NAME = <span class="string">"_csrf"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CSRF_HEADER_NAME = <span class="string">"X-XSRF-TOKEN"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String parameterName = DEFAULT_CSRF_PARAMETER_NAME;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String headerName = DEFAULT_CSRF_HEADER_NAME;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String cookieName = DEFAULT_CSRF_COOKIE_NAME;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Method setHttpOnlyMethod;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> cookieHttpOnly;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String cookiePath;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CookieCsrfTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      this.setHttpOnlyMethod = ReflectionUtils.findMethod(Cookie.class, "setHttpOnly", boolean.class);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.setHttpOnlyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.cookieHttpOnly = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CsrfToken <span class="title">generateToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultCsrfToken(<span class="keyword">this</span>.headerName, <span class="keyword">this</span>.parameterName,</span><br><span class="line">            createNewToken());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveToken</span><span class="params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">         HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">      String tokenValue = token == <span class="keyword">null</span> ? <span class="string">""</span> : token.getToken();</span><br><span class="line">      <span class="comment">// 将CsrfToken存储在用户的cookie内</span></span><br><span class="line">       Cookie cookie = <span class="keyword">new</span> Cookie(<span class="keyword">this</span>.cookieName, tokenValue);</span><br><span class="line">      cookie.setSecure(request.isSecure());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.cookiePath != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.cookiePath.isEmpty()) &#123;</span><br><span class="line">            cookie.setPath(<span class="keyword">this</span>.cookiePath);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cookie.setPath(<span class="keyword">this</span>.getRequestContext(request));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">         cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         cookie.setMaxAge(-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cookieHttpOnly &amp;&amp; setHttpOnlyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ReflectionUtils.invokeMethod(setHttpOnlyMethod, cookie, Boolean.TRUE);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      response.addCookie(cookie);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>CsrfToken</code>存储在用户的cookie中的作用：</p>
<ul>
<li>减少了服务器<code>HttpSession</code>存储的内存消耗</li>
<li>用<code>cookie</code>存储<code>CsrfToken</code>，前端可以用JS读取（只需要设置该cookie的HttpOnly为false即可），而不用服务器端注入参数，在使用方式上更加灵活。</li>
</ul>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-8-SpringSecurity-跨域与CORS</title>
    <url>/2020/SpringSecurity-8-SpringSecurity-%E8%B7%A8%E5%9F%9F%E4%B8%8ECORS/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>跨域是一种浏览器同源安全策略，即浏览器单方面限制脚本的跨域访问。如何确定是否为跨域呢？</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">只要请求的<span class="built_in">URL</span>与所在页面的<span class="built_in">URL</span>首部不同，则就会产生跨域</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<ul>
<li>在<code>http://a.baidu.com</code>下访问<code>https://a.baidu.com</code>资源会形成协议跨域。</li>
<li>在<code>a.baidu.com</code>下访问<code>b.baidu.com</code>资源会形成主机跨域。</li>
<li>在<code>a.baidu.com:80</code>下访问<code>a.baidu.com:8080</code>资源会形成端口跨域</li>
</ul>
<p>其中URL首部是指</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.location</span><span class="selector-class">.protocol</span>+<span class="selector-tag">window</span><span class="selector-class">.location</span><span class="selector-class">.host</span></span><br></pre></td></tr></table></figure>

<p>因此协议、域名以及端口号的不同都会产生跨域。</p>
<p>解决跨域访问的方法很多，比如JSONP，nginx和CORS等，但是JSONP由于只能支持GET方式访问，所以这里不做研究。下面研究CORS。</p>
<h2 id="2-实现跨域之CORS"><a href="#2-实现跨域之CORS" class="headerlink" title="2. 实现跨域之CORS"></a>2. 实现跨域之CORS</h2><p>在学习这个部分之前，可以先学习下Spring Security和Spring boot对cors的支持。</p>
<blockquote>
<p>Spring Security：<a href="https://docs.spring.io/spring-security/site/docs/5.0.14.RELEASE/reference/htmlsingle/#cors" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.14.RELEASE/reference/htmlsingle/#cors</a></p>
<p>Spring Boot：<a href="https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-cors" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-cors</a></p>
</blockquote>
<h3 id="2-1-CORS的产生"><a href="#2-1-CORS的产生" class="headerlink" title="2.1 CORS的产生"></a>2.1 CORS的产生</h3><p>下面将创建一个SpringBoot应用来说明</p>
<p>（1）创建<code>UserController</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程安全的Map</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, User&gt; users = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Integer, User&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"users"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getUserList</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;(users.values());</span><br><span class="line">            r.setResult(userList);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）实体类<code>User</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date ctm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get/set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）工具类<code>JsonResult</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonResult</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object result = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// get/set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）静态页面<code>test.html</code>（放在<code>static</code>目录下）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src="https://cdn.bootcss.com/jquery/2.1.0/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">        <span class="function">function <span class="title">crosRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                url:<span class="string">'http://localhost:8081/users'</span>,</span><br><span class="line">                type:<span class="string">'get'</span>,</span><br><span class="line">                dataType:<span class="string">'json'</span>,</span><br><span class="line">                success:function(data)&#123;</span><br><span class="line">                    console.log(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button onclick="crosRequest()"&gt;请求跨域资源&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>其余配置参考：</p>
<p>（5）运行项目</p>
<p>将这个服务分别以8080和8081启动。前者直接启动即可；后者在前者启动后，首先在application.yml中修改server.port=8081。然后依次点击<code>Run</code>——&gt;<code>Edit Configurations</code>，在界面的右上角取消勾选<code>Single instance only</code></p>
<p><img src="../images/8.SpringSecurity-%E8%B7%A8%E5%9F%9F%E4%B8%8ECORS/20200308182006.jpg" alt></p>
<p>然后访问<a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a> 我们知道在<code>test.html</code>通过ajax请求的端口是8081端口，所以按照前面的学习可以知道，明显出现了跨域请求。</p>
<p><img src="../images/8.SpringSecurity-%E8%B7%A8%E5%9F%9F%E4%B8%8ECORS/20200308190035.jpg" alt></p>
<h3 id="2-2-局部解决跨域请求"><a href="#2-2-局部解决跨域请求" class="headerlink" title="2.2 局部解决跨域请求"></a>2.2 局部解决跨域请求</h3><p>在SpringMVC中，我们学习到了在一个controller上添加注解<code>@CrossOrigin</code>便能够解决单个controller请求的跨域，比如下面这样的配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(</span><br><span class="line">    origins = <span class="string">"http://localhost:8080"</span>,</span><br><span class="line">    maxAge = <span class="number">3600</span>,</span><br><span class="line">    methods = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程安全的Map</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Integer, User&gt; users = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Integer, User&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// @CrossOrigin(</span></span><br><span class="line">    <span class="comment">//         origins = "http://localhost:8080",</span></span><br><span class="line">    <span class="comment">//         maxAge = 3600,</span></span><br><span class="line">    <span class="comment">//         methods = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line">    <span class="comment">// )</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"users"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;JsonResult&gt; <span class="title">getUserList</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        JsonResult r = <span class="keyword">new</span> JsonResult();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;(users.values());</span><br><span class="line">            r.setResult(userList);</span><br><span class="line">            r.setStatus(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            r.setResult(e.getClass().getName() + <span class="string">":"</span> + e.getMessage());</span><br><span class="line">            r.setStatus(<span class="string">"error"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在整个Controller上配置，则起作用的范围在整个Controller上；单个方法上配置，则仅在这个方法上起作用。启动项目，重复前面的运行方式。</p>
<p><img src="../images/8.SpringSecurity-%E8%B7%A8%E5%9F%9F%E4%B8%8ECORS/20200308190933.jpg" alt></p>
<h3 id="2-3-全局解决跨域"><a href="#2-3-全局解决跨域" class="headerlink" title="2.3 全局解决跨域"></a>2.3 全局解决跨域</h3><p>在Springboot中提供了全军解决跨域问题的方法，可以参考官方文档。</p>
<p>另外添加一个配置类<code>CORSConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CORSConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//registry.addMapping("/api/**");</span></span><br><span class="line">                registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                        .allowedOrigins(<span class="string">"http://localhost:8080"</span>)</span><br><span class="line">                        .allowedMethods(<span class="string">"GET"</span>,<span class="string">"POST"</span>,<span class="string">"DELETE"</span>,<span class="string">"PUT"</span>,<span class="string">"OPTIONS"</span>)</span><br><span class="line">                        .allowCredentials(<span class="keyword">false</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/8.SpringSecurity-%E8%B7%A8%E5%9F%9F%E4%B8%8ECORS/20200308190933.jpg" alt></p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>以上便是对于SpringSecurity中关于CORS的学习。</p>
<p>参考资料</p>
<ul>
<li><p>Spring Security实战</p>
</li>
<li><p><a href="https://blog.csdn.net/saytime/article/details/74937204" target="_blank" rel="noopener">SpringBoot（六）：SpringBoot使用CROS解决跨域问题</a></p>
</li>
<li><p>SpringBoot官方文档</p>
</li>
<li><p>SpringSecurity官方文档</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-7-SpringSecurity-密码设置</title>
    <url>/2020/SpringSecurity-7-SpringSecurity-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>2011年12月，国内某开发者社区网站被黑客“拖库”,600多万个密码明文存储的用户账号被公开，大量用户直接面临数据隐私泄露和数据安全的双重威胁，因此对密码加密就十分重要。早期通过使用md5加密算法，但是容易出现彩虹表问题，因此后期产生了不同的加密算法，其中作为代表性的便是<code>BCrypt</code>，这个也是Spring Security推荐的加密算法。如果对加密历史感兴趣可以参考相关资料。</p>
<h2 id="2-密码加密"><a href="#2-密码加密" class="headerlink" title="2. 密码加密"></a>2. 密码加密</h2><p>在Spring Security中对密码加密，需要实现<code>PasswordEncoder</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 对原始密码加密</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 原始密码和数据库中的密码是否匹配</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中在Spring Security中已经实现了大多数密码的实现类</p>
<p><img src="../images/7.SpringSecurity-%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE/20200308110126.jpg" alt></p>
<h3 id="2-1-注册时对密码加密"><a href="#2-1-注册时对密码加密" class="headerlink" title="2.1 注册时对密码加密"></a>2.1 注册时对密码加密</h3><p>前面我们知道，对原始数据加密需要使用<code>encode</code>方法。</p>
<p>（1）注册一个passwordEncode的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder(); <span class="comment">// 创建的是子类的实例,主要BCryptPasswordEncoder可以设置长度，可以查看源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建一个controller，其中存在保存用户信息的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        user.setPassword(passwordEncoder.encode(user.getPassword()))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就对明文密码进行了加密。</p>
<h3 id="2-2-登录时查询密码是否匹配"><a href="#2-2-登录时查询密码是否匹配" class="headerlink" title="2.2 登录时查询密码是否匹配"></a>2.2 登录时查询密码是否匹配</h3><p>对于密码是否匹配，Spring Security默认调用<code>matches</code>方法。</p>
<h2 id="3-自定义加密"><a href="#3-自定义加密" class="headerlink" title="3. 自定义加密"></a>3. 自定义加密</h2><p>自定义加密只需要实现<code>PasswordEncoder</code>接口即可。这里需要实现将数据库中未被加密的密码加密后再验证。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPasswordEncoder</span> <span class="keyword">extends</span> <span class="title">BCryptPasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MyPasswordEncoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern BCRYPT_PATTERN = Pattern.compile(<span class="string">"\\A\\$2a?\\$\\d\\d\\$[./0-9A-Za-z]&#123;53&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较用户输入的密码和数据库存储的密码是否一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawPassword 用户输入的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encodedPassword 存储的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"待校验的密码："</span>+rawPassword.toString());</span><br><span class="line">        LOGGER.info(<span class="string">"存储的密码："</span>+encodedPassword);</span><br><span class="line">        <span class="keyword">if</span> (!BCRYPT_PATTERN.matcher(encodedPassword).matches())&#123;</span><br><span class="line">            <span class="comment">// 如果数据库中的密码不是Bcrypt密文，则先加密</span></span><br><span class="line">            encodedPassword = encode(encodedPassword);</span><br><span class="line">            LOGGER.info(<span class="string">"加密后的密码为："</span>+encodedPassword);</span><br><span class="line">            <span class="comment">// 实际后面还可以添加保存到数据库中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是的，则直接比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.matches(rawPassword, encodedPassword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-6-SpringSecurity-会话管理</title>
    <url>/2020/SpringSecurity-6-SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>（1）HTTP无状态？怎样解决？</p>
<p>通常我们知道HTTP本身是无状态的，用户和服务器交互过程中，每个请求之间都没有关联性，这样就意味着用户的访问没有身份记录，站点也无法为用户提供个性化服务。</p>
<p><strong>解决：</strong><code>session</code>的诞生解决了这个问题，服务器和用户约定每个请求都携带一个id类的信息，从而让不同请求之间有了关联，而id又可以很方便地绑定具体用户，所以我们可以把不同请求归类到同一用户。但是仅仅使用session增加了服务器的负担，将<code>cookie</code>作为载体，将得到更好的效果。</p>
<p><strong>原理：</strong><span style="color:red">当用户首次访问系统时，系统会为该用户生成一个sessionId，并添加到cookie，在该用户的会话期内，每个请求都自动携带该因此系统可以很轻易地识别出这是来自哪个用户的请求。</span></p>
<p>（2）固定会话攻击？</p>
<p><strong>产生的原因：</strong>前面我们知道为了提供更好的体验，所以出现了session+cookie的组合。但是有时候用户会在浏览器中禁用cookie，因此提出了在url地址后面添加jession，例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://test.com;jessionid=xxx</span><br></pre></td></tr></table></figure>

<p>虽然上述方式能够带来方便，当时却带了另一个问题——个人信息安全。因为黑客很容易获取到这个sessionId，从而在不需要用户账户密码的情况下访问系统。这就是典型的固定会话攻击问题。</p>
<p>本节主要学习如下内容：</p>
<p>（1）防御固定会话攻击（了解）</p>
<p>（2）<code>session</code>超时处理</p>
<p>（3）<code>session</code>并发控制</p>
<p>（4）集群<code>session</code>管理</p>
<h2 id="2-防御固定会话攻击"><a href="#2-防御固定会话攻击" class="headerlink" title="2. 防御固定会话攻击"></a>2. 防御固定会话攻击</h2><h3 id="2-1-原理分析"><a href="#2-1-原理分析" class="headerlink" title="2.1 原理分析"></a>2.1 原理分析</h3><p>在Spring Security中对于开启防御固定会话攻击很简单，只需要配置如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">            .sessionManagement() <span class="comment">// 开启防御固定会话攻击</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置，其实在Spring Security已经默认配置。我们不妨看一下<code>WebSecurityConfigurerAdapter</code>的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurerAdapter</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">		<span class="title">WebSecurityConfigurer</span>&lt;<span class="title">WebSecurity</span>&gt; </span>&#123;	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> disableDefaults;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">WebSecurityConfigurerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 有参构造，所以我们可以知道创建这个实例后，disableDefaults为false</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">WebSecurityConfigurerAdapter</span><span class="params">(<span class="keyword">boolean</span> disableDefaults)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.disableDefaults = disableDefaults;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个HTTPSecurity</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 如http已经存在，则不需要创建，直接返回即可</span></span><br><span class="line">    	<span class="keyword">if</span> (http != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> http;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 创建一个http</span></span><br><span class="line">		http = <span class="keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">				sharedObjects);</span><br><span class="line">    	<span class="comment">// 由于disableDefaults为false，所以会进入</span></span><br><span class="line">		<span class="keyword">if</span> (!disableDefaults) &#123;</span><br><span class="line">			<span class="comment">// @formatter:off</span></span><br><span class="line">			http</span><br><span class="line">				.csrf().and()</span><br><span class="line">				.addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class="line">				.exceptionHandling().and()</span><br><span class="line">				.headers().and()</span><br><span class="line">                <span class="comment">// 默认配置了sessionManagement</span></span><br><span class="line">				.sessionManagement().and()</span><br><span class="line">				.securityContext().and()</span><br><span class="line">				.requestCache().and()</span><br><span class="line">				.anonymous().and()</span><br><span class="line">				.servletApi().and()</span><br><span class="line">				.apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">				.logout();</span><br><span class="line">			<span class="comment">// ....</span></span><br><span class="line">		&#125;</span><br><span class="line">		configure(http);</span><br><span class="line">		<span class="keyword">return</span> http;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现在创建HttpSecurity时，实际上是配置了<code>sessionManagement()</code></p>
<p><code>sessionManagement</code>是一个会话管理的配置器，其中，防御会话固定攻击的策略有四种：</p>
<ul>
<li><code>none</code>：不做任何变动，登录之后沿用旧session</li>
<li><code>newSession</code> ：登录之后创建一个新的session</li>
<li><code>migrateSession</code>：登录之后创建一个session，并将旧的session中的数据赋值过来</li>
<li><code>changeSessionId</code>：不创建新的会话，而是使用由容器提供的会话固定保护。</li>
</ul>
<p>在Spring Security5中后默认优先使用的策略是<code>changeSessionId</code>，如果发生异常的情况下才会使用<code>migrateSession</code>方式。而在Spring Security4中默认使用的<code>migrateSession</code>。看一下源码，我们知道<code>sessionManagement</code>是由<code>SessionManagementConfigurer</code>配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionManagementConfigurer</span>&lt;<span class="title">H</span> <span class="keyword">extends</span> <span class="title">HttpSecurityBuilder</span>&lt;<span class="title">H</span>&gt;&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">AbstractHttpConfigurer</span>&lt;<span class="title">SessionManagementConfigurer</span>&lt;<span class="title">H</span>&gt;, <span class="title">H</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SessionAuthenticationStrategy DEFAULT_SESSION_FIXATION_STRATEGY = createDefaultSessionFixationProtectionStrategy();</span><br><span class="line">	<span class="keyword">private</span> SessionAuthenticationStrategy sessionFixationAuthenticationStrategy = <span class="keyword">this</span>.DEFAULT_SESSION_FIXATION_STRATEGY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SessionAuthenticationStrategy <span class="title">createDefaultSessionFixationProtectionStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 默认有限使用ChangeSessionId</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ChangeSessionIdAuthenticationStrategy();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// 当发生异常时使用migrateSession</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SessionFixationProtectionStrategy();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们可以查看一下官方文档也有说明</p>
<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/20200305202847.png" alt></p>
<h3 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2 具体实现"></a>2.2 具体实现</h3><p>可以自定义设置防御策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       http.authorizeRequests()</span><br><span class="line">               .antMatchers(<span class="string">"/api/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">//对"/admin"的请求判断是否有“ADMIN”权限</span></span><br><span class="line">               .antMatchers(<span class="string">"/api/user/**"</span>).hasRole(<span class="string">"USER"</span>) <span class="comment">//对"/user/**"下的请求判断是否有“USER”权限</span></span><br><span class="line">               .antMatchers(<span class="string">"/api/app/**"</span>).permitAll() <span class="comment">//对"/app/**"下的请求判断是否有“APP”权限</span></span><br><span class="line">               .anyRequest().authenticated() <span class="comment">// 对所有请求都需要验证</span></span><br><span class="line">               .and()</span><br><span class="line">           .formLogin()</span><br><span class="line">               .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">               <span class="comment">//.failureHandler(new MyAuthenticationFailureHandler()) // 登录失败后的处理</span></span><br><span class="line">               .and()</span><br><span class="line">           .csrf()</span><br><span class="line">               .disable()</span><br><span class="line">           .sessionManagement()</span><br><span class="line">               .sessionFixation().migrateSession() <span class="comment">// 为默认的策略即可，不建议修改</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面虽然配置了防御策略，但是并不推荐配置该项，使用默认即可。</p>
<h2 id="3-会话过期"><a href="#3-会话过期" class="headerlink" title="3. 会话过期"></a>3. 会话过期</h2><h3 id="3-1-原理分析"><a href="#3-1-原理分析" class="headerlink" title="3.1 原理分析"></a>3.1 原理分析</h3><p>（1）超时时间设置</p>
<p>我们通常知道会话是由时间限制的，当超过这个时间限制后，会话是无效的。在基于springboot的方式下，可以在application.yml下配置会话有效时间</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">session:</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">PT30S</span>  <span class="comment"># 设置时间为30s，但是在SpringBoot中默认最小为1分钟</span></span><br></pre></td></tr></table></figure>

<p>关于时间配置使用的是Jdk8中提供的<code>Duration</code>类，参考：<a href="https://www.cnblogs.com/ergexy/p/9684933.html" target="_blank" rel="noopener">SpringBoot session超时的问题</a></p>
<blockquote>
<ul>
<li>默认为正，负以<code>-</code>开头</li>
<li>紧接着<code>p</code></li>
<li><code>D</code>表示天</li>
<li><code>T</code>表示天和小时之间的分隔符</li>
<li><code>H</code>表示小时</li>
<li><code>M</code>表示分钟</li>
<li><code>S</code>表示秒</li>
</ul>
</blockquote>
<p>（2）设置超时策略</p>
<p>通常发生超时后我们可以选择两个解决方法：设置跳转链接和指定超时策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sessionManagement()</span><br><span class="line">    <span class="comment">// .sessionFixation().migrateSession() // 为默认的策略即可，不建议修改</span></span><br><span class="line">    <span class="comment">// .invalidSessionUrl("/session/invalid") // 会话过期时跳 转到某个URL。</span></span><br><span class="line">    .invalidSessionStrategy(<span class="keyword">new</span> MyInvalidSessionStrategy()) <span class="comment">// 自定义session过期策略 （和上面的跳转url，二选一）</span></span><br></pre></td></tr></table></figure>

<p><strong>设置跳转链接：</strong>只需要配置一个controller即可（省略）</p>
<p><strong>设置超时策略：</strong>需要创建一个<code>MyInvalidSessionStrategy</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的过期策略需要实现InvalidSessionStrategy接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvalidSessionStrategy</span> <span class="keyword">implements</span> <span class="title">InvalidSessionStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInvalidSessionDetected</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">"session无效"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>实现一个当出现超时后给出提示功能</p>
<p>（1）配置超时时间（上面已经配置，省略）</p>
<p>（2）在configure中配置使用会话过期策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       http.authorizeRequests()</span><br><span class="line">               .antMatchers(<span class="string">"/api/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">//对"/admin"的请求判断是否有“ADMIN”权限</span></span><br><span class="line">               .antMatchers(<span class="string">"/api/user/**"</span>).hasRole(<span class="string">"USER"</span>) <span class="comment">//对"/user/**"下的请求判断是否有“USER”权限</span></span><br><span class="line">               .antMatchers(<span class="string">"/api/app/**"</span>).permitAll() <span class="comment">//对"/app/**"下的请求判断是否有“APP”权限</span></span><br><span class="line">               .anyRequest().authenticated() <span class="comment">// 对所有请求都需要验证</span></span><br><span class="line">               .and()</span><br><span class="line">           .formLogin()</span><br><span class="line">               .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">               <span class="comment">//.failureHandler(new MyAuthenticationFailureHandler()) // 登录失败后的处理</span></span><br><span class="line">               .and()</span><br><span class="line">           .csrf()</span><br><span class="line">               .disable()</span><br><span class="line">           .sessionManagement()</span><br><span class="line">               <span class="comment">// .sessionFixation().migrateSession() // 为默认的策略即可，不建议修改</span></span><br><span class="line">               <span class="comment">// .invalidSessionUrl("/session/invalid") // 会话过期时跳 转到某个URL。</span></span><br><span class="line">               .invalidSessionStrategy(<span class="keyword">new</span> MyInvalidSessionStrategy()) </span><br><span class="line">       ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>（3）MyInvalidSessionStrategy类如上（省略）</p>
<p>（4）启动项目</p>
<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Animation.gif" alt></p>
<h2 id="4-并发控制"><a href="#4-并发控制" class="headerlink" title="4. 并发控制"></a>4. 并发控制</h2><h3 id="4-1-并发会话数控制"><a href="#4-1-并发会话数控制" class="headerlink" title="4.1 并发会话数控制"></a>4.1 并发会话数控制</h3><p>并发控制，可以用来设置当个用户同时在线的最大会话数。</p>
<p>设置并发的最大数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sessionManagement()</span><br><span class="line">    <span class="comment">// .sessionFixation().migrateSession() // 为默认的策略即可，不建议修改</span></span><br><span class="line">    <span class="comment">// .invalidSessionUrl("/session/invalid") // 会话无效时跳 转到某个URL。</span></span><br><span class="line">    .invalidSessionStrategy(<span class="keyword">new</span> MyInvalidSessionStrategy()) <span class="comment">// 自定义session无效策略 （和上面的跳转url，二选一）</span></span><br><span class="line">    .maximumSessions(<span class="number">1</span>) <span class="comment">// 设置单个用户的最大并发数</span></span><br></pre></td></tr></table></figure>

<p>上面设置了并发数为1，在默认情况下，如果有人使用当前用户的账号和密码登录，新登录用户的会话会踢掉就的会话。</p>
<p>（2）在<code>ConcurrentSessionControlAuthenticationStrategy</code>类中给出了原因</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthentication</span><span class="params">(Authentication authentication,</span></span></span><br><span class="line"><span class="function"><span class="params">                             HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取session的个数</span></span><br><span class="line">    <span class="keyword">int</span> sessionCount = sessions.size();</span><br><span class="line">    <span class="comment">// 获取允许的最大个数</span></span><br><span class="line">    <span class="keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果当前存在的会话数等于允许的最大会话数</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCount == allowedSessions) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SessionInformation si : sessions) &#123;</span><br><span class="line">                <span class="comment">// 如果当前验证的会话并非新对话，则不做任何处理</span></span><br><span class="line">                <span class="keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 否则进行策略判断</span></span><br><span class="line">    allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">allowableSessionsExceeded</span><span class="params">(List&lt;SessionInformation&gt; sessions,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">int</span> allowableSessions, SessionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SessionAuthenticationException </span>&#123;</span><br><span class="line">    <span class="comment">// exceptionIfMaximumExceeded指示了当用户达到最大会话数时，是否阻止新会话建立</span></span><br><span class="line">    <span class="keyword">if</span> (exceptionIfMaximumExceeded || (sessions == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SessionAuthenticationException(messages.getMessage(</span><br><span class="line">            <span class="string">"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed"</span>,</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; Integer.valueOf(allowableSessions) &#125;,</span><br><span class="line">            <span class="string">"Maximum sessions of &#123;0&#125; for this principal exceeded"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine least recently used session, and mark it for invalidation</span></span><br><span class="line">    SessionInformation leastRecentlyUsed = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SessionInformation session : sessions) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((leastRecentlyUsed == <span class="keyword">null</span>)</span><br><span class="line">            || session.getLastRequest()</span><br><span class="line">            .before(leastRecentlyUsed.getLastRequest())) &#123;</span><br><span class="line">            leastRecentlyUsed = session;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 当新会话建立时，使最早的会话过期</span></span><br><span class="line">    leastRecentlyUsed.expireNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-前登录禁用后登录"><a href="#4-2-前登录禁用后登录" class="headerlink" title="4.2 前登录禁用后登录"></a>4.2 前登录禁用后登录</h3><p>前面我们知道了Spring Security默认提供的是踢掉就的会话，但是我们希望的是当在会话数达到最大时阻止新的会话创建，就可以有如下设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sessionManagement()</span><br><span class="line">    <span class="comment">// .sessionFixation().migrateSession() // 为默认的策略即可，不建议修改</span></span><br><span class="line">    <span class="comment">// .invalidSessionUrl("/session/invalid") // 会话过期时跳 转到某个URL。</span></span><br><span class="line">    .invalidSessionStrategy(<span class="keyword">new</span> MyInvalidSessionStrategy()) <span class="comment">// 自定义session过期策略 （和上面的跳转url，二选一）</span></span><br><span class="line">    .maximumSessions(<span class="number">1</span>) <span class="comment">// 设置单个用户的最大并发数</span></span><br><span class="line">    .maxSessionsPreventsLogin(<span class="keyword">true</span>) <span class="comment">// 阻止新会话登录，默认为false</span></span><br></pre></td></tr></table></figure>

<p>当时上述配置后可能出现一个问题，当用户首先登录后，然后使用退出<code>/logout</code>，当下一次再登录就会出现下面错误。</p>
<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Animation2.gif" alt></p>
<p>在我退出之后，再次登录是无法登录的。出现上面的原因是因为Spring Security是通过监听session的销毁事件来触发会话信息表相关清理工作的，但我们并没有注册过相关的监听器，导致Spring Security无法正常清理过期或已注销的会话。</p>
<p>解决方法：注册一个<code>bean</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpSessionEventPublisher <span class="title">httpSessionEventPublisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpSessionEventPublisher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在<code>servlet</code>中监听<code>session</code>相关事件的方法需要实现<code>HttpSessionListener</code>接口，并在系统中注册该监听器。在<code>Spring Security</code>中存在该类，为<code>HttpSessionEventPublisher</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionEventPublisher</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGGER_NAME = HttpSessionEventPublisher<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">ApplicationContext <span class="title">getContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(servletContext);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建session</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">		HttpSessionCreatedEvent e = <span class="keyword">new</span> HttpSessionCreatedEvent(event.getSession());</span><br><span class="line">		Log log = LogFactory.getLog(LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">			log.debug(<span class="string">"Publishing event: "</span> + e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 调用ApplicationEventPublisher，重新发布session创建事件</span></span><br><span class="line">		getContext(event.getSession().getServletContext()).publishEvent(e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 销毁session</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">		HttpSessionDestroyedEvent e = <span class="keyword">new</span> HttpSessionDestroyedEvent(event.getSession());</span><br><span class="line">		Log log = LogFactory.getLog(LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">			log.debug(<span class="string">"Publishing event: "</span> + e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 调用ApplicationEventPublisher，重新发布session创建事件</span></span><br><span class="line">		getContext(event.getSession().getServletContext()).publishEvent(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-后登录导致前登录无效"><a href="#4-3-后登录导致前登录无效" class="headerlink" title="4.3 后登录导致前登录无效"></a>4.3 后登录导致前登录无效</h3><p>当某个账号已经被登录了，另外一个人想利用这个账号进行登录。前面我们知道可以进行阻止，但是我们有时希望使用自己的策略，就可使用下面的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sessionManagement()</span><br><span class="line">    <span class="comment">// .sessionFixation().migrateSession() // 为默认的策略即可，不建议修改</span></span><br><span class="line">    <span class="comment">// .invalidSessionUrl("/session/invalid") // 会话过期时跳 转到某个URL。</span></span><br><span class="line">    .invalidSessionStrategy(<span class="keyword">new</span> MyInvalidSessionStrategy()) <span class="comment">// 自定义session过期策略 （和上面的跳转url，二选一）</span></span><br><span class="line">    .maximumSessions(<span class="number">1</span>) <span class="comment">// 设置单个用户的最大并发数</span></span><br><span class="line">    <span class="comment">// .maxSessionsPreventsLogin(true) // 阻止新会话登录，默认为false</span></span><br><span class="line">    <span class="comment">// .expiredUrl("/session/expired") // 需要自己另外实现一个controller（和下面二选一）</span></span><br><span class="line">    .expiredSessionStrategy(<span class="keyword">new</span> MyExpiredSessionStrategy())</span><br></pre></td></tr></table></figure>

<p>其中<code>MyExpiredSessionStrategy</code>类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">MyExpiredSessionStrategy</span> <span class="keyword">implements</span> <span class="title">SessionInformationExpiredStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExpiredSessionDetected</span><span class="params">(SessionInformationExpiredEvent event)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletResponse response = event.getResponse();</span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">"你已经在另一个地方登录！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Animation3.gif" alt></p>
<p>首先在第一个浏览器中登录账号<code>admin</code>，然后在另外一个账号登录相同账号。由于不阻止新会话登录（<code>maxSessionsPreventsLogin(false)</code>，这是默认的配置），所以后者是可以登录成功的，但是会踢掉前者登录，这也是为什么前者将会显示<span style="color:red">你已经在另一个地方登录！</span>。</p>
<p><strong>【注意】</strong></p>
<p>在并发控制方面，如果采用的是基于内存的登录，那么没有任何问题。但是如果是基于自定义的数据库模型，需要再实现<code>UserDetails</code>的类中添加<code>hashcode</code>和<code>equals</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(username, user.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因分析：</p>
<p>在Spring Security中采用的会话信息表来管理用户会话状态，具体实现可以参考<code>SessionRegistryImpl</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionRegistryImpl</span> <span class="keyword">implements</span> <span class="title">SessionRegistry</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ApplicationListener</span>&lt;<span class="title">SessionDestroyedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//....     </span></span><br><span class="line">    <span class="comment">// 存放用户以及其对应的所有sessionId的map （需要注意的是数据结构是Map）      </span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals;</span><br><span class="line">	<span class="comment">// 存放sessionId以及其对应的SessionInformation （数据结构是Map）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SessionInformation&gt; sessionIds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 用于处理SessionDestryEvent事件        </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(SessionDestroyedEvent event)</span> </span>&#123;</span><br><span class="line">		String sessionId = event.getId();</span><br><span class="line">        <span class="comment">// 当会话销毁事件被触发时，移除对应的sessionId的相关数据</span></span><br><span class="line">		removeSessionInformation(sessionId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 注册新的会话	        </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerNewSession</span><span class="params">(String sessionId, Object principal)</span> </span>&#123;</span><br><span class="line">		Assert.hasText(sessionId, <span class="string">"SessionId required as per interface contract"</span>);</span><br><span class="line">		Assert.notNull(principal, <span class="string">"Principal required as per interface contract"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Registering session "</span> + sessionId + <span class="string">", for principal "</span></span><br><span class="line">					+ principal);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (getSessionInformation(sessionId) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			removeSessionInformation(sessionId);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sessionIds.put(sessionId,</span><br><span class="line">				<span class="keyword">new</span> SessionInformation(principal, sessionId, <span class="keyword">new</span> Date()));</span><br><span class="line">		<span class="comment">// 判断该用户是否已经存在</span></span><br><span class="line">		Set&lt;String&gt; sessionsUsedByPrincipal = principals.computeIfAbsent(principal, key -&gt; <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class="line">		sessionsUsedByPrincipal.add(sessionId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Sessions used by '"</span> + principal + <span class="string">"' : "</span></span><br><span class="line">					+ sessionsUsedByPrincipal);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 移除对应会话信息        </span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSessionInformation</span><span class="params">(String sessionId)</span> </span>&#123;</span><br><span class="line">		Assert.hasText(sessionId, <span class="string">"SessionId required as per interface contract"</span>);</span><br><span class="line"></span><br><span class="line">		SessionInformation info = getSessionInformation(sessionId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Removing session "</span> + sessionId</span><br><span class="line">					+ <span class="string">" from set of registered sessions"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从SessionIds中移除对应的sessionId</span></span><br><span class="line">		sessionIds.remove(sessionId);</span><br><span class="line">		<span class="comment">// 获取对应用户的所有sessionId</span></span><br><span class="line">		Set&lt;String&gt; sessionsUsedByPrincipal = principals.get(info.getPrincipal());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有，则直接返回</span></span><br><span class="line">		<span class="keyword">if</span> (sessionsUsedByPrincipal == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Removing session "</span> + sessionId</span><br><span class="line">					+ <span class="string">" from principal's set of registered sessions"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 存在，则做对应的清理工作</span></span><br><span class="line">		sessionsUsedByPrincipal.remove(sessionId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (sessionsUsedByPrincipal.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// No need to keep object in principals Map anymore</span></span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Removing principal "</span> + info.getPrincipal()</span><br><span class="line">						+ <span class="string">" from registry"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			principals.remove(info.getPrincipal());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Sessions used by '"</span> + info.getPrincipal() + <span class="string">"' : "</span></span><br><span class="line">					+ sessionsUsedByPrincipal);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们知道<code>principals</code>采用了以用户信息为key的设计。我们知道，在hashMap中，以对象为key必须覆写hashCode和equals两个方法（具体原因可以查阅hashMap的设计），但我们实现UserDetails时并没有这么做，这导致同一个用户每次登录注销时计算得到的key都不相同，所以每次登录都会向principals中添加一个用户，而注销时却从来不能有效移除。在这种情况下，不仅达不到会话并发控制的效果，还会引发内存泄露。</p>
<h2 id="5-集群Session管理"><a href="#5-集群Session管理" class="headerlink" title="5. 集群Session管理"></a>5. 集群Session管理</h2><h3 id="5-1-原理分析"><a href="#5-1-原理分析" class="headerlink" title="5.1 原理分析"></a>5.1 原理分析</h3><p>在部署应用时，搭建至少两台机器的集群环境，防止一台服务器出现问题而服务中断，这样在一台机器在停止服务时，另一台机器还能继续提供服务。</p>
<p>而使用集群，在基于<code>Session</code>的身份认证就会导致问题：一个用户登录成功后，其<code>Session</code>存放在<code>A</code>机器上，而如果<code>Session</code>不做其他处理，在用户操作时，在负载均衡下，可能会请求发到<code>B</code>机器上，而<code>B</code>机器无<code>Session</code>导致无权限访问而需要再次登录。</p>
<p>而解决集群中<code>Session</code>的管理，可以把<code>Session</code>抽取出来为一个独立存储，用户请求需要<code>Session</code>时都会读取该存储<code>Session</code></p>
<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/20200307232312.jpg" alt></p>
<p>解决集群会话的常见解决方案有三种：</p>
<ul>
<li><code>session</code>保持：采用IP哈希负载策略，将来自相同客户端的请求转发至相同的服务器上处理。<span style="color:red">存在问题</span>，就是假设某个部分采用相同的源IP，然后通过路由给不同的用户分配不同的内网，但是最终使用的源IP还是相同的，如果将这些员工的请求都转发到相同的服务器上，存在一定的负载失衡。</li>
<li><code>session</code>复制：指服务器之间同步session数据，以达到各个实例之间会话状态一致的做法。<span style="color:red">存在问题</span>，就是同步需要消耗数据带宽，同时占用大量的资源。</li>
<li><code>session</code>共享（推荐做法）：指将 <code>session</code> 从服务器内存抽离出来，集中存储到独立的数据容器，并由各个服务器共享。</li>
</ul>
<p>这里使用<code>redis</code>作为<code>Session</code>存储管理，而<code>Spring Session</code>支持以下方式存储<code>Session</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StoreType &#123;</span><br><span class="line">    REDIS,</span><br><span class="line">    MONGODB,</span><br><span class="line">    JDBC,</span><br><span class="line">    HAZELCAST,</span><br><span class="line">    NONE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StoreType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么使用<code>redis</code>：</p>
<ol>
<li><code>redis</code>在大多数项目中使用来做缓存，查询速度快</li>
<li><code>Session</code>是有时间限制的，<code>redis</code>本身自带过期时间</li>
</ol>
</blockquote>
<h3 id="5-2-具体实现"><a href="#5-2-具体实现" class="headerlink" title="5.2 具体实现"></a>5.2 具体实现</h3><p>（1）在application.yml中配置如下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">session:</span></span><br><span class="line">        <span class="attr">store-type:</span> <span class="string">redis</span> <span class="comment"># session的存储类型为redis</span></span><br><span class="line">        <span class="attr">redis:</span></span><br><span class="line">          <span class="attr">flush-mode:</span> <span class="string">on_save</span> <span class="comment"># ON_SAVE在调用#SessionRepository#save(Session)时，在response commit前刷新缓存</span></span><br><span class="line">          <span class="attr">namespace:</span> <span class="string">spring:session</span> <span class="comment"># 存储session密钥的命名空间</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.52</span><span class="number">.10</span> <span class="comment"># 其余配置默认即可</span></span><br></pre></td></tr></table></figure>

<p>（2）使用不同端口启动程序（分别以8080和8081）</p>
<p>点击”Run”——&gt;”Edit configureations”,设置如下内容</p>
<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/20200307223055.png" alt></p>
<p>（3）启动8080，然后在application.yml中设置<code>server.port=8081</code>，然后启动该8081。最终实验结果如下：</p>
<p><img src="/images/6.SpringSecurity-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/Animation4.gif" alt></p>
<p>可以发现，虽然我是在8080服务上进行登录，但是在8081可以免登录，从而说明session被共用了。</p>
<p>参考资料</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/b9332491f500" target="_blank" rel="noopener">Spring Security源码分析九：Spring Security Session管理</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/caa1d35d3524" target="_blank" rel="noopener">Spring Security集群Session管理</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-5-SpringSecurity-实现自动登录和自动注销</title>
    <url>/2020/SpringSecurity-5-SpringSecurity-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%92%8C%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-功能实现"><a href="#1-功能实现" class="headerlink" title="1.功能实现"></a>1.功能实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/api/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">//对"/admin"的请求判断是否有“ADMIN”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/api/user/**"</span>).hasRole(<span class="string">"USER"</span>) <span class="comment">//对"/user/**"下的请求判断是否有“USER”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/api/app/**"</span>).permitAll() <span class="comment">//对"/app/**"下的请求判断是否有“APP”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/actuator/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated() <span class="comment">// 对所有请求都需要验证</span></span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">                .failureHandler(<span class="keyword">new</span> MyAuthenticationFailureHandler()) <span class="comment">// 登录失败后的处理</span></span><br><span class="line">                .and()</span><br><span class="line">             .csrf().disable()</span><br><span class="line">             .rememberMe()   </span><br><span class="line">                .userDetailsService(myUserDetailsService); <span class="comment">// 添加记住我</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行项目</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200303214112.png" alt></p>
<p>当点击<code>Remember me on this computer.</code>并成功登录后，在浏览器将生成一个cookie（除了JSESSIONID外）</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200303214442.png" alt></p>
<h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h2><p>在<code>AbstractRemembermeServices</code>类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRememberMeServices</span> <span class="keyword">implements</span> <span class="title">RememberMeServices</span>,</span></span><br><span class="line"><span class="class">		<span class="title">InitializingBean</span>, <span class="title">LogoutHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TWO_WEEKS_S = <span class="number">1209600</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tokenValiditySeconds = TWO_WEEKS_S; <span class="comment">// 过期时间是2周</span></span><br></pre></td></tr></table></figure>

<p>另外存在方法<code>loginSuccess</code>,这个方法具体实现分类为：<code>TokenBasedRememberMeServices</code>和<code>PersistentTokenBasedRememberMeServices</code>后者将token存储在数据库中（参考：<a href="https://niocoder.com/2018/01/17/Spring-Security%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%83-Spring-Security-%E8%AE%B0%E4%BD%8F%E6%88%91/#persistenttokenbasedremembermeservicesonloginsuccess" target="_blank" rel="noopener">Spring Security源码分析七：Spring Security 记住我</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loginSuccess</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                               HttpServletResponse response, Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!rememberMeRequested(request, parameter)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Remember-me login not requested."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onLoginSuccess(request, response, successfulAuthentication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）查看<code>TokenBasedRememberMeServices</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		String username = retrieveUserName(successfulAuthentication);</span><br><span class="line">		String password = retrievePassword(successfulAuthentication);</span><br><span class="line">		<span class="comment">// ....</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// Cookie 失效时间</span></span><br><span class="line">		<span class="keyword">int</span> tokenLifetime = calculateLoginLifetime(request, successfulAuthentication);</span><br><span class="line">		<span class="keyword">long</span> expiryTime = System.currentTimeMillis();</span><br><span class="line">		expiryTime += <span class="number">1000L</span> * (tokenLifetime &lt; <span class="number">0</span> ? TWO_WEEKS_S : tokenLifetime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 MD5 签名，与校验 Cookie 的逻辑一致</span></span><br><span class="line">		String signatureValue = makeTokenSignature(expiryTime, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到cookie中</span></span><br><span class="line">		setCookie(<span class="keyword">new</span> String[] &#123; username, Long.toString(expiryTime), signatureValue &#125;,</span><br><span class="line">				tokenLifetime, request, response);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在生成签名时，以前的Spring Security的getKey是生成一个UUID，需要看一下在<code>AbstractRemembermeServices</code>在被调用之前对key的赋值，估计也是一个UUId，正式UUID的原因。这将导致每次重启服务后，key都会重新生成，使得重启之前的所有自动登录cookie失效。除此之外，在多实例部署的情况下，由于实例间的 key并不相同，所以当用户访问系统的另一个实例时，自动登录策略就会失效。合理的用法是指定key。</p>
<p>在<code>RememberMeConfigurer</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/00dced2d301d" target="_blank" rel="noopener">https://www.jianshu.com/p/00dced2d301d</a></p>
<p>设置key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.rememberMe()  <span class="comment">// 配置rememberMe</span></span><br><span class="line">    .userDetailsService(myUserDetailsService)</span><br><span class="line">    .key(<span class="string">"xfcy"</span>); <span class="comment">// 设置key</span></span><br></pre></td></tr></table></figure>



<p>临时性自动登录：这种方式不需要服务器花费空间来存储自动登录的相关数据，实现简单，安全性相对较高。但存在潜在风险，即如果该令牌在有效期内被盗取，那么用户的身份将完全暴露。</p>
<h2 id="3-持久化令牌"><a href="#3-持久化令牌" class="headerlink" title="3. 持久化令牌"></a>3. 持久化令牌</h2><h3 id="2-1-持久化令牌实现"><a href="#2-1-持久化令牌实现" class="headerlink" title="2.1 持久化令牌实现"></a>2.1 持久化令牌实现</h3><p>持久化令牌方案在交互上与散列加密方案一致，都是在用户勾选Remember-me之后，将生成的令<br>牌发送到用户浏览器，并在用户下次访问系统时读取该令牌进行认证。不同的是，它采用了更加严谨<br>的安全性设计。<br>在持久化令牌方案中，最核心的是series和token两个值，它们都是用MD5散列过的随机字符串。<br>不同的是，series仅在用户使用密码重新登录时更新，而token会在每一个新的session中都重新生成。<br>这样设计有什么好处呢？<br>首先，解决了散列加密方案中一个令牌可以同时在多端登录的问题。每个会话都会引发token的更<br>新，即每个token仅支持单实例登录。<br>其次，自动登录不会导致series变更，而每次自动登录都需要同时验证series和token两个值，当该<br>令牌还未使用过自动登录就被盗取时，系统会在非法用户验证通过后刷新 token 值，此时在合法用户<br>的浏览器中，该token值已经失效。当合法用户使用自动登录时，由于该series对应的 token 不同，系统<br>可以推断该令牌可能已被盗用，从而做一些处理。例如，清理该用户的所有自动登录令牌，并通知该<br>用户可能已被盗号等。</p>
<p>Spring Security使用PersistentRememberMeToken来表明一个验证实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentRememberMeToken</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String series;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String tokenValue;</span><br><span class="line">    <span class="comment">// 最后一次自动登录时间</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Date date;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">//....   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要再数据库中定义一张<code>persistent_logins</code>表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CREATE TABLE <span class="title">persistent_logins</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  username VARCHAR(<span class="number">64</span>)</span> NOT NULL,</span></span><br><span class="line"><span class="function">  series <span class="title">VARCHAR</span><span class="params">(<span class="number">64</span>)</span> PRIMARY KEY,</span></span><br><span class="line"><span class="function">  token <span class="title">VARCHAR</span><span class="params">(<span class="number">64</span>)</span> NOT NULL,</span></span><br><span class="line"><span class="function">  last_used TIMESTAMP NOT NULL</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>

<p>修改<code>SecurityConfig</code>的<code>configure</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/api/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">//对"/admin"的请求判断是否有“ADMIN”权限</span></span><br><span class="line">            .antMatchers(<span class="string">"/api/user/**"</span>).hasRole(<span class="string">"USER"</span>) <span class="comment">//对"/user/**"下的请求判断是否有“USER”权限</span></span><br><span class="line">            .antMatchers(<span class="string">"/api/app/**"</span>).permitAll() <span class="comment">//对"/app/**"下的请求判断是否有“APP”权限</span></span><br><span class="line">            .antMatchers(<span class="string">"/actuator/**"</span>).permitAll()</span><br><span class="line">            .anyRequest().authenticated() <span class="comment">// 对所有请求都需要验证</span></span><br><span class="line">            .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">            .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">            .failureHandler(<span class="keyword">new</span> MyAuthenticationFailureHandler()) <span class="comment">// 登录失败后的处理</span></span><br><span class="line">            .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        	.disable()</span><br><span class="line">        .rememberMe()</span><br><span class="line">        	.userDetailsService(myUserDetailsService)</span><br><span class="line">        	<span class="comment">//.key("xfcy"); // 设置key</span></span><br><span class="line">        	.tokenRepository(<span class="keyword">null</span>); <span class="comment">// 设置tokenRepository</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行项目，在数据库中将生成如下内容</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200304104452.png" alt></p>
<p>显然，两种方案都存在cookie被盗取导致身份被暂时利用的可能，如果有更高的安全性需求，建<br>议使用Spring Security提供的令牌持久化方案。当然，最安全的方式还是尽量不使用自动登录，但很多<br>时候，在实际开发中，优质体验比不可预期的安全风险要更为优先。<br>如果决定提供自动登录功能，就应当限制cookie登录时的部分执行权限。例如，修改密码、修改<br>邮箱（防止找回密码）、查看隐私信息（如完整的手机号码、银行卡号等）等，校验登录密码或设置<br>独立密码来做二次校验也是不错的方案</p>
<h2 id="4-自动注销"><a href="#4-自动注销" class="headerlink" title="4. 自动注销"></a>4. 自动注销</h2><p>在<code>WebSecurityConfigurerAdapter</code>类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 如果http存在，则直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (http != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> http;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用默认的http配置</span></span><br><span class="line">	http = <span class="keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">			sharedObjects);</span><br><span class="line">	<span class="keyword">if</span> (!disableDefaults) &#123;</span><br><span class="line">		<span class="comment">// @formatter:off</span></span><br><span class="line">		http</span><br><span class="line">			.csrf().and()</span><br><span class="line">			.addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class="line">			.exceptionHandling().and()</span><br><span class="line">			.headers().and()</span><br><span class="line">			.sessionManagement().and()</span><br><span class="line">			.securityContext().and()</span><br><span class="line">			.requestCache().and()</span><br><span class="line">			.anonymous().and()</span><br><span class="line">			.servletApi().and()</span><br><span class="line">			.apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">			.logout(); <span class="comment">// 使用了默认的logout配置</span></span><br><span class="line">		</span><br><span class="line">           <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样我们可以知道<code>logout()</code>方法实际上应该是以<code>LogoutConfigure</code>作为基础配置</p>
<p>在<code>LogoutConfigure</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(H http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LogoutFilter logoutFilter = createLogoutFilter(http);</span><br><span class="line">    http.addFilter(logoutFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LogoutFilter <span class="title">createLogoutFilter</span><span class="params">(H http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    logoutHandlers.add(contextLogoutHandler);</span><br><span class="line">    LogoutHandler[] handlers = logoutHandlers</span><br><span class="line">        .toArray(<span class="keyword">new</span> LogoutHandler[logoutHandlers.size()]);</span><br><span class="line">    LogoutFilter result = <span class="keyword">new</span> LogoutFilter(getLogoutSuccessHandler(), handlers);</span><br><span class="line">    result.setLogoutRequestMatcher(getLogoutRequestMatcher(http));</span><br><span class="line">    result = postProcess(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LogoutFilter <span class="title">createLogoutFilter</span><span class="params">(H http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    logoutHandlers.add(contextLogoutHandler);</span><br><span class="line">    LogoutHandler[] handlers = logoutHandlers</span><br><span class="line">        .toArray(<span class="keyword">new</span> LogoutHandler[logoutHandlers.size()]);</span><br><span class="line">    LogoutFilter result = <span class="keyword">new</span> LogoutFilter(getLogoutSuccessHandler(), handlers);</span><br><span class="line">    result.setLogoutRequestMatcher(getLogoutRequestMatcher(http));</span><br><span class="line">    result = postProcess(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在LogoutFilter类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LogoutFilter</span><span class="params">(LogoutSuccessHandler logoutSuccessHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    LogoutHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = <span class="keyword">new</span> CompositeLogoutHandler(handlers);</span><br><span class="line">    Assert.notNull(logoutSuccessHandler, <span class="string">"logoutSuccessHandler cannot be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.logoutSuccessHandler = logoutSuccessHandler;</span><br><span class="line">    setFilterProcessesUrl(<span class="string">"/logout"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogoutRequestMatcher</span><span class="params">(RequestMatcher logoutRequestMatcher)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(logoutRequestMatcher, <span class="string">"logoutRequestMatcher cannot be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.logoutRequestMatcher = logoutRequestMatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在LogoutFilter中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">    HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// #1.匹配到/logout请求</span></span><br><span class="line">    <span class="keyword">if</span> (requiresLogout(request, response)) &#123;</span><br><span class="line">        Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Logging out user '"</span> + auth</span><br><span class="line">                         + <span class="string">"' and transferring to logout destination"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">// #2.处理1-4步</span></span><br><span class="line">        <span class="keyword">this</span>.handler.logout(request, response, auth);</span><br><span class="line">		<span class="comment">// #3.重定向注册界面</span></span><br><span class="line">        logoutSuccessHandler.onLogoutSuccess(request, response, auth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在CookieClearingLogoutHandler类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Authentication authentication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String cookieName : cookiesToClear) &#123;</span><br><span class="line">        <span class="comment">//# 1.Cookie置为null</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, <span class="keyword">null</span>);</span><br><span class="line">        String cookiePath = request.getContextPath() + <span class="string">"/"</span>;</span><br><span class="line">        cookie.setPath(cookiePath);</span><br><span class="line">        cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在PersistentTokenBasedRememberMeServices</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Authentication authentication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.logout(request, response, authentication);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (authentication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//#1.清空persistent_logins表中记录</span></span><br><span class="line">        tokenRepository.removeUserTokens(authentication.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SecurityContextLogoutHandler类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			Authentication authentication)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(request, <span class="string">"HttpServletRequest required"</span>);</span><br><span class="line">    <span class="keyword">if</span> (invalidateHttpSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invalidating session: "</span> + session.getId());</span><br><span class="line">            <span class="comment">// 当前session失效</span></span><br><span class="line">            session.invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clearAuthentication) &#123;</span><br><span class="line">        SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">        <span class="comment">//#2.清空当前的`SecurityContext`</span></span><br><span class="line">        context.setAuthentication(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SecurityContextHolder.clearContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-4-SpringSecurity-基于图像验证码的登录认证</title>
    <url>/2020/SpringSecurity-4-SpringSecurity-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>我们通常在配置过滤器时，使用过下面的方法：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200303162709.png" alt></p>
<p>其中<code>HttpSecuirty</code>实际上就是用来配置SpringSecurity的过滤器链，无论是CRSF还是表单登录都是由其配置。同样还可以配置<code>sessionManagement()</code>，如上图所示就配置了。这样我们不妨查看一下HttpSecurity中的<code>sessionManagement()</code>方法</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200303163945.png" alt></p>
<p>然后调用<code>getOrApply</code>方法，其中注入了一个<code>SessionManagementConfigure</code>对象。接下来看一下这个方法的源码。</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200303164135.png" alt></p>
<p>通过判断当前配置中是否存在该配置，如果存在，则直接返回，否则创建该配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(B http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PortMapper portMapper = http.getSharedObject(PortMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (portMapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        authenticationEntryPoint.setPortMapper(portMapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RequestCache requestCache = http.getSharedObject(RequestCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultSuccessHandler.setRequestCache(requestCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    authFilter.setAuthenticationManager(http</span><br><span class="line">                                        .getSharedObject(AuthenticationManager<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    authFilter.setAuthenticationSuccessHandler(successHandler);</span><br><span class="line">    authFilter.setAuthenticationFailureHandler(failureHandler);</span><br><span class="line">    <span class="keyword">if</span> (authenticationDetailsSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        authFilter.setAuthenticationDetailsSource(authenticationDetailsSource);</span><br><span class="line">    &#125;</span><br><span class="line">    SessionAuthenticationStrategy sessionAuthenticationStrategy = http</span><br><span class="line">        .getSharedObject(SessionAuthenticationStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (sessionAuthenticationStrategy != <span class="keyword">null</span>) &#123;</span><br><span class="line">        authFilter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">    RememberMeServices rememberMeServices = http</span><br><span class="line">        .getSharedObject(RememberMeServices<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (rememberMeServices != <span class="keyword">null</span>) &#123;</span><br><span class="line">        authFilter.setRememberMeServices(rememberMeServices);</span><br><span class="line">    &#125;</span><br><span class="line">    F filter = postProcess(authFilter);</span><br><span class="line">    <span class="comment">// 重点关注：往HttpSecurity的List&lt;Filter&gt; filters列表中添加了一个Filter对象</span></span><br><span class="line">    http.addFilter(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.jianshu.com/p/6f1b129442a1" target="_blank" rel="noopener">https://www.jianshu.com/p/6f1b129442a1</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SecurityConfigurer</span>&lt;<span class="title">O</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SecurityBuilder</span>&lt;<span class="title">O</span>&gt;&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 各个配置器的初始化方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(B builder)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 各个配置器被统一调用的配置方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">configure</span><span class="params">(B builder)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SpringSecurity-3-SpringSecurity-认证流程源码解析</title>
    <url>/2020/SpringSecurity-3-SpringSecurity-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在RESTful API中，通常的拦截顺序如下：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301095928.png" alt></p>
<p>可以比较下三者的区别：</p>
<p>（1）Filter过滤器：</p>
<ul>
<li><p>作用：<span style="color:red"><strong>拦截web访问的url地址</strong></span></p>
</li>
<li><p>特点：filter只是适用于web中，依赖于Servlet容器，基于函数回调实现；拦截方法的请求(ServletRequest request)和响应(ServletResponse response)；可以控制最初的http请求，但是更细一点的类和方法控制不了。</p>
</li>
<li><p>用途：<strong>设置字符编码，鉴权操作</strong></p>
</li>
</ul>
<p>（2）Interceptor拦截器</p>
<ul>
<li><p>作用：<span style="color:red"><strong>拦截器拦截以 .action结尾的url，拦截Action的访问</strong></span></p>
</li>
<li><p>特点：不依赖Servlet容器，基于Java的反射机制（APO思想）进行实现；<strong>可以获取执行的方法的名称</strong>，请求(HttpServletRequest)；<strong>可以控制请求的控制器和方法</strong>，但控制不了请求方法里的参数(<span style="color:green">只能获取参数的名称，不能获取到参数的值</span>)；</p>
</li>
<li><p>用途：用于处理页面提交的请求响应并进行处理，例如做国际化，做主题更换，过滤等</p>
</li>
</ul>
<p>下面有两着的流程示意图。</p>
<p><img src="https://img-blog.csdn.net/20180515183033475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwNjEwNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>（3）Spring AOP拦截器</p>
<ul>
<li><p>作用：<span style="color:red"><strong>只能拦截Spring管理Bean的访问（业务层Service）</strong></span>具体AOP详情参照 <a href="https://blog.csdn.net/fly910905/article/details/84025425" target="_blank" rel="noopener">Spring AOP：原理、 通知、连接点、切点、切面、表达式</a></p>
</li>
<li><p>特点：实际开发中，AOP常和事务结合：<a href="https://blog.csdn.net/fly910905/article/details/83547744" target="_blank" rel="noopener">Spring的事务管理:声明式事务管理(切面)</a><strong>AOP操作可以对操作进行横向的拦截</strong>，最大的优势在于他可<strong>以获取执行方法的参数( ProceedingJoinPoint.getArgs() )</strong>，对方法进行统一的处理；可以自定义切入的点，有方法的参数，但是拿不到http请求，可以通过其他方式如RequestContextHolder获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes= (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br></pre></td></tr></table></figure>
</li>
<li><p>用途：常见<strong>使用日志，事务，请求参数安全验证</strong>等</p>
</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/u010061060/article/details/80327348" target="_blank" rel="noopener">https://blog.csdn.net/u010061060/article/details/80327348</a></p>
<p>​            <a href="https://blog.csdn.net/fly910905/article/details/86537648" target="_blank" rel="noopener">https://blog.csdn.net/fly910905/article/details/86537648</a></p>
<h2 id="2-Spring-Security登录流程"><a href="#2-Spring-Security登录流程" class="headerlink" title="2. Spring Security登录流程"></a>2. Spring Security登录流程</h2><p>我们都知道Spring Security主要充当的是过滤器作用，其内部是由一系列的过滤器链组成。下面列举当前主要的过滤器链：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301150849.png" alt></p>
<p>首先准备好代码：</p>
<p>（1）在<code>UsernamePasswordAuthenticationFilter</code>的<code>attemptAuthentication</code>方法设置一个断点。</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301152904.png" alt></p>
<p>首先判断是否为post方式请求，然后构造一个<code>UsernamePasswordAuthenticationToken</code>对象</p>
<p>（2）在<code>UsernamePasswordAuthenticationToken</code>类中构造方法中</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301153459.png" alt></p>
<p>这里出现了一个<code>super(null)</code>,不妨看看<code>UsernamePasswordAuthenticationToken</code>的父类：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301154738.png" alt></p>
<p>现在还没有认证，所以执行到这里就直接返回了。</p>
<p>（3）继续执行到<code>setDetails(request,authRequest);</code>方法</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301155118.png" alt></p>
<p>继续往后面执行，可以发现调用的是<code>AbstractAuthenticationToken</code>中的set方法，对属性赋值。</p>
<p>（4）继续执行到<code>return this.getAuthenticationManager().authenticate(authRequest);</code></p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301155430.png" alt></p>
<p>然后在接口<code>AuthenticationManager</code>中定义了<code>authenticate(authRequest);</code>方法，其实现类这里主要研究<code>ProviderManager</code></p>
<p>（5）查看<code>ProviderManager</code>类中定义的<code>authenticate</code>方法</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301160809.png" alt></p>
<p>首先是<code>AnonymousAuthenticationProvider</code>，这种是不支持的，然后是<code>DaoAuthenticationProvider</code></p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301161057.png" alt></p>
<p>查看<code>authenticate</code>方法，可以发现该方法在<code>AuthenticationProvider</code>接口中定义。但是该接口子类较多</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301161622.png" alt></p>
<p>因此该方法实际上是在其父类<code>AbstractUserDetailsAuthenticationProvider</code>中实现</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301162410.png" alt></p>
<p>（10）在<code>DaoAuthenticationProvider</code>类中</p>
<p>查看下<code>retrieveUser</code>方法</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301162614.png" alt></p>
<p>主要作用：</p>
<ul>
<li>获取到了UserDetailsService对象，并返回</li>
</ul>
<p>进入<code>MyUserDetialsService</code>的<code>loadUserByUsername</code>方法中，得到一个<code>UserDetails</code>对象</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301163004.png" alt></p>
<p>（11）在</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301165004.png" alt></p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200301095103.png" alt></p>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-2-SpringSecurity-认证与授权</title>
    <url>/2020/SpringSecurity-2-SpringSecurity-%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在前面的学习中，Spring Security提供的安全机制：仅有一个用户，仅有一种角色。这种方式在实际开发中也明显不行。下面将按照两种方式创建多用户和多角色配置</p>
<h2 id="2-自定义验证"><a href="#2-自定义验证" class="headerlink" title="2. 自定义验证"></a>2. 自定义验证</h2><p>基础配置，在<code>SecurityConfig</code>中配置如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/api/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">//对"/admin"的请求判断是否有“ADMIN”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/api/user/**"</span>).hasRole(<span class="string">"USER"</span>) <span class="comment">//对"/user/**"下的请求判断是否有“USER”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/api/app/**"</span>).permitAll() <span class="comment">//对"/app/**"下的请求不拦截</span></span><br><span class="line">                .anyRequest().authenticated() <span class="comment">// 对所有请求都需要验证</span></span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">                .failureHandler(<span class="keyword">new</span> MyAuthenticationFailureHandler()) <span class="comment">// 登录失败后的处理</span></span><br><span class="line">                .permitAll(); <span class="comment">//登录页是不设置访问限制;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建三个Controller（分别为：AdminController、UserController和AppController），其中<code>AdminController</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他两个controller和其相似。</p>
<h3 id="2-1-基于内存的验证"><a href="#2-1-基于内存的验证" class="headerlink" title="2.1 基于内存的验证"></a>2.1 基于内存的验证</h3><p>这种方式相对简单，验证用户的数据固定在代码中，只需要实现<code>UserDetailService</code>即可。详细代码如下：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229153508.png" alt></p>
<p>我们可以看到<code>UserDetailManager</code>下主要有两个子类，分别代表两种方式。</p>
<p>在<code>SecurityConfig</code>中配置如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// ....   </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">"user"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>).build());</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">"admin"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面创建了两个用户：user和admin，分别具有不同的角色。</p>
<p>运行项目，通过上述配置的密码角色，自行验证。</p>
<h3 id="2-2-基于数据库的验证"><a href="#2-2-基于数据库的验证" class="headerlink" title="2.2 基于数据库的验证"></a>2.2 基于数据库的验证</h3><p>（1）由于使用数据库方式验证，所以必要的依赖是不可缺少的。在pom.xml中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加Springboot支持mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 添加mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在前面的继承图中可以，使用数据库方式验证，可以通过创建<code>JdbcUserDetailManager</code>实例，但是这种方式有一定局限，创建的数据库模型必须是Spring Security默认提供的，因此还可以通过直接实现<code>UserDetailService</code>方式实现。</p>
<h4 id="2-2-1-基于Spring-Security默认提供的模型"><a href="#2-2-1-基于Spring-Security默认提供的模型" class="headerlink" title="2.2.1 基于Spring Security默认提供的模型"></a>2.2.1 基于Spring Security默认提供的模型</h4><p>（1）创建数据库中的表<code>User</code>和<code>Authority</code>，这两种表在：<code>/org/springframework/security/core/userdetails/jdbc/users.ddl</code>中提供了定义（注意修改下数据类型）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> (</span><br><span class="line">  username <span class="built_in">VARCHAR</span> (<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="keyword">PASSWORD</span> <span class="built_in">VARCHAR</span> (<span class="number">500</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  enabled <span class="built_in">BOOLEAN</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> authorities (</span><br><span class="line">  username <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  authority <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> fk_authorities_users <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (username) <span class="keyword">REFERENCES</span> <span class="keyword">users</span> (username)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> ix_auth_username</span><br><span class="line"><span class="keyword">ON</span> authorities (username, authority);</span><br></pre></td></tr></table></figure>

<p>在mysql中创建上面的表。</p>
<p>（2）修改<code>SecurityConfig</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 需要注入数据源</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="comment">// ....   </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于jdbc方式</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JdbcUserDetailsManager manager = <span class="keyword">new</span> JdbcUserDetailsManager();</span><br><span class="line">        manager.setDataSource(dataSource);  <span class="comment">// manager需要设置数据源</span></span><br><span class="line">        <span class="keyword">if</span> (!manager.userExists(<span class="string">"user"</span>))&#123; <span class="comment">// 由于username是主键，当数据库中存在这个名字时，重启服务会继续创建而报错，因而需要判断</span></span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">"user"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!manager.userExists(<span class="string">"admin"</span>))&#123; <span class="comment">// 同上理</span></span><br><span class="line">            manager.createUser(User.withUsername(<span class="string">"admin"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>).build());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务，可以发现数据被填充进数据库中。当用户访问时，可以根据配置的数据登录访问。</p>
<p>上面的基于<code>JdbcUserDetailManager</code>和<code>InMemoryUserDetailManager</code>两种方式均可以在<code>WebSecurityConfigurer Adapter</code>中的另外一个<code>config</code>方法中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于jdbc方式</span></span><br><span class="line"><span class="comment">/*@Bean</span></span><br><span class="line"><span class="comment">public UserDetailsService userDetailsService()&#123;</span></span><br><span class="line"><span class="comment">	JdbcUserDetailsManager manager = new JdbcUserDetailsManager();</span></span><br><span class="line"><span class="comment">    manager.setDataSource(dataSource);  // manager需要设置数据源</span></span><br><span class="line"><span class="comment">    if (!manager.userExists("user"))&#123; // 由于username是主键，当数据库中存在这个名字时，重启服务会继续创建而报错，因而需要判断</span></span><br><span class="line"><span class="comment">    	manager.createUser(User.withUsername("user").password("123").roles("USER").build());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (!manager.userExists("admin"))&#123; // 同上理</span></span><br><span class="line"><span class="comment">            manager.createUser(User.withUsername("admin").password("123").roles("USER","ADMIN").build());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return manager;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	auth.jdbcAuthentication()</span><br><span class="line">    	.dataSource(dataSource)</span><br><span class="line">        .withUser(<span class="string">"user"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .withUser(<span class="string">"admin"</span>).password(<span class="string">"123"</span>).roles(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也可以实现上面功能（但是存在问题就是无法和上面判断使用存在同名的user）</p>
<h4 id="2-2-2-基于自定义的数据库模型（重点）"><a href="#2-2-2-基于自定义的数据库模型（重点）" class="headerlink" title="2.2.2 基于自定义的数据库模型（重点）"></a>2.2.2 基于自定义的数据库模型（重点）</h4><p>上面存在的问题在于：固定了数据库表的结构，这在实际开发中明显不行，因此需要自己定义。在前面学习两种基本方式时，使用了基于内存的方式和基于数据库的方式，同样还是将上面的那个继承关系放到下面：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229153508.png" alt></p>
<p>可以发现一个特点：就是两者都实现<code>UserDetailsService</code>和<code>UserDetailsManager</code>接口，不妨先看看这两个接口。</p>
<p>首先看看<code>UserDetailsService</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据用户名找到用户。 在实际的实现中，搜索可能区分大小写，或者不区分大小写，具体取决于实现实例的配置方式。 在这种情况下，返回的&lt;code&gt; UserDetails &lt;/ code&gt;对象的用户名可能与实际请求的用户名不同。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常在这里查找到数据库中的用户，可以参考前面两个实现类的操作，这里不详细谈论。</p>
<p>在<code>UserDetailsManager</code>接口中，主要定义了一些增删改查的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsManager</span> <span class="keyword">extends</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new user with the supplied details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">createUser</span><span class="params">(UserDetails user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Update the specified user.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(UserDetails user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Remove the user with the given login name from the system.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Modify the current user's password. This should change the user's password in the</span></span><br><span class="line"><span class="comment">	 * persistent user repository (datbase, LDAP etc).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> oldPassword current password (for re-authentication if required)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> newPassword the password to change to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">changePassword</span><span class="params">(String oldPassword, String newPassword)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check if a user with the supplied login name exists in the system.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">userExists</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于自己使用Jpa或者mybatis查询更加灵活，所以不需要上面定义的接口。</p>
<p>综上：使用自定义的方法一定需要实现<code>UserDetailsService</code>接口。</p>
<p>（1）创建一个数据库表,并插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`enable`</span> <span class="built_in">TINYINT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'用户是否可用'</span>,</span><br><span class="line">  <span class="string">`roles`</span> <span class="built_in">TEXT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COMMENT</span> <span class="string">'用户角色，多个角色之间用逗号隔开'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`username`</span> (<span class="string">`username`</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`users`</span>(<span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`roles`</span>) <span class="keyword">VALUES</span>(<span class="string">"admin"</span>, <span class="string">"123"</span>, <span class="string">"ROLE_ADMIN,ROLE_USER"</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`users`</span>(<span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`roles`</span>) <span class="keyword">VALUES</span>(<span class="string">"user"</span>, <span class="string">"123"</span>, <span class="string">"ROLE_USER"</span>);</span><br></pre></td></tr></table></figure>

<p>需要删除之前的表，或者另外命令。</p>
<p>（2）创建<code>MyUserDetailsService</code>类实现<code>UserDetailsService</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyPasswordEncoder myPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MyUserDetailsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"前台获取到的用户名为："</span>+username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库中尝试获取该用户</span></span><br><span class="line">        User user = userMapper.findByUsername(username);</span><br><span class="line">        <span class="comment">// 用户不存在，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置密码</span></span><br><span class="line">        String password = myPasswordEncoder.encode(user.getPassword());</span><br><span class="line">        LOGGER.info(<span class="string">"数据库中的密码为："</span>+password);</span><br><span class="line">        user.setPassword(password);</span><br><span class="line">        <span class="comment">//user</span></span><br><span class="line">        <span class="comment">// 将数据库形式的roles解析为UserDetails的权限集</span></span><br><span class="line">        <span class="comment">// AuthorityUtils.commaSeparatedStringToAuthorityList是Spring Security</span></span><br><span class="line">        <span class="comment">//提供的用于将逗号隔开的权限集字符串切割成可用权限对象列表的方法</span></span><br><span class="line">        <span class="comment">// 当然也可以自己实现，如用分号来隔开等，参考generateAuthorities</span></span><br><span class="line">        user.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList(user.getRoles()));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面返回的User类是自己定义的。这里的User可以使用Spring Security带的<code>User</code>类，也可以使用自定义的<code>User</code>类，但是需要注意自定义的<code>User</code>类需要继承<code>UserDetails</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String roles;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enable;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;  <span class="comment">// 自定义变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前用不到，暂时返回true，否则将会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前用不到，暂时返回true，否则将会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前用不到，暂时返回true，否则将会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.enable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(String roles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnable</span><span class="params">(<span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enable = enable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthorities</span><span class="params">(List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外mappr为<code>UserMapper</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from users where username= #&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findByUsername</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动类上需要添加包扫描</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.xfcy.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面添加了一个密码操作，因为实际开发中不可能是明文密码，通常是经过加密处理，并且还存在加密方式为普通的加密的基础上增加某些字符串等等。</p>
<p>（3）创建的<code>MyPasswordEncoder</code>类为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPasswordEncoder</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MyPasswordEncoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码原始密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawPassword 用户输入的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"加密时待加密的密码："</span> + rawPassword.toString());</span><br><span class="line">        <span class="keyword">return</span> rawPassword.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较用户输入的密码和数据库存储的密码是否一致</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rawPassword 用户输入的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encodedPassword 存储的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">"待校验的密码："</span>+rawPassword.toString());</span><br><span class="line">        LOGGER.info(<span class="string">"存储的密码："</span>+encodedPassword);</span><br><span class="line">        <span class="keyword">return</span> rawPassword.equals(encodedPassword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PasswordEncoder</code>接口提供了两个方法，由于这里是不需要加密，所以直接返回即可。</p>
<p>（4）查看一下配置类，需要注释掉之前基于内存和普通数据库模型的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//private DataSource dataSource;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/api/admin/**"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">//对"/admin"的请求判断是否有“ADMIN”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/api/user/**"</span>).hasRole(<span class="string">"USER"</span>) <span class="comment">//对"/user/**"下的请求判断是否有“USER”权限</span></span><br><span class="line">                .antMatchers(<span class="string">"/api/app/**"</span>).permitAll() <span class="comment">//对"/app/**"下的请求判断是否有“APP”权限</span></span><br><span class="line">                .anyRequest().authenticated() <span class="comment">// 对所有请求都需要验证</span></span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">                .failureHandler(<span class="keyword">new</span> MyAuthenticationFailureHandler()) <span class="comment">// 登录失败后的处理</span></span><br><span class="line">                .permitAll(); <span class="comment">//登录页是不设置访问限制;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他被注释掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229201758.png" alt></p>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>以上便是基于自定义验证的全部内容。其中重点内容便是自定义数据库模型方式。后面将通过源码进行分析</p>
<p>参考资料：</p>
<ul>
<li>Spring Security实战</li>
</ul>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity-1-SpringSecurity-基础入门</title>
    <url>/2020/SpringSecurity-1-SpringSecurity-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在本节，我们主要学习一下Spring Security的基础知识。</p>
<h2 id="2-基础配置"><a href="#2-基础配置" class="headerlink" title="2. 基础配置"></a>2. 基础配置</h2><p>（1）配置maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springboot对于web和test依赖支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- springboot对于security依赖支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-基本验证"><a href="#3-基本验证" class="headerlink" title="3. 基本验证"></a>3. 基本验证</h2><p>前期配置：</p>
<p>（1）创建一个启动器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建一个controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-基于弹出框验证"><a href="#3-1-基于弹出框验证" class="headerlink" title="3.1 基于弹出框验证"></a>3.1 基于弹出框验证</h3><p>在SpringSecurity中提供了两种验证方式：基于弹出框验证和基于表单验证。在Spring5后，默认提供的方式为基于表单的验证。</p>
<p>在application.yml中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">basic:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 默认是关闭的，另外在SpringBoot2.0后这个配置不推荐使用</span></span><br></pre></td></tr></table></figure>

<p>启动项目，得到随机密码为：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229115919.png" alt></p>
<p>访问项目<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p>
<img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229133000.png" style="zoom:150%;">



<h3 id="3-2-基于表单的验证"><a href="#3-2-基于表单的验证" class="headerlink" title="3.2 基于表单的验证"></a>3.2 基于表单的验证</h3><h4 id="3-2-1-使用默认账号和动态密码"><a href="#3-2-1-使用默认账号和动态密码" class="headerlink" title="3.2.1 使用默认账号和动态密码"></a>3.2.1 使用默认账号和动态密码</h4><p>（1）创建一个启动器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建一个controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当启动项目时，得到一个随机密码</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229115919.png" alt></p>
<p>访问如下<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p>
<img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200227152932.png" style="zoom:150%;">

<p>其中用户名为默认值user，密码即为上面动态生成的密码。</p>
<h4 id="3-2-2-使用自定义账号密码"><a href="#3-2-2-使用自定义账号密码" class="headerlink" title="3.2.2 使用自定义账号密码"></a>3.2.2 使用自定义账号密码</h4><p>在application.yml中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>当使用上述账号和密码便可以完成登录。</p>
<h2 id="4-自定义登录页"><a href="#4-自定义登录页" class="headerlink" title="4. 自定义登录页"></a>4. 自定义登录页</h2><p>前面使用的都是security自带的登录页。但是在开发中这种方式往往是不符合要求的，需要使用自己的登录页面。</p>
<p>方法：</p>
<p>（1）创建一个配置类实现<code>WebSecurityConfigurerAdapter</code>类</p>
<p>（2）重写<code>configure</code>方法</p>
<p>首先，了解下<code>WebSecurityConfigurerAdapter</code>类</p>
<h3 id="4-1-使用自定义登录页"><a href="#4-1-使用自定义登录页" class="headerlink" title="4.1 使用自定义登录页"></a>4.1 使用自定义登录页</h3><p>创建一个<code>SecurityConfig</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated() <span class="comment">//对任何请求都认证</span></span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .loginPage(<span class="string">"/myLogin.html"</span>) <span class="comment">//使用表单登录，其中登录页是自定义页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">"/login"</span>) <span class="comment">// 处理表单提交的请求，这个必须和action的地址一致</span></span><br><span class="line">                .permitAll() <span class="comment">//登录页是不设置访问限制</span></span><br><span class="line">                .and()</span><br><span class="line">            .csrf().disable(); <span class="comment">// 关闭跨域访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加一个自定义的登录界面，其中登录界面的<code>action</code>为<code>/login</code></p>
<p>重启项目，并运行</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229133216.png" alt></p>
<h2 id="5-自定义成功和失败处理"><a href="#5-自定义成功和失败处理" class="headerlink" title="5. 自定义成功和失败处理"></a>5. 自定义成功和失败处理</h2><p>由于前面挡用户认证成功后，便有服务器处理请求，然后返回给浏览器。但是在前后端分离的场景中，应该的流程为：用户认证成功后，将结果返回给浏览器，然后浏览器决定是否再向服务器请求用户需要的地址内容。</p>
<p>修改在<code>securityConfig</code>中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated() <span class="comment">//对任何请求都认证</span></span><br><span class="line">                .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">                .loginPage(<span class="string">"/myLogin.html"</span>) <span class="comment">//使用表单登录，其中登录页是自定义页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">"/login"</span>) <span class="comment">// 设置表单提交的请求，这个必须和action的地址一致</span></span><br><span class="line">                .successHandler(<span class="keyword">new</span> MyAuthenticationSuccessHandler()) <span class="comment">// 登录成功后的处理</span></span><br><span class="line">                .failureHandler(<span class="keyword">new</span> MyAuthenticationFailureHandler()) <span class="comment">// 登录失败后的处理</span></span><br><span class="line">                .permitAll() <span class="comment">//登录页是不设置访问限制</span></span><br><span class="line">                .and()</span><br><span class="line">            .csrf().disable(); <span class="comment">// 关闭跨域访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中定义的<code>MyAuthenticationSuccessHandler</code>和<code>MyAuthenticationFailureHandler</code>类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationSuccessHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户成功登录后的响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter writer = httpServletResponse.getWriter();</span><br><span class="line">        <span class="comment">// 响应一个json串，让浏览器决定后续处理</span></span><br><span class="line">        writer.write(<span class="string">"&#123;\"error_code\":\"0\",\"message\":\"认证成功\"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationFailureHandler</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录失败后的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        <span class="comment">// 响应一个json串，让浏览器决定后续处理</span></span><br><span class="line">        writer.write(<span class="string">"&#123;\"error_code\":\"1\",\"message\":\"认证失败\"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启项目，等到运行结果：</p>
<p><img src="https://raw.githubusercontent.com/xfljm/img/master/Img/20200229133618.png" alt></p>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>以上便是SpringSecurity的基础内容，当然实际开发中更多的是使用OAuth2.相关内容后续再学习。</p>
<p>参考资料</p>
<ul>
<li>《Spring Security实战》</li>
</ul>
]]></content>
      <categories>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>[object Object]</title>
    <url>/2020/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>默认文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-1-关键字-2-Java基础：static关键字</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-1-%E5%85%B3%E9%94%AE%E5%AD%97-2-Java%E5%9F%BA%E7%A1%80%EF%BC%9Astatic%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p><span style="color:red">问题1：</span>static是静态修饰符，什么叫静态修饰符呢？</p>
<blockquote>
<p> 大家都知道，在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的，而所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。这样做有什么意义呢？在Java程序里面，所有的东西都是对象，而对象的抽象就是类，对于一个类而言，如果要使用他的成员，那么普通情况下必须先实例化对象后，通过对象的引用才能够访问这些成员，但是<strong>用static修饰的成员可以通过类名加“.”进行直接访问。</strong></p>
</blockquote>
<p><span style="color:red">问题2：</span>static的作用?</p>
<blockquote>
<p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。</p>
</blockquote>
<p>被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，<strong>它不依赖类特定的实例，被类的所有实例共享</strong>。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。</p>
<p>用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。</p>
<p>static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用--废话），但是不能在其他类中通过类名来直接引用，这一点很重要。实际上你需要搞明白，private是访问权限限定，static表示不要实例化就可以使用，这样就容易理解多了。static前面加上其它访问权限关键字的效果也以此类推。</p>
<p><span style="color:red">问题3：</span>static变量或方法访问语法</p>
<blockquote>
<p>static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问，访问语法为：</p>
<p>类名.静态方法名(参数列表…)</p>
<p>类名.静态变量名</p>
</blockquote>
<p>用static修饰的代码块表示静态代码块，当Java虚拟机（JVM）加载类时，就会执行该代码块（用处非常大，呵呵）。</p>
<hr>
<h2 id="2-static变量"><a href="#2-static变量" class="headerlink" title="2 static变量"></a>2 static变量</h2><p>按照是否静态的对类成员变量进行分类可分两种：</p>
<p>（1）被static修饰的变量，叫静态变量或类变量；</p>
<p>（2）没有被static修饰的变量，叫实例变量。</p>
<p>两者的区别是：</p>
<p>对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。静态变量属于类，不属于任何一个独立的对象。</p>
<p>对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextld = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的<code>静态变量nextId</code>和实例<code>变量id</code>。假设创建了100个Employee对象，那么每个对象应该都有一个id，但是所有对象只共享一个nextId。</p>
<h2 id="3-static-final修饰变量"><a href="#3-static-final修饰变量" class="headerlink" title="3 static+final修饰变量"></a>3 static+final修饰变量</h2><p>我们经常还看见<code>public static final double PI = 3.14159265358979323846;</code>表示一旦给值，就不可修改，另外可以通过类名访问。</p>
<hr>
<h2 id="4-static方法"><a href="#4-static方法" class="headerlink" title="4 static方法"></a>4 static方法</h2><p>静态方法可以直接通过类名调用，任何的实例也都可以调用（但是不建议这么做）。静态方法不能访问实例变量和实例方法。另外static方法必须实现。</p>
<p><strong>注意：</strong></p>
<p>静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！这个需要去理解，想明白其中的道理，不是记忆！！！因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</p>
<p>在下面两种情况下使用静态方法：</p>
<p>1.一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如： Math.pow )。<br>2.一个方法只需要访问类的静态域（例如：Employee.getNextld ）</p>
<h2 id="5-static-final修饰方法"><a href="#5-static-final修饰方法" class="headerlink" title="5 static+final修饰方法"></a>5 static+final修饰方法</h2><p>该中方式也是经常看到的，比如下面一段源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> NumberFormat <span class="title">getCurrencyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance(Locale.getDefault(Locale.Category.FORMAT), CURRENCYSTYLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了前面static方法的功能外，<span style="color:red">该方法不能重写</span>（因为已经static修饰方法的原因，已经被修饰过一次了，final的作用刚好是赋值过一次后，不允许再次赋值，所以这里也就成为不能被重写）。</p>
<hr>
<h2 id="4-static代码块"><a href="#4-static代码块" class="headerlink" title="4 static代码块"></a>4 static代码块</h2><p>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                Test5.a = <span class="number">3</span>; </span><br><span class="line">                System.out.println(a); </span><br><span class="line">                Test5 t = <span class="keyword">new</span> Test5(); </span><br><span class="line">                t.f(); </span><br><span class="line">                t.b = <span class="number">1000</span>; </span><br><span class="line">                System.out.println(t.b); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                Test5.a = <span class="number">4</span>; </span><br><span class="line">                System.out.println(a); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">                <span class="comment">// TODO 自动生成方法存根 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                Test5.a = <span class="number">5</span>; </span><br><span class="line">                System.out.println(a); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                System.out.println(<span class="string">"hhahhahah"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">hhahhahah</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



<p>利用静态代码块可以对一些static变量进行赋值，最后再看一眼这些例子，都一个static的main方法，这样JVM在运行main方法的时候可以直接调用而不用创建实例。</p>
<p>1、  static和final一块用表示什么</p>
<p>static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！</p>
<pre><code>对于变量，表示一旦给值就不可修改，并且通过类名可以访问。</code></pre><p> 对于方法，表示不可覆盖，并且可以通过类名直接访问。</p>
<p><strong>特别要注意一个问题：</strong></p>
<p>对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，这一点在编程中用到很多。看个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticFinal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String strStaticFinalVar =<span class="string">"aaa"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String strStaticVar =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String strFinalVar = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intStaticFinalVar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer integerStaticFinalVar =<span class="keyword">new</span> Integer(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;String&gt;alStaticFinalVar = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"-------------值处理前----------\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"strStaticFinalVar="</span> +strStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"strStaticVar="</span> +strStaticVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"strFinalVar="</span> +strFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"intStaticFinalVar="</span> +intStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"integerStaticFinalVar="</span> +integerStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"alStaticFinalVar="</span> +alStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                <span class="comment">//strStaticFinalVar="哈哈哈哈";  //错误，final表示终态,不可以改变变量本身.</span></span><br><span class="line">                strStaticVar = <span class="string">"哈哈哈哈"</span>;       <span class="comment">//正确，static表示类变量,值可以改变.</span></span><br><span class="line">                <span class="comment">//strFinalVar="呵呵呵呵";        //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。</span></span><br><span class="line">                <span class="comment">//intStaticFinalVar=2;          //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。</span></span><br><span class="line">                <span class="comment">//integerStaticFinalVar=new Integer(8);  //错误, final表示终态，在定义的时候就要初值（哪怕给个null），一旦给定后就不可再更改。</span></span><br><span class="line">                alStaticFinalVar.add(<span class="string">"aaa"</span>);       <span class="comment">//正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。</span></span><br><span class="line">                alStaticFinalVar.add(<span class="string">"bbb"</span>);       <span class="comment">//正确，容器变量本身没有变化，但存放内容发生了变化。这个规则是非常常用的，有很多用途。</span></span><br><span class="line">                System.out.println(<span class="string">"-------------值处理后----------\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"strStaticFinalVar="</span> +strStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"strStaticVar="</span> +strStaticVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"strFinalVar="</span> +strFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"intStaticFinalVar="</span> +intStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"integerStaticFinalVar="</span> +integerStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"alStaticFinalVar="</span> +alStaticFinalVar + <span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">                <span class="keyword">new</span> TestStaticFinal().test();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span>值处理前<span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span></span><br><span class="line"></span><br><span class="line">strStaticFinalVar=aaa</span><br><span class="line"></span><br><span class="line">strStaticVar=null</span><br><span class="line"></span><br><span class="line">strFinalVar=null</span><br><span class="line"></span><br><span class="line">intStaticFinalVar=0</span><br><span class="line"></span><br><span class="line">integerStaticFinalVar=8</span><br><span class="line"></span><br><span class="line">alStaticFinalVar=<span class="symbol">\[</span><span class="symbol">\]</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span>值处理后<span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span><span class="symbol">\-</span></span><br><span class="line"></span><br><span class="line">strStaticFinalVar=aaa</span><br><span class="line"></span><br><span class="line">strStaticVar=哈哈哈哈</span><br><span class="line"></span><br><span class="line">strFinalVar=null</span><br><span class="line"></span><br><span class="line">intStaticFinalVar=0</span><br><span class="line"></span><br><span class="line">integerStaticFinalVar=8</span><br><span class="line"></span><br><span class="line">alStaticFinalVar=<span class="symbol">\[</span>aaa, bbb<span class="symbol">\]</span></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>看了上面这个例子，就清楚很多了，但必须明白：通过static final修饰的容器类型变量中所“装”的对象是可改变的。这是和一般基本类型和类类型变量差别很大的地方。</p>
<h2 id="5-java-static块和static方法的使用区别"><a href="#5-java-static块和static方法的使用区别" class="headerlink" title="5 java static块和static方法的使用区别"></a>5 java static块和static方法的使用区别</h2><p>如果有些代码必须在项目启动的时候就执行,就需要使用静态代码块,这种代码是主动执行的；需要在项目启动的时候就初始化但是不执行,在不创建对象的情况下,可以供其他程序调用,而在调用的时候才执行，这需要使用静态方法,这种代码是被动执行的。 静态方法在类加载的时候 就已经加载 可以用类名直接调用。</p>
<p><strong>静态代码块和静态方法的区别是：</strong></p>
<p>• 静态代码块是自动执行的;</p>
<p>• 静态方法是被调用的时候才执行的.</p>
<p>• 静态方法：如果我们在程序编写的时候需要一个不实例化对象就可以调用的方法，我们就可以使用静态方法，具体实现是在方法前面加上static，如下：</p>
<p><strong>public static void</strong> method(){}</p>
<p><strong>在使用静态方法的时候需要注意一下几个方面：</strong></p>
<p>在静态方法里只能直接调用同类中其他的静态成员（包括变量和方法），而不能直接访问类中的非静态成员。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才可使用，而静态方法在使用前不用创建任何对象。（备注：<strong>静态变量是属于整个类的变量而不是属于某个对象的</strong>）</p>
<p>静态方法不能以任何方式引用this和super关键字，因为静态方法在使用前不用创建任何实例对象，当静态方法调用时，this所引用的对象根本没有产生。</p>
<p>静态程序块：当一个类需要在被载入时就执行一段程序，这样可以使用静态程序块。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>有时你希望定义一个类成员，使它的使用完全独立于该类的任何对象。通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static(静态的)就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象。你可以将方法和变量都声明为static。static 成员的最常见的例子是main( ) 。因为在程序开始执行时必须调用main() ，所以它被声明为static。</p>
<p>声明为static的变量实质上就是全局变量。当声明一个对象时，并不产生static变量的拷贝，而是该类所有的实例变量共用同一个static变量。声明为static的方法有以下几条限制：</p>
<p>• 它们仅能调用其他的static方法。</p>
<p>• 它们只能访问static数据。</p>
<p>• 它们不能以任何方式引用this或super（关键字super 与继承有关，在下一章中描述）。</p>
<p>如果你需要通过计算来初始化你的static变量，你可以声明一个static块，Static 块仅在该类被加载时执行一次。</p>
<p>参考资料</p>
<ul>
<li><a href="https://blog.csdn.net/qq1623267754/article/details/36190715" target="_blank" rel="noopener">java中static、final、static final的区别</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-11-Java基础：静态代理、动态代理和CGLIB代理</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-11-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLIB%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="一、代理模式介绍"><a href="#一、代理模式介绍" class="headerlink" title="一、代理模式介绍"></a>一、代理模式介绍</h1><p><a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">代理模式</a>是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p>
<p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p>
<blockquote>
<p>代理模式UML类图</p>
</blockquote>
<p><img src="https://segmentfault.com/img/remote/1460000011291184" alt="代理模式UML类图" title="代理模式UML类图"></p>
<p>举个例子，我们生活中经常到火车站去买车票，但是人一多的话，就会非常拥挤，于是就有了代售点，我们能从代售点买车票了。这其中就是代理模式的体现，代售点代理了火车站对象，提供购买车票的方法。</p>
<h1 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h1><p>这种代理方式需要代理对象和目标对象实现一样的接口。</p>
<p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p>
<p>缺点：</p>
<ol>
<li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li>
<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>
</ol>
<blockquote>
<p>举例：保存用户功能的静态代理实现</p>
</blockquote>
<ul>
<li>接口类： IUserDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>目标对象：UserDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态代理对象：UserDapProxy <strong><em>需要实现IUserDao接口！</em></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(IUserDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);<span class="comment">//扩展了额外功能</span></span><br><span class="line">        target.save();</span><br><span class="line">        System.out.println(<span class="string">"提交事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类：TestProxy</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticUserProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStaticProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        IUserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        UserDaoProxy proxy = <span class="keyword">new</span> UserDaoProxy(target);</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">提交事务</span><br></pre></td></tr></table></figure>

<h1 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h1><p>动态代理利用了<a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/" target="_blank" rel="noopener">JDK API</a>，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p>
<p>静态代理与动态代理的区别主要在：</p>
<ul>
<li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li>
<li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</li>
</ul>
<p><strong>特点：</strong><br>动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。</p>
<p>JDK中生成代理对象主要涉及的类有</p>
<ul>
<li><a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/Proxy.html" target="_blank" rel="noopener">java.lang.reflect Proxy</a>，主要方法为</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object    <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,  //指定当前目标对象使用类加载器</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> Class&lt;?&gt;[] interfaces,    //目标对象实现的接口的类型</span></span></span><br><span class="line"><span class="function"><span class="params"> InvocationHandler h      //事件处理器</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://tool.oschina.net/uploads/apidocs/jdk-zh/java/lang/reflect/InvocationHandler.html" target="_blank" rel="noopener">java.lang.reflect InvocationHandler</a>，主要方法为</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function">Object    <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 在代理实例上处理方法调用并返回结果。</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：保存用户功能的动态代理实现</p>
</blockquote>
<ul>
<li>接口类： IUserDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>目标对象：UserDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态代理对象：UserProxyFactory</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">// 维护一个目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 执行目标对象方法</span></span><br><span class="line">                        Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"提交事务"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类：TestProxy</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDynamicProxy</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        IUserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        System.out.println(target.getClass());  <span class="comment">//输出目标对象信息</span></span><br><span class="line">        IUserDao proxy = (IUserDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        System.out.println(proxy.getClass());  <span class="comment">//输出代理对象信息</span></span><br><span class="line">        proxy.save();  <span class="comment">//执行代理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">class com<span class="selector-class">.proxy</span>.UserDao</span><br><span class="line">class com<span class="selector-class">.sun</span><span class="selector-class">.proxy</span>.<span class="variable">$Proxy4</span></span><br><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">提交事务</span><br></pre></td></tr></table></figure>

<h1 id="四、cglib代理"><a href="#四、cglib代理" class="headerlink" title="四、cglib代理"></a>四、cglib代理</h1><blockquote>
<p>cglib is a powerful, high performance and quality Code Generation Library. It can extend JAVA classes and implement interfaces at runtime.</p>
</blockquote>
<p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a> (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p>
<p><strong>cglib特点</strong></p>
<ul>
<li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。<br>如果想代理没有实现接口的类，就可以使用CGLIB实现。</li>
<li>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。<br>它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</li>
<li>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</li>
</ul>
<p>cglib与动态代理最大的<strong>区别</strong>就是</p>
<ul>
<li>使用动态代理的对象必须实现一个或多个接口</li>
<li>使用cglib代理的对象则无需实现接口，达到代理类无侵入。</li>
</ul>
<p>使用cglib需要引入<a href="https://repo1.maven.org/maven2/cglib/cglib/3.2.5/cglib-3.2.5.jar" target="_blank" rel="noopener">cglib的jar包</a>，如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib。</p>
<ul>
<li>cglib的Maven坐标</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：保存用户功能的动态代理实现</p>
</blockquote>
<ul>
<li>目标对象：UserDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代理对象：ProxyFactory</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标对象生成代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//工具类</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象代理</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">        <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">        Object returnValue = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"关闭事务"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试类：TestProxy</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglibProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        UserDao target = <span class="keyword">new</span> UserDao();</span><br><span class="line">        System.out.println(target.getClass());</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        UserDao proxy = (UserDao) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        <span class="comment">//执行代理对象方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">class com.cglib.UserDao</span><br><span class="line">class com.cglib.UserDao$$EnhancerByCGLIB$$<span class="number">552188b6</span></span><br><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">关闭事务</span><br></pre></td></tr></table></figure>

<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ol>
<li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li>
<li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li>
<li>动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。</li>
<li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li>
<li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li>
<li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</li>
</ol>
<h1 id="六、相关资料"><a href="#六、相关资料" class="headerlink" title="六、相关资料"></a>六、相关资料</h1><p>代理模式相关知识</p>
<ul>
<li><a href="http://www.jianshu.com/p/6f6bb2f0ece9" target="_blank" rel="noopener">代理模式及Java实现动态代理</a></li>
<li><a href="http://blog.csdn.net/chenssy/article/details/11179815" target="_blank" rel="noopener">设计模式读书笔记 - 代理模式</a></li>
<li><a href="http://rejoy.iteye.com/blog/1627405" target="_blank" rel="noopener">JDK动态代理实现原理</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a></li>
<li><a href="http://www.cnblogs.com/fillPv/p/5939277.html" target="_blank" rel="noopener">Java代理(jdk静态代理、动态代理和cglib动态代理)</a></li>
<li><a href="http://blog.csdn.net/dreamrealised/article/details/12885739" target="_blank" rel="noopener">AOP的底层实现-CGLIB动态代理和JDK动态代理</a></li>
<li><a href="http://llying.iteye.com/blog/220452" target="_blank" rel="noopener">深入浅出CGlib-打造无入侵的类代理</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></li>
</ul>
<p>UML相关知识</p>
<ul>
<li><a href="https://yq.aliyun.com/articles/75556" target="_blank" rel="noopener">博客 - UML类图与类的关系详解</a></li>
<li><a href="https://books.google.com.hk/books?id=dU--JuYudxgC&pg=PA18&lpg=PA18&dq=uml%E8%AF%A6%E8%A7%A3&source=bl&ots=ay5tHhDK0l&sig=_Fj_cEmG9ZSN5S3HHl1SrNcmcKw&hl=zh-CN&sa=X&ved=0ahUKEwiR14Kg45LVAhXL44MKHRZHD3Y4ChDoAQg3MAQ#v=onepage&q=uml%E8%AF%A6%E8%A7%A3&f=false" target="_blank" rel="noopener">goole图书 -《UML建模实例详解》</a></li>
</ul>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>默认文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-10-Java基础：Object类</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-10-Java%E5%9F%BA%E7%A1%80%EF%BC%9AObject%E7%B1%BB/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>Object类是类层次结构的根，Java中所有的类从根本上都继承自这个类。</p>
<p>Object类有12个成员方法，按照用途可以分为以下几种</p>
<p>1，构造函数</p>
<p>2，hashCode和equals函数用来判断对象是否相同,</p>
<p>3，wait(),wait(long),wait(long,int),notify(),notifyAll()</p>
<p>4，toString()和getClass,</p>
<p>5，clone()</p>
<p>6，finalize()用于在垃圾回收</p>
<p>其中3属于并发中的内容，这里不讨论。</p>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-hashCode和equals函数用来判断对象是否相同"><a href="#2-1-hashCode和equals函数用来判断对象是否相同" class="headerlink" title="2.1 hashCode和equals函数用来判断对象是否相同"></a>2.1 hashCode和equals函数用来判断对象是否相同</h3><p>（1）<code>equals</code>方法和<code>hashConde</code>方法源码</p>
<p>首先看一下<code>equals</code>的源码？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，其<strong>默认比较的是两个对象的地址是否相等</strong>。</p>
<p>再看看<code>hashConde</code>的源码？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p>（2）<code>equals</code>方法和<code>==</code>比较</p>
<p><code>equals</code>：如果某个类没有重写equals方法，则默认比较该类两个对象的地址。如果类中重写了（使用默认的重写方式），则比较的是对象的内容是否相等。</p>
<p><code>==</code>：比较两个对象的地址是否相等</p>
<p>（3）为什么在重写<code>equals</code>方法时往往需要重写<code>hashCode</code>方法？</p>
<p>首先我们知道下面规则：</p>
<ul>
<li>如果两个对象使用equals比较返回true，那么它们的hashCode值一定要相同</li>
<li>如果两个对象equals比较返回false，那么它们的hashCode值不一定不同。</li>
<li>覆盖equals，往往需要覆盖hashCode，可以使用idea自动生成，保证equals返回true，则hashCode相同；equals返回false，则hashCode不同。</li>
</ul>
<p>（4）在HashSet和HashMap中来解释为何需要同时重写上面两个方法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新建Person对象，</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">"aaa"</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建HashSet对象 </span></span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    set.add(p1);</span><br><span class="line">    set.add(p2);</span><br><span class="line">    set.add(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较p1 和 p2， 并打印它们的hashCode()</span></span><br><span class="line">    System.out.printf(<span class="string">"p1.equals(p2) : %s; p1(%d) p2(%d)\n"</span>, p1.equals(p2), p1.hashCode(), p2.hashCode());</span><br><span class="line">    <span class="comment">// 打印set</span></span><br><span class="line">    System.out.printf(<span class="string">"set:%s\n"</span>, set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">p1.equals(p2) : <span class="literal">true</span>; p1(<span class="number">1169863946</span>) p2(<span class="number">1690552137</span>)</span><br><span class="line"><span class="keyword">set</span>:[(eee, <span class="number">100</span>), (eee, <span class="number">100</span>), (aaa, <span class="number">200</span>)]</span><br></pre></td></tr></table></figure>

<p>我们重写了Person的equals()。但是，很奇怪的发现：HashSet中仍然有重复元素：p1 和 p2。为什么会出现这种情况呢？</p>
<p>这是因为虽然p1 和 p2的内容相等，但是它们的hashCode()不等；所以，HashSet在添加p1和p2的时候，认为它们不相等。</p>
<p><strong>所以在重写equals方法的时候必须重写hashCode方法。</strong></p>
<h3 id="2-2-toString和getClass"><a href="#2-2-toString和getClass" class="headerlink" title="2.2 toString和getClass"></a>2.2 toString和getClass</h3><p>（1）<code>toString</code>方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，默认的输出结果是<code>类名+@+十六进制的hashCode值</code>。比如下面形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Book b = <span class="keyword">new</span> Book();</span><br><span class="line">        String s = <span class="string">"Hello"</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(b.toString());</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Book@</span><span class="number">659e0</span>bfd</span><br><span class="line"><span class="symbol">Book@</span><span class="number">659e0</span>bfd</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>

<p>因此如果想打打印该类的信息，可以在该类中重写<code>toString</code>方法。</p>
<p>（2）<code>getClass</code>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>返回此 Object 的运行时类。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/51d9ba549172" target="_blank" rel="noopener">Object类中的方法及相关面试题</a></li>
<li><a href="http://www.51gjie.com/java/587.html" target="_blank" rel="noopener">http://www.51gjie.com/java/587.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-9-Java基础：注解使用</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-9-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-注解基础"><a href="#1-注解基础" class="headerlink" title="1. 注解基础"></a>1. 注解基础</h2><h3 id="1-1-什么是注解？"><a href="#1-1-什么是注解？" class="headerlink" title="1.1 什么是注解？"></a>1.1 什么是注解？</h3><p> 对于很多初次接触的开发者来说应该都有这个疑问？<strong><em>Annontation</em></strong>是Java5开始引入的新特征，中文名称叫<strong>注解</strong>。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。</p>
<p>　　Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p>
<h3 id="1-2-注解的用处"><a href="#1-2-注解的用处" class="headerlink" title="1.2 注解的用处"></a>1.2 注解的用处</h3><p> 1、生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等<br>  2、跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处;<br>  3、在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</p>
<h3 id="1-3-注解的原理"><a href="#1-3-注解的原理" class="headerlink" title="1.3 注解的原理"></a>1.3 注解的原理</h3><p>　　注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p>
<h3 id="1-4-元注解"><a href="#1-4-元注解" class="headerlink" title="1.4 元注解"></a>1.4 元注解</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：<br>   @Documented – 注解是否将包含在JavaDoc中<br>   @Retention – 什么时候使用该注解<br>   @Target – 注解用于什么地方<br>   @Inherited – 是否允许子类继承该注解</p>
<p>  1.）@Retention – 定义该注解的生命周期<br>  ●   RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。<br>  ●   RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式<br>  ●   RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p>
<p>  2.）Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括<br>  ● ElementType.CONSTRUCTOR: 用于描述构造器<br>  ● ElementType.FIELD: 成员变量、对象、属性（包括enum实例）<br>  ● ElementType.LOCAL_VARIABLE: 用于描述局部变量<br>  ● ElementType.METHOD: 用于描述方法<br>  ● ElementType.PACKAGE: 用于描述包<br>  ● ElementType.PARAMETER: 用于描述参数<br>  ● ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</p>
<p> 3.)@Documented – 一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档中。</p>
<p> 4.)@Inherited – 定义该注释和子类的关系<br>     @Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。</p>
<h3 id="1-5-常见标准的Annotation"><a href="#1-5-常见标准的Annotation" class="headerlink" title="1.5 常见标准的Annotation"></a>1.5 常见标准的Annotation</h3><p>  1.）Override<br>      java.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重写了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。<br>  2.）Deprecated<br>     Deprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。<br> 3.）SuppressWarnings<br>     SuppressWarning 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对@SuppressWarings 有效，同时编译器忽略掉无法识别的警告名。<br>　　@SuppressWarnings(“unchecked”)</p>
<h2 id="2-自定义注解"><a href="#2-自定义注解" class="headerlink" title="2. 自定义注解"></a>2. 自定义注解</h2><h3 id="2-1-自定义注解规则"><a href="#2-1-自定义注解规则" class="headerlink" title="2.1 自定义注解规则"></a>2.1 自定义注解规则</h3><p>自定义注解类编写的一些规则:</p>
<ol>
<li>Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li>
<li>参数成员只能用public 或默认(default) 这两个访问权修饰</li>
<li>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</li>
<li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li>
<li>注解也可以没有定义成员,，不过这样注解就没啥用了<br>PS:自定义注解需要使用到元注解</li>
</ol>
<h3 id="2-2-自定义注解实例"><a href="#2-2-自定义注解实例" class="headerlink" title="2.2 自定义注解实例"></a>2.2 自定义注解实例</h3><p>首先创建注解<code>@FruitName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果名称注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// ElementType.FIELD表明注解用在字段上</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="comment">// 注解的生命周期为始终不丢弃</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">// 表示是否将这个注解添加到Java文档中</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitName &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建注解<code>@FruitColor</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 水果颜色注解</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitColor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色枚举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color&#123; BLUE,RED,GREEN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 颜色属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Color <span class="title">fruitColor</span><span class="params">()</span> <span class="keyword">default</span> Color.GREEN</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建注解<code>@FruitProvider</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 水果供应者注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitProvider &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">address</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建注解处理类<code>FruitInfoUtil</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitInfoUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFruitInfo</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String strFruitName=<span class="string">" 水果名称："</span>;</span><br><span class="line">        String strFruitColor=<span class="string">" 水果颜色："</span>;</span><br><span class="line">        String strFruitProvicer=<span class="string">"供应商信息："</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的属性（当前类，不包括父类）</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个属性</span></span><br><span class="line">        <span class="keyword">for</span>(Field field :fields)&#123;</span><br><span class="line">            <span class="comment">// 判断FruitName注解是否在该field字段上</span></span><br><span class="line">            <span class="keyword">if</span>(field.isAnnotationPresent(FruitName<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                <span class="comment">// 获取该字段上指定注解的注释</span></span><br><span class="line">                FruitName fruitName = (FruitName) field.getAnnotation(FruitName<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                strFruitName=strFruitName+fruitName.value();</span><br><span class="line">                System.out.println(strFruitName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(field.isAnnotationPresent(FruitColor<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                strFruitColor=strFruitColor+fruitColor.fruitColor().toString();</span><br><span class="line">                System.out.println(strFruitColor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(field.isAnnotationPresent(FruitProvider<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                strFruitProvicer=<span class="string">" 供应商编号："</span>+fruitProvider.id()+<span class="string">" 供应商名称："</span>+fruitProvider.name()+<span class="string">" 供应商地址："</span>+fruitProvider.address();</span><br><span class="line">                System.out.println(strFruitProvicer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建一个实体类<code>Apple</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitName</span>(<span class="string">"Apple"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appleName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitColor</span>(fruitColor= FruitColor.Color.GREEN)</span><br><span class="line">    <span class="keyword">private</span> String appleColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@FruitProvider</span>(id=<span class="number">1</span>,name=<span class="string">"陕西红富士集团"</span>,address=<span class="string">"陕西省西安市延安路89号红富士大厦"</span>)</span><br><span class="line">    <span class="keyword">private</span> String appleProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleColor</span><span class="params">(String appleColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appleColor = appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppleColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appleColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleName</span><span class="params">(String appleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appleName = appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appleName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleProvider</span><span class="params">(String appleProvider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.appleProvider = appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppleProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建一个测试类<code>FruitRun</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FruitInfoUtil.getFruitInfo(Apple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行结果是：</p>
<blockquote>
<p> 水果名称：Apple<br> 水果颜色：RED<br> 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦</p>
</blockquote>
<p>参考链接：<br>[1]<a href="http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html" target="_blank" rel="noopener">http://www.cnblogs.com/peida/archive/2013/04/26/3038503.html</a><br>[2]<a href="http://www.cnblogs.com/whoislcj/p/5671622.html" target="_blank" rel="noopener">http://www.cnblogs.com/whoislcj/p/5671622.html</a><br>[3]<a href="http://blog.csdn.net/lylwo317/article/details/52163304" target="_blank" rel="noopener">http://blog.csdn.net/lylwo317/article/details/52163304</a></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-8-Java基础：序列化</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-8-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="1-1-什么是序列化和反序列化？"><a href="#1-1-什么是序列化和反序列化？" class="headerlink" title="1.1 什么是序列化和反序列化？"></a>1.1 什么是序列化和反序列化？</h3><p><strong>对象的序列化</strong>：换为字节序列的过程称为。</p>
<p><strong>对象的反序列化</strong>：把字节序列恢复为对象的过程称。</p>
<h3 id="1-2-主要用途？"><a href="#1-2-主要用途？" class="headerlink" title="1.2 主要用途？"></a>1.2 主要用途？</h3><ul>
<li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li>
<li>在网络上传送对象的字节序列。</li>
</ul>
<p>　　在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>
<p>　　当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p>
<h2 id="2-序列化实现方式"><a href="#2-序列化实现方式" class="headerlink" title="2. 序列化实现方式"></a>2. 序列化实现方式</h2><p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口之一。</p>
<h3 id="2-1-基本序列化"><a href="#2-1-基本序列化" class="headerlink" title="2.1 基本序列化"></a>2.1 基本序列化</h3><p>Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的</p>
<p>首先创建一个类<code>Person</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span> <span class="comment">// 可以链式编程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>序列化步骤</strong>：</p>
<ul>
<li>步骤一：创建一个ObjectOutputStream输出流；</li>
<li>步骤二：调用ObjectOutputStream对象的writeObject输出可序列化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteAndReadObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ObjectOutputStream输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"E:/object.txt"</span>));</span><br><span class="line">        <span class="comment">//将对象序列化到文件s</span></span><br><span class="line">        Person person = Person.builder().name(<span class="string">"9龙"</span>).age(<span class="number">11</span>).build();</span><br><span class="line">        <span class="comment">// 写入到文件中</span></span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        <span class="comment">// 关闭输出流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件保存到E盘中。</p>
<p><strong>反序列化步骤</strong>：</p>
<ul>
<li>步骤一：创建一个ObjectInputStream输入流；</li>
<li>步骤二：调用ObjectInputStream对象的readObject()得到序列化的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteAndReadObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun2</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"E:/object.txt"</span>)));</span><br><span class="line">        <span class="comment">// 读取到对象中</span></span><br><span class="line">        Person person = (Person) ois.readObject();</span><br><span class="line">        <span class="comment">// 在控制台输出</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        <span class="comment">// 关闭输入流</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Person(<span class="attribute">name</span>=9龙, <span class="attribute">age</span>=11)</span><br></pre></td></tr></table></figure>



<h3 id="2-2-成员是引用的序列化"><a href="#2-2-成员是引用的序列化" class="headerlink" title="2.2 成员是引用的序列化"></a>2.2 成员是引用的序列化</h3><p><strong>如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。</strong></p>
<p>新增加一个<code>Teacher</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person person; <span class="comment">//成员变量有Person</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改前面的<code>Person</code>类，去掉实现<code>Serializable</code></p>
<p><strong>序列化测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteAndReadObjectTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ObjectOutputStream输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"E:/object2.txt"</span>));</span><br><span class="line">        <span class="comment">//将对象序列化到文件s</span></span><br><span class="line">        Person person = Person.builder().name(<span class="string">"9龙"</span>).age(<span class="number">11</span>).build();</span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher(<span class="string">"zhangsan"</span>, person);</span><br><span class="line">        <span class="comment">// 写入到文件中</span></span><br><span class="line">        oos.writeObject(teacher);</span><br><span class="line">        <span class="comment">// 关闭输出流</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>Person</code>类没有序列化，所以这一定报错，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.io</span><span class="selector-class">.NotSerializableException</span>: <span class="selector-tag">com</span><span class="selector-class">.xfcy</span><span class="selector-class">.serializable</span><span class="selector-class">.Person</span></span><br><span class="line"></span><br><span class="line">	<span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.io</span><span class="selector-class">.ObjectOutputStream</span><span class="selector-class">.writeObject0</span>(<span class="selector-tag">ObjectOutputStream</span><span class="selector-class">.java</span><span class="selector-pseudo">:1184)</span></span><br><span class="line">	.....</span><br></pre></td></tr></table></figure>



<h3 id="2-3-同一对象序列化多次的机制"><a href="#2-3-同一对象序列化多次的机制" class="headerlink" title="2.3 同一对象序列化多次的机制"></a>2.3 同一对象序列化多次的机制</h3><p><strong>同一对象序列化多次，会将这个对象序列化多次吗？</strong>答案是<strong>否定</strong>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"teacher.txt"</span>))) &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"路飞"</span>, <span class="number">20</span>);</span><br><span class="line">            Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">"雷利"</span>, person);</span><br><span class="line">            Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">"红发香克斯"</span>, person);</span><br><span class="line">            <span class="comment">//依次将4个对象写入输入流</span></span><br><span class="line">            oos.writeObject(t1);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次将t1、t2、person、t2对象序列化到文件teacher.txt文件中。</p>
<p><strong>注意：反序列化的顺序与序列化时的顺序一致</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"teacher.txt"</span>))) &#123;</span><br><span class="line">            Teacher t1 = (Teacher) ois.readObject();</span><br><span class="line">            Teacher t2 = (Teacher) ois.readObject();</span><br><span class="line">            Person p = (Person) ois.readObject();</span><br><span class="line">            Teacher t3 = (Teacher) ois.readObject();</span><br><span class="line">            System.out.println(t1 == t2);</span><br><span class="line">            System.out.println(t1.getPerson() == p);</span><br><span class="line">            System.out.println(t2.getPerson() == p);</span><br><span class="line">            System.out.println(t2 == t3);</span><br><span class="line">            System.out.println(t1.getPerson() == t2.getPerson());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，<strong>Java序列化同一对象，并不会将此对象序列化多次得到多个对象。</strong></p>
<ul>
<li><strong>Java序列化算法</strong></li>
</ul>
<ol>
<li><strong>所有保存到磁盘的对象都有一个序列化编码号</strong></li>
<li><strong>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</strong></li>
<li><strong>如果此对象已经序列化过，则直接输出编号即可。</strong></li>
</ol>
<h3 id="1-4-java序列化算法潜在的问题"><a href="#1-4-java序列化算法潜在的问题" class="headerlink" title="1.4 java序列化算法潜在的问题"></a>1.4 java序列化算法潜在的问题</h3><p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。<strong>如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) &#123;</span><br><span class="line">            <span class="comment">//第一次序列化person</span></span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"9龙"</span>, <span class="number">23</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            System.out.println(person);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改name</span></span><br><span class="line">            person.setName(<span class="string">"海贼王"</span>);</span><br><span class="line">            System.out.println(person);</span><br><span class="line">            <span class="comment">//第二次序列化person</span></span><br><span class="line">            oos.writeObject(person);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次反序列化出p1、p2</span></span><br><span class="line">            Person p1 = (Person) ios.readObject();</span><br><span class="line">            Person p2 = (Person) ios.readObject();</span><br><span class="line">            System.out.println(p1 == p2);</span><br><span class="line">            System.out.println(p1.getName().equals(p2.getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Person&#123;name='9龙', age=23&#125;</span></span><br><span class="line"><span class="comment">//Person&#123;name='海贼王', age=23&#125;</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="1-5-可选的自定义序列化"><a href="#1-5-可选的自定义序列化" class="headerlink" title="1.5 可选的自定义序列化"></a>1.5 可选的自定义序列化</h3><p>1.有些时候，我们有这样的需求，某些属性不需要序列化。<strong>使用transient关键字选择不需要序列化的字段。</strong></p>
<p>首先我们修改<code>Person</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span> <span class="comment">// 可以链式编程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> singlehood;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的属性<code>singlehood</code>便是使用了关键字<code>transient</code>， 序列化时将被胡烈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建输入流和输出流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"E:/person.txt"</span>));</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"E:/person.txt"</span>));</span><br><span class="line">        <span class="comment">// 构建对象</span></span><br><span class="line">        Person person = Person.builder().name(<span class="string">"9龙"</span>).age(<span class="number">23</span>).height(<span class="number">187</span>).singlehood(<span class="keyword">true</span>).build();</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        <span class="comment">// 通过输入流将对象写入到文件中</span></span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        <span class="comment">// 从输出流中得到对象</span></span><br><span class="line">        Person person1 = (Person) ois.readObject();</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        <span class="comment">// 关闭</span></span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Person(<span class="attribute">name</span>=9龙, <span class="attribute">age</span>=23, <span class="attribute">height</span>=187, <span class="attribute">singlehood</span>=<span class="literal">true</span>)</span><br><span class="line">Person(<span class="attribute">name</span>=9龙, <span class="attribute">age</span>=23, <span class="attribute">height</span>=187, <span class="attribute">singlehood</span>=<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>可以发现正是因为忽略了<code>singlehood</code>进行序列化，因此使用的值为默认值<code>false</code>。</p>
<p>2.使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了<strong>可选的自定义序列化。</strong>可以进行控制序列化的方式，或者对序列化数据进行编码加密等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException；</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectIutputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure>

<p>通过重写writeObject与readObject方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象。这里展示对名字进行反转加密。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//将名字反转写入二进制流</span></span><br><span class="line">       out.writeObject(<span class="keyword">new</span> StringBuffer(<span class="keyword">this</span>.name).reverse());</span><br><span class="line">       out.writeInt(age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ins)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">       <span class="comment">//将读出的字符串反转恢复回来</span></span><br><span class="line">       <span class="keyword">this</span>.name = ((StringBuffer)ins.readObject()).reverse().toString();</span><br><span class="line">       <span class="keyword">this</span>.age = ins.readInt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当序列化流不完整时，readObjectNoData()方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。</p>
<p>3.更彻底的自定义序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br><span class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>writeReplace：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">      ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">      list.add(<span class="keyword">this</span>.name);</span><br><span class="line">      list.add(<span class="keyword">this</span>.age);</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">           ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) &#123;</span><br><span class="line">          Person person = <span class="keyword">new</span> Person(<span class="string">"9龙"</span>, <span class="number">23</span>);</span><br><span class="line">          oos.writeObject(person);</span><br><span class="line">          ArrayList list = (ArrayList)ios.readObject();</span><br><span class="line">          System.out.println(list);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//[9龙, 23]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>readResolve：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略构造方法，get及set方法</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> (<span class="string">"brady"</span>, <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"person.txt"</span>));</span><br><span class="line">             ObjectInputStream ios = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"person.txt"</span>))) &#123;</span><br><span class="line">            Person person = <span class="keyword">new</span> Person(<span class="string">"9龙"</span>, <span class="number">23</span>);</span><br><span class="line">            oos.writeObject(person);</span><br><span class="line">            HashMap map = (HashMap)ios.readObject();</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//&#123;brady=23&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>readResolve常用来反序列单例类，保证单例类的唯一性。</strong></p>
<p><strong>注意：readResolve与writeReplace的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写readResolve方法没有问题；否则，重写readResolve使用private修饰。</strong></p>
</li>
</ul>
<h3 id="1-6-使用Externalizable：强制自定义序列化"><a href="#1-6-使用Externalizable：强制自定义序列化" class="headerlink" title="1.6 使用Externalizable：强制自定义序列化"></a>1.6 使用Externalizable：强制自定义序列化</h3><p>通过实现Externalizable接口，必须实现writeExternal、readExternal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">// 必须有无参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExPerson</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将name反转后写入二进制流</span></span><br><span class="line">        StringBuffer reverse = <span class="keyword">new</span> StringBuffer(name).reverse();</span><br><span class="line">        System.out.println(reverse.toString());</span><br><span class="line">        out.writeObject(reverse);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//将读取的字符串反转后赋值给name实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个流</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"E:/ExPerson.txt"</span>));</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"E:/ExPerson.txt"</span>));</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        ExPerson person = ExPerson.builder().name(<span class="string">"brady"</span>).age(<span class="number">23</span>).build();</span><br><span class="line">        <span class="comment">// 写入文件中</span></span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        <span class="comment">// 从文件中读取</span></span><br><span class="line">        ExPerson person1 = (ExPerson)ois.readObject();</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        <span class="comment">// 关闭两个流</span></span><br><span class="line">        oos.close();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ydarb  <span class="comment">// 先反转了</span></span><br><span class="line">brady</span><br><span class="line"><span class="constructor">ExPerson(<span class="params">name</span>=<span class="params">brady</span>, <span class="params">age</span>=23)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。</strong></p>
<h2 id="3、两种序列化对比"><a href="#3、两种序列化对比" class="headerlink" title="3、两种序列化对比"></a>3、两种序列化对比</h2><table>
<thead>
<tr>
<th align="left">实现Serializable接口</th>
<th align="left">实现Externalizable接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">系统自动存储必要的信息</td>
<td align="left">程序员决定存储哪些信息</td>
</tr>
<tr>
<td align="left">Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td>
<td align="left">必须实现接口内的两个方法</td>
</tr>
<tr>
<td align="left">性能略差</td>
<td align="left">性能略好</td>
</tr>
</tbody></table>
<p><strong>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</strong></p>
<h3 id="三、序列化版本号serialVersionUID"><a href="#三、序列化版本号serialVersionUID" class="headerlink" title="三、序列化版本号serialVersionUID"></a>三、序列化版本号serialVersionUID</h3><p>我们知道，<strong>反序列化必须拥有class文件，但随着项目的升级，class文件也会升级，序列化怎么保证升级前后的兼容性呢？</strong></p>
<p>java序列化提供了一个private static final long serialVersionUID 的序列化版本号，只有版本号相同，即使更改了序列化属性，对象也可以正确被反序列化回来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列化版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1111013L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//省略构造方法及get,set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果反序列化使用的<strong>class的版本号</strong>与序列化时使用的<strong>不一致</strong>，反序列化会 <strong>报InvalidClassException异常。</strong></p>
<p><strong>序列化版本号可自由指定，如果不指定，JVM会根据类信息自己计算一个版本号，这样随着class的升级，就无法正确反序列化；不指定版本号另一个明显隐患是，不利于jvm间的移植，可能class文件没有更改，但不同jvm可能计算的规则不一样，这样也会导致无法反序列化。</strong></p>
<p>什么情况下需要修改serialVersionUID呢？分三种情况。</p>
<ul>
<li>如果只是修改了方法，反序列化不容影响，则无需修改版本号；</li>
<li>如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；</li>
<li>如果修改了非瞬态变量，则可能导致反序列化失败。<strong>如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。</strong>如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。</li>
</ul>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ol>
<li>所有需要网络传输的对象都需要实现序列化接口，通过建议所有的javaBean都实现Serializable接口。</li>
<li>对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化；方法、类变量、transient实例变量都不会被序列化。</li>
<li>如果想让某个变量不被序列化，使用transient修饰。</li>
<li>序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li>
<li>反序列化时必须有序列化对象的class文件。</li>
<li>当通过文件、网络来读取序列化后的对象时，必须按照实际写入的顺序读取。</li>
<li>单例类序列化，需要重写readResolve()方法；否则会破坏单例原则。</li>
<li>同一对象序列化多次，只有第一次序列化为二进制流，以后都只是保存序列化编号，不会重复序列化。</li>
<li>建议所有可序列化的类加上serialVersionUID 版本号，方便项目升级。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/xdp-gacl/p/3777987.html" target="_blank" rel="noopener">孤傲苍狼——Java基础学习总结——Java对象的序列化和反序列化</a></p>
</li>
<li><p><a href="https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf#h12" target="_blank" rel="noopener">掘金——java序列化，看这篇就够了</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-7-Java基础：浅复制和深复制</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-7-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在Java中数据类型主要包括两种：</p>
<blockquote>
<ul>
<li>值类型：Java 的基本数据类型，例如 int、float</li>
<li>引用类型：自定义类和 Java 包装类（string、integer）</li>
</ul>
</blockquote>
<p>他们的特点：</p>
<blockquote>
<ul>
<li>基本数据类型的特点：直接存储在栈(stack)中的数据</li>
<li>引用数据类型的特点：<strong>存储的是该对象在栈中引用，真实的数据存放在堆内存里</strong></li>
</ul>
</blockquote>
<p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/12/23/167da171f30b62ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>在 Java 开发中，对象拷贝或者说对象克隆是常有的事，对象克隆最终都离不开下面三种方式：</p>
<ul>
<li><strong>直接赋值</strong>、</li>
<li><strong>浅拷贝</strong>、</li>
<li><strong>深拷贝</strong> </li>
</ul>
<h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-直接赋值"><a href="#2-1-直接赋值" class="headerlink" title="2.1 直接赋值"></a>2.1 直接赋值</h3><p>直接赋值是我们最常用的方式，在我们代码中的体现是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Persona = <span class="keyword">new</span> Person();</span><br><span class="line">Person b = a;</span><br></pre></td></tr></table></figure>

<p>是一种简单明了的方式，但是它只是拷贝了对象引用地址而已，并没有在内存中生成新的对象，我们可以通过下面这个例子来证明这一点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    ...省略get/set...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// main 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 初始化一个对象</span></span><br><span class="line">       Person person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我是张三"</span>);</span><br><span class="line">       <span class="comment">// 复制对象</span></span><br><span class="line">       Person person1 = person;</span><br><span class="line">       <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">       person1.setName(<span class="string">"我不是张三了"</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码，你会得到如下结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;<span class="attribute">name</span>=<span class="string">'我不是张三了'</span>, <span class="attribute">age</span>=20, <span class="attribute">email</span>=<span class="string">'123456@qq.com'</span>, <span class="attribute">desc</span>=<span class="string">'我是张三'</span>&#125;</span><br><span class="line">person1对象：Person&#123;<span class="attribute">name</span>=<span class="string">'我不是张三了'</span>, <span class="attribute">age</span>=20, <span class="attribute">email</span>=<span class="string">'123456@qq.com'</span>, <span class="attribute">desc</span>=<span class="string">'我是张三'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们将 person 对象复制给了 person1 对象，我们对 person1 对象的 name 属性进行了修改，并未修改 person 对象的name 属性值，但是我们最后发现 person 对象的 name 属性也发生了变化，其实不止这一个值，对于其他值也是一样的，所以这结果证明了我们上面的结论：<strong>直接赋值的方式没有生产新的对象，只是生新增了一个对象引用</strong>，直接赋值在 Java 内存中的模型大概是这样的</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ecee2935796461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h3 id="2-2-浅拷贝"><a href="#2-2-浅拷贝" class="headerlink" title="2.2 浅拷贝"></a>2.2 浅拷贝</h3><p>浅拷贝也可以实现对象克隆，从这名字你或许可以知道，这种拷贝一定存在某种缺陷，是的，它就是存在一定的缺陷，先来看看浅拷贝的定义：<strong>如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。换句话说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</strong> 可能你没太理解这段话，那么我们在来看看浅拷贝的通用模型：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ecee29370f0cfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="浅拷贝通用模型"></p>
<p>要实现对象浅拷贝还是比较简单的，只需要被复制类需要实现 Cloneable 接口，重写 clone 方法即可，对 person 类进行改造，使其可以支持浅拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改造很简单只需要让 person 继承 Cloneable 接口，并且重写 clone 方法即可，clone 也非常简单只需要调用 object 的 clone 方法就好，唯一需要注意的地方就是 clone 方法需要用 public 来修饰，在简单的修改 main 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我是张三"</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">"我是张三的克隆对象"</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行 main 方法，结果如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;<span class="attribute">name</span>=<span class="string">'张三'</span>, <span class="attribute">age</span>=20, <span class="attribute">email</span>=<span class="string">'123456@qq.com'</span>, <span class="attribute">desc</span>=<span class="string">'我是张三'</span>&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;<span class="attribute">name</span>=<span class="string">'我是张三的克隆对象'</span>, <span class="attribute">age</span>=22, <span class="attribute">email</span>=<span class="string">'123456@qq.com'</span>, <span class="attribute">desc</span>=<span class="string">'我是张三'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个结果，你是否有所质疑呢？说好的引用对象只是拷贝了地址，为啥修改了 person1 对象的 name 属性值，person 对象没有改变？这里就是一个非常重要的知识点了，，原因在于：<strong>String、Integer 等包装类都是不可变的对象，当需要修改不可变对象的值时，需要在内存中生成一个新的对象来存放新的值，然后将原来的引用指向新的地址，所以在这里我们修改了 person1 对象的 name 属性值，person1 对象的 name 字段指向了内存中新的 name 对象，但是我们并没有改变 person 对象的 name 字段的指向，所以 person 对象的 name 还是指向内存中原来的 name 地址，也就没有变化</strong></p>
<p>这种引用是一种特列，因为这些引用具有不可变性，并不具备通用性，所以我们就自定义一个类，来演示浅拷贝，我们定义一个 PersonDesc 类用来存放person 对象中的 desc 字段，，然后在 person 对象中引用 PersonDesc 类，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增 PersonDesc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDesc</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">	<span class="comment">// 将原来的 string desc 变成了 PersonDesc 对象，这样 personDesc 就是引用类型</span></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String email, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.personDesc = <span class="keyword">new</span> PersonDesc();</span><br><span class="line">        <span class="keyword">this</span>.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">     ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 main 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"平头哥"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我的公众号是：平头哥的技术博文"</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">"我是平头哥的克隆对象"</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        person1.setDesc(<span class="string">"我已经关注了平头哥的技术博文公众号"</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 main 方法，得到如下结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;name=<span class="string">'平头哥'</span>, age=<span class="number">20</span>, email=<span class="string">'123456@qq.com'</span>, desc=<span class="string">'我已经关注了平头哥的技术博文公众号'</span>&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;name=<span class="string">'我是平头哥的克隆对象'</span>, age=<span class="number">22</span>, email=<span class="string">'123456@qq.com'</span>, desc=<span class="string">'我已经关注了平头哥的技术博文公众号'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们修改 person1 的 desc 字段之后，person 的 desc 也发生了改变，这说明 person 对象和 person1 对象指向是同一个 PersonDesc 对象地址，这也符合浅拷贝引用对象只拷贝引用地址并未创建新对象的定义，到这你应该知道浅拷贝了吧。</p>
<h3 id="2-3-深拷贝"><a href="#2-3-深拷贝" class="headerlink" title="2.3 深拷贝"></a>2.3 深拷贝</h3><p>深拷贝也是对象克隆的一种方式，相对于浅拷贝，<strong>深拷贝是一种完全拷贝，无论是值类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象</strong>，简单点说就是拷贝对象和被拷贝对象没有任何关系，互不影响。深拷贝的通用模型如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/4/16ecee2937132904?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="深拷贝通用模型"></p>
<p>深拷贝有两种方式，一种是跟浅拷贝一样实现 Cloneable 接口，另一种是实现 Serializable 接口，用序列化的方式来实现深拷贝，我们分别用这两种方式来实现深拷贝</p>
<p><strong>方式1：实现 Cloneable 接口方式</strong></p>
<p>实现 Cloneable 接口的方式跟浅拷贝相差不大，我们需要引用对象也实现 Cloneable 接口，具体代码改造如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDesc</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">	...省略...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* clone 方法不是简单的调用super的clone 就好，</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 需要将引用对象也克隆一次</span></span><br><span class="line">        person.personDesc = (PersonDesc) personDesc.clone();</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">	...省略...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>main 方法不需要任何改动，我们再次运行 main 方法，得到如下结果：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;<span class="attribute">name</span>=<span class="string">'平头哥'</span>, <span class="attribute">age</span>=20, <span class="attribute">email</span>=<span class="string">'123456@qq.com'</span>, <span class="attribute">desc</span>=<span class="string">'我的公众号是：平头哥的技术博文'</span>&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;<span class="attribute">name</span>=<span class="string">'我是平头哥的克隆对象'</span>, <span class="attribute">age</span>=22, <span class="attribute">email</span>=<span class="string">'123456@qq.com'</span>, <span class="attribute">desc</span>=<span class="string">'我已经关注了平头哥的技术博文公众号'</span>&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看出，修改 person1 的 desc 时对 person 的 desc 已经没有影响了，说明进行了深拷贝，在内存中重新生成了一个新的对象。</p>
<p><strong>方式二：实现 Serializable 接口方式</strong></p>
<p>实现 Serializable 接口方式也可以实现深拷贝，而且这种方式还可以解决多层克隆的问题，多层克隆就是引用类型里面又有引用类型，层层嵌套下去，用 Cloneable 方式实现还是比较麻烦的，一不小心写错了就不能实现深拷贝了，使用 Serializable 序列化的方式就需要所有的对象对实现 Serializable 接口，我们对代码进行改造，改造成序列化的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">369285298572941L</span>;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">// 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span></span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 将流序列化成对象</span></span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">            person = (Person) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">  ...省略...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDesc</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">872390113109L</span>;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"平头哥"</span>,<span class="number">20</span>,<span class="string">"123456@qq.com"</span>,<span class="string">"我的公众号是：平头哥的技术博文"</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">"我是平头哥的克隆对象"</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        person1.setDesc(<span class="string">"我已经关注了平头哥的技术博文公众号"</span>);</span><br><span class="line">        System.out.println(<span class="string">"person对象："</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"person1对象："</span>+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 main 方法，我们可以得到跟 Cloneable 方式一样的结果，序列化的方式也实现了深拷贝。到此关于 Java 浅拷贝和深拷贝的相关内容就介绍完了，希望你有所收获。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><strong>浅拷贝</strong>：只拷贝引用地址并未创建新对象，所以对于引用类型（除去包装类外），当拷贝的新对象对引用类型进行修改，原始的对象也被修改。浅拷贝是一种有缺陷的拷贝。</p>
<p><strong>深拷贝</strong>：深拷贝是一种完全拷贝，无论是值类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象</p>
<p>参考资料：</p>
<ul>
<li><a href="https://juejin.im/post/5b5dcf8351882519790c9a2e" target="_blank" rel="noopener">https://juejin.im/post/5b5dcf8351882519790c9a2e</a></li>
<li><a href="https://juejin.im/post/5de7237a518825125015cd6d" target="_blank" rel="noopener">https://juejin.im/post/5de7237a518825125015cd6d</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-6-Java基础：泛型</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-6-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p><strong>使用泛型能够让编写的代码可以被很多不同的类型的对象所重用</strong>。</p>
<p>Java 泛型是 Java 5 引入的一个重要特性，相信大多数 Java 开发者都对此不陌生，但是泛型背后的实现原理和类型擦除还是许多人依然不是很清楚。本文将介绍 Java 泛型的原理和使用，重点阐述容易产生困惑的通配符、类型擦除等问题。</p>
<h2 id="2-Java-泛型"><a href="#2-Java-泛型" class="headerlink" title="2. Java 泛型"></a>2. Java 泛型</h2><h3 id="2-1-Java-泛型是什么？"><a href="#2-1-Java-泛型是什么？" class="headerlink" title="2.1 Java 泛型是什么？"></a>2.1 Java 泛型是什么？</h3><p>Java 泛型，提供了参数化类型，并且提供了编译时强类型检查。泛型可以让我们很简单地支持不同类型，在 Java 集合框架中泛型广泛用以对类型的抽象。</p>
<h3 id="2-2-Java-泛型的好处"><a href="#2-2-Java-泛型的好处" class="headerlink" title="2.2 Java 泛型的好处"></a>2.2 Java 泛型的好处</h3><ul>
<li><p>提供编译时的强类型检查。可以在编译时发现类型安全问题，不用等到运行时。</p>
</li>
<li><p>避免类型转换。</p>
</li>
</ul>
<p>看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">String s = (String) list.get(<span class="number">0</span>); <span class="comment">// type cast to String</span></span><br></pre></td></tr></table></figure>

<p>如果使用泛型的话，不需要类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">String s = list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以实现通用的算法。通用算法可以处理不同类型的集合，可以进行自定义，并且类型安全且易于阅读。</li>
</ul>
<h2 id="2-泛型类型与泛型方法"><a href="#2-泛型类型与泛型方法" class="headerlink" title="2. 泛型类型与泛型方法"></a>2. 泛型类型与泛型方法</h2><h3 id="2-1-泛型类型"><a href="#2-1-泛型类型" class="headerlink" title="2.1 泛型类型"></a>2.1 泛型类型</h3><p>泛型类型是指泛型类或泛型接口。为了理解泛型类型的概念，看下面这个例子。</p>
<p>先定义一个简单的 Box 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String object)</span> </span>&#123; <span class="keyword">this</span>.object = object; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 Box 只能存放 String 类型的元素，如果想存放 Integer 等其他类型的元素，则必须重写另外一个 Box，代码不能复用。下面再看使用泛型后的 Box：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for "Type"</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 Box 可以存放除基本类型外的任何类型了。使用 T 类型代替 String 类型，按照惯例，类型参数名是一个大写字母，常见的类型参数名如下：</p>
<ul>
<li>E - Element（在 Java 集合框架中广泛运用）</li>
<li>K - Key</li>
<li>N - Number</li>
<li>T - Type</li>
<li>V - Value</li>
</ul>
<h3 id="2-2-泛型类型的原始类型（Raw-Types）"><a href="#2-2-泛型类型的原始类型（Raw-Types）" class="headerlink" title="2.2 泛型类型的原始类型（Raw Types）"></a>2.2 泛型类型的原始类型（Raw Types）</h3><p>原始类型（Raw Types）是没有指定参数类型的泛型类或泛型接口。例如，对于上面提到的<code>Box&lt;T&gt;</code>泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Box rawBox = <span class="keyword">new</span> Box();</span><br></pre></td></tr></table></figure>

<p><code>Box</code>就是<code>Box&lt;T&gt;</code>的原始类型，原始类型一般出现在旧版代码中，因为大量的 API 在 Java 5 之前不是通用的。原始类型和泛型类型也可以转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// generic type to raw type</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">Box rawBox = stringBox;               <span class="comment">// OK</span></span><br><span class="line">rawBox.set(<span class="number">8</span>);  <span class="comment">// warning: unchecked invocation to set(T)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// raw type to generic type</span></span><br><span class="line">Box rawBox = <span class="keyword">new</span> Box();           <span class="comment">// rawBox is a raw type of Box&lt;T&gt;</span></span><br><span class="line">Box&lt;Integer&gt; intBox = rawBox;     <span class="comment">// warning: unchecked conversion</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h3><p>泛型方法是指有它们自己参数化类型的方法。类型参数在一对尖括号之间，并且在方法返回类型之前。</p>
<p>下面 Util 类有一个泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getKey().equals(p2.getKey()) &amp;&amp;</span><br><span class="line">               p1.getValue().equals(p2.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常调用泛型方法的方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer, String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="string">"apple"</span>);</span><br><span class="line">Pair&lt;Integer, String&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">2</span>, <span class="string">"pear"</span>);</span><br><span class="line"><span class="keyword">boolean</span> same = Util.&lt;Integer, String&gt;compare(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在 Java 7 以上版本，利用类型推断可以简写为</span></span><br><span class="line"><span class="keyword">boolean</span> same = Util.compare(p1, p2);</span><br></pre></td></tr></table></figure>



<h2 id="3-有界类型参数-Bounded-Type-Parameters"><a href="#3-有界类型参数-Bounded-Type-Parameters" class="headerlink" title="3. 有界类型参数 (Bounded Type Parameters)"></a>3. 有界类型参数 (Bounded Type Parameters)</h2><p>很多时候我们都想限制参数类型的边界，例如在对比两个对象的方法中，想确保方法参数都是 Comparable 的。声明有界类型参数（Bounded Type Parameters<br>），格式为 <code>T extends Class &amp; Interface1 &amp; ... &amp; InterfaceN</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T t1, T t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.compareTo(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当我们传递的参数没有实现 Comparable 接口，会有编译时错误。有界类型参数同样可以用于泛型类和泛型接口中，而且支持多个边界，例如 <code>&lt;T extends A &amp; B &amp; C&gt;</code>，只允许最多一个 Class 边界，而且如果有一个 Class 边界，Class 边界必须在最前面。</p>
<h2 id="4-通配符"><a href="#4-通配符" class="headerlink" title="4. 通配符"></a>4. 通配符</h2><p>Java 泛型中问号<code>?</code>是通配符，表示未知类型。通配符可以用于参数、属性、局部变量或返回值的类型，但是不能用于泛型方法调用或创建泛型类实例的类型参数。</p>
<h3 id="4-1-无界通配符-Unbounded-Wildcards"><a href="#4-1-无界通配符-Unbounded-Wildcards" class="headerlink" title="4.1 无界通配符 (Unbounded Wildcards)"></a>4.1 无界通配符 (Unbounded Wildcards)</h3><p>单独使用<code>?</code>表示无界通配符，例如<code>List&lt;?&gt;</code>，表示未知类型的 list。下面两个场景适合使用无界通配符：</p>
<ul>
<li><p>如果想写一个方法，只用到 Object 类中的功能，即用<code>List&lt;?&gt;</code>代替<code>List&lt;Object&gt;</code>。</p>
</li>
<li><p>当使用到的泛型类型的方法不依赖参数类型时，例如只用到 List.size 或 List.clear 方法。事实上，<code>Class&lt;?&gt;</code>非常常见也是因为<code>Class&lt;T&gt;</code>中的大多数方法都不依赖 T。</p>
</li>
</ul>
<h3 id="4-2-上限通配符-Upper-Bounded-Wildcards"><a href="#4-2-上限通配符-Upper-Bounded-Wildcards" class="headerlink" title="4.2 上限通配符 (Upper Bounded Wildcards)"></a>4.2 上限通配符 (Upper Bounded Wildcards)</h3><p>上限通配符可以放宽对变量的限制。语法为<code>? extends SuperType</code>，SuperType 可以是类或接口。例如，如果想写一个对 <code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code>, <code>List&lt;Number&gt;</code>都适用的方法，可以用 <code>List&lt;? extends Number&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list)</span><br><span class="line">        s += n.doubleValue();</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-3-下限通配符-Lower-Bounded-Wildcards"><a href="#4-3-下限通配符-Lower-Bounded-Wildcards" class="headerlink" title="4.3 下限通配符 (Lower Bounded Wildcards)"></a>4.3 下限通配符 (Lower Bounded Wildcards)</h3><p>下限通配符可以限制为特定类型或该类型的父类型。语法为<code>? super SubType</code>。例如，想写一个方法添加 Integer 对象到 list 中，可以是 <code>List&lt;Integer&gt;</code>, <code>List&lt;Number&gt;</code>和<code>List&lt;Object&gt;</code>，可以用<code>List&lt;? super Integer&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-4-泛型的继承与子类型"><a href="#4-4-泛型的继承与子类型" class="headerlink" title="4.4 泛型的继承与子类型"></a>4.4 泛型的继承与子类型</h3><p>泛型有个常见的误解：Integer 是 Number 的子类型，所以 <code>Box&lt;Integer&gt;</code> 也是 <code>Box&lt;Number&gt;</code> 的子类型。<strong>但是其实<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Number&gt;</code>并没有直接关系。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boxTest</span><span class="params">(Box&lt;Number&gt; n)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="comment">// 如果传 Box&lt;Integer&gt; 会出现编译错误</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/6193835-50163d79254ebe60.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/338/format/webp" alt></p>
<p>generics-1.gif</p>
<p>泛型类的继承，可以看 Collection 的关系，<code>ArrayList&lt;String&gt;</code>是<code>List&lt;String&gt;</code>的子类型：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6193835-77b6d6abcf242d21.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/147/format/webp" alt></p>
<p>generics-2.gif</p>
<p>上面提到<code>Box&lt;Integer&gt;</code>和<code>Box&lt;Number&gt;</code>都是 Object 子类，但是它们还有个共有的父类型<code>Box&lt;?&gt;</code>，同理<code>List&lt;Number&gt;</code>和<code>List&lt;Integer&gt;</code>的父类型为<code>List&lt;?&gt;</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6193835-0f431f7ba69fd016.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/335/format/webp" alt></p>
<p>generics-3.gif</p>
<p>至于上限通配符和下限通配符间的关系，见下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6193835-6b0d827f8bfa2600.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/335/format/webp" alt></p>
<p>generics-4.gif</p>
<h3 id="4-5-通配符捕获-Wildcard-Capture"><a href="#4-5-通配符捕获-Wildcard-Capture" class="headerlink" title="4.5 通配符捕获 (Wildcard Capture)"></a>4.5 通配符捕获 (Wildcard Capture)</h3><p>有些时候，编译器会推测通配符的类型，例如<code>List&lt;?&gt;</code>类型，在某些代码中编译器从代码推断出具体的类型，这种场景就是通配符捕获。大多数情况下，我们都不需要关心通配符捕获，除非看到错误信息中包含“CAP#”。</p>
<p>下面代码会产生捕获错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;?&gt; i)</span> </span>&#123;</span><br><span class="line">        i.set(<span class="number">0</span>, i.get(<span class="number">0</span>)); <span class="comment">// 错误: 不兼容的类型: Object无法转换为CAP#1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的错误一开始可能觉得莫名其妙，先看看错误信息：i.set(int, capture&lt;?&gt;) 需要的参数类型为<code>int,CAP#1</code>，而实际传入的为<code>int,Object</code>，编译器将 i.get(0) 返回的类型推断为 Object。当调用<code>List.set(int, E)</code>时，编译器无法确认传入的类型与 List 的元素类型一致，虽然我们人为知道这处调用的类型是一致的。</p>
<p>我们可以额外加一个泛型方法来避免编译错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardFixed</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;?&gt; i)</span> </span>&#123;</span><br><span class="line">        fooHelper(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Helper method created so that the wildcard can be captured</span></span><br><span class="line">    <span class="comment">// through type inference.</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fooHelper</span><span class="params">(List&lt;T&gt; l)</span> </span>&#123;</span><br><span class="line">        l.set(<span class="number">0</span>, l.get(<span class="number">0</span>)); <span class="comment">// 传入参数也为 T，编译器推断为 CAP#1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面再看一个更复杂的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardErrorBad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapFirst</span><span class="params">(List&lt;? extends Number&gt; l1, List&lt;? extends Number&gt; l2)</span> </span>&#123;</span><br><span class="line">      Number temp = l1.get(<span class="number">0</span>);</span><br><span class="line">      l1.set(<span class="number">0</span>, l2.get(<span class="number">0</span>)); <span class="comment">// 错误: 不兼容的类型: Number无法转换为CAP#1</span></span><br><span class="line">      l2.set(<span class="number">0</span>, temp);      <span class="comment">// 错误: 不兼容的类型: Number无法转换为CAP#1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子试图执行一个不安全的操作，看下面调用的场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Double&gt;  ld = Arrays.asList(<span class="number">10.10</span>, <span class="number">20.20</span>, <span class="number">30.30</span>);</span><br><span class="line">swapFirst(li, ld);</span><br></pre></td></tr></table></figure>

<p>虽然<code>List&lt;Integer&gt;</code>和<code>List&lt;Double&gt;</code>都符合<code>List&lt;? extends Number&gt;</code>类型，但是<code>List&lt;Integer&gt;</code>列表中存放 Double 类型的元素显然不正确，所以也无法添加其他泛型方法来解决这个问题。</p>
<h3 id="4-6-PECS-原则"><a href="#4-6-PECS-原则" class="headerlink" title="4.6 PECS 原则"></a>4.6 PECS 原则</h3><p>在学习泛型的过程，一个容易困惑的问题是如何什么时候用上限通配符或下限通配符。下面先分析两者的具体使用区别。</p>
<p>对于<code>List&lt;? extends Number&gt;</code>类型，可以执行哪些操作呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Number first = list.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">list.add(<span class="keyword">null</span>); <span class="comment">// OK</span></span><br><span class="line">Number number = <span class="number">1</span>;</span><br><span class="line">list.add(number); <span class="comment">// 错误: 不兼容的类型: Number无法转换为CAP#1</span></span><br><span class="line">list.clear(); <span class="comment">// OK</span></span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><code>List&lt;? extends Number&gt;</code>类型可以添加 null 值，也可以通过泛型方法写入从本身 list 读取的值，但是无法添加新的元素。无法添加新元素的原因，是对于<code>List&lt;? extends Number&gt;</code>类型来说，可能是 <code>List&lt;Number&gt;</code>、 <code>List&lt;Integer&gt;</code>或<code>List&lt;Double&gt;</code>等类型，无法确定新元素的类型与集合里的类型一致，所以编译器会提示报错。所以可以将<code>List&lt;? extends Number&gt;</code>类型的列表看作非严格意义上的只读列表。</p>
<p>而对于<code>List&lt;? super Number&gt;</code>类型呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">Number first = list.get(<span class="number">0</span>); <span class="comment">// 错误: 不兼容的类型: CAP#1无法转换为Number</span></span><br><span class="line">list.add(<span class="keyword">null</span>); <span class="comment">// OK</span></span><br><span class="line">Number number = <span class="number">1</span>;</span><br><span class="line">list.add(number); <span class="comment">// OK</span></span><br><span class="line">list.clear(); <span class="comment">// OK</span></span><br><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><code>List&lt;? super Number&gt;</code>类型可以添加 null 值、添加新的元素，也可以删除元素，但是无法读取列表中的值。无法读取列表的原因，是对于<code>List&lt;? super Number&gt;</code>类型来说，可能是<code>List&lt;Number&gt;</code>也可能是<code>List&lt;Object&gt;</code>类型，读取列表元素时不能确定元素类型。所以可以将<code>List&lt;? super Number&gt;</code>类型的列表看作只写列表。</p>
<p>上面两个例子中，只读类型相当于生产者（Producer），生产 T，就使用<code>? extends T</code>，只写类型相当于消费者（Consumer），消费 T，就使用<code>? super T</code>。也就是“Producer Extends, Consumer Super”，简称 PECS 原则。</p>
<p>Collections.copy 方法就用到了这个原则，<code>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)</code>，src 列表是只读的，dest 列表是只写的。</p>
<p><strong>通配符的使用建议如下：</strong></p>
<ul>
<li><p>只读类型使用上限通配符<code>? extends T</code></p>
</li>
<li><p>只写类型使用下限通配符<code>? super T</code></p>
</li>
<li><p>如果只读类型只用到 Object 的方法，即<code>List&lt;? extends Object&gt;</code>，可以用<code>List&lt;?&gt;</code>无界通配符</p>
</li>
<li><p>对于同时需要读取和写入的类型，不要使用通配符</p>
</li>
</ul>
<p>上面四条建议都不适用于方法返回值类型。应该避免在返回值中使用通配符，因为这样会强制要求调用者调用时处理通配符。</p>
<h2 id="5-类型擦除"><a href="#5-类型擦除" class="headerlink" title="5. 类型擦除"></a>5. 类型擦除</h2><p>类型擦除是 Java 泛型中最容易产生困惑的地方，举个很简单的例子，许多人误以为<code>List&lt;String&gt;</code>与<code>List&lt;Integer&gt;</code>的 Class 类型不一致：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">System.out.println(strList.getClass().getName());   <span class="comment">// java.util.ArrayList</span></span><br><span class="line">System.out.println(intList.getClass().getName());   <span class="comment">// java.util.ArrayList</span></span><br><span class="line">System.out.println(strList.getClass() == intList.getClass());   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在编译时<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>的类型是不一样的，但是在运行时两者的类型又是一样的，背后的原因就是类型擦除。</p>
<p>Java 泛型添加是为了提供编译时的类型检查和支持泛型编程，并没有运行时的支持。所以 Java 编译器会用类型擦除来删除所有泛型类型检查代码，并在必要时插入强制类型转换。类型擦除确保不为参数化类型创建新类，所以<code>ArrayList&lt;E&gt;</code>的 Class 类型还是<code>java.util.ArrayList</code>，相应的，泛型也不会增加运行时开销。Java 编译器在应用泛型类型擦除时有以下行为：</p>
<ul>
<li><p>将泛型中所有参数化类型替换为泛型边界，如果参数化类型是无界的，则替换为 Object 类型。字节码中没有任何泛型的相关信息。</p>
</li>
<li><p>为了类型安全，在必要时插入类型转换代码。</p>
</li>
<li><p>生成桥接方法来保持泛型类型的多态性。</p>
</li>
</ul>
<h3 id="5-1-参数化类型替换"><a href="#5-1-参数化类型替换" class="headerlink" title="5.1 参数化类型替换"></a>5.1 参数化类型替换</h3><p>对于无解参数化类型，类型擦除时会替换为 Object。</p>
<p>下面看单链表中节点类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于有界参数化类型，类型擦除时会替换为第一个边界。</p>
<p>如果节点类使用有界参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data, Node&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparable data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Comparable data, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-类型转换"><a href="#5-2-类型转换" class="headerlink" title="5.2 类型转换"></a>5.2 类型转换</h3><p>经过参数化类型替换后，在使用泛型相关内容时，通常需要添加类型转换代码，看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;String&gt; node = <span class="keyword">new</span> Node&lt;&gt;(<span class="string">"Hello"</span>, <span class="keyword">null</span>);</span><br><span class="line">String data = node.getData();   <span class="comment">// 实际上 node.getData() 返回的是 Object 类型</span></span><br></pre></td></tr></table></figure>

<p>所以编译器还会插入类型转换代码，编译后如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(<span class="string">"Hello"</span>, <span class="keyword">null</span>);</span><br><span class="line">String data = (String) node.getData();</span><br></pre></td></tr></table></figure>



<h3 id="5-3-桥接方法"><a href="#5-3-桥接方法" class="headerlink" title="5.3 桥接方法"></a>5.3 桥接方法</h3><p>当编译一个类继承泛型类或泛型接口，在类型擦除的过程中编译器会生成一个合成方法，也称为桥接方法。</p>
<p>看下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> &lt;<span class="title">A</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( A that)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span> &lt;<span class="title">NumericValue</span>&gt; </span>&#123;</span><br><span class="line">    priva te <span class="keyword">byte</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">NumericValue</span> <span class="params">(<span class="keyword">byte</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( NumericValue that)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value - that.value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过参数化类型替换后，Comparable 接口的 compareTo 方法的参数类型为 Object，而 NumericValue 也需要实现<code>compareTo(Object)</code>方法，经过类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( Object that)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NumericValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    priva te <span class="keyword">byte</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">NumericValue</span> <span class="params">(<span class="keyword">byte</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">byte</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">( NumericValue that)</span>   </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.value - that.value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新合成的桥接方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object that)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.compareTo((NumericValue)that);  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除后<code>NumericValue.compareTo(NumericValue)</code>方法不再是接口的实现方法，这是类型擦除的一个副作用：两个方法（在接口和实现类中）在类型擦除之前具有相同的签名，而在类型擦除之后具有不同的签名。</p>
<p>为了让 NumericValue 依然正确地实现 Comparable 接口，编译器添加了一个桥接方法，和接口的签名相同，桥接方法委托给实现类中的原始方法。</p>
<p>虽然存在桥接方法，但是一般情况下，编译器不允许我们调用桥接方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NumericValue value = <span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">value.compareTo(value); <span class="comment">// OK</span></span><br><span class="line">value.compareTo(<span class="string">"abc"</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>但是，还有两种方式可以调用桥接方法：使用原始类型（Raw Types）或反射。但是桥接方法中有类型转换，所以传其他类型会有运行时报错。下面是使用原始类型的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparable comparable = <span class="keyword">new</span> NumericValue((<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">comparable.compareTo(comparable); <span class="comment">// OK</span></span><br><span class="line">comparable.compareTo(<span class="string">"abc"</span>);    <span class="comment">// OK at compile time, throws ClassCastException at run time</span></span><br></pre></td></tr></table></figure>



<h2 id="6-泛型的限制"><a href="#6-泛型的限制" class="headerlink" title="6. 泛型的限制"></a>6. 泛型的限制</h2><h3 id="6-1-不能用基本类型实例化泛型"><a href="#6-1-不能用基本类型实例化泛型" class="headerlink" title="6.1 不能用基本类型实例化泛型"></a>6.1 不能用基本类型实例化泛型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">'a'</span>);  <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line">Pair&lt;Integer, Character&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">8</span>, <span class="string">'a'</span>); <span class="comment">// ok，because of autoboxing</span></span><br></pre></td></tr></table></figure>

<p>主要原因：类型擦除后，Pair类包含Object类型的域，而Object是不能存储int值的，但是使用Integer去可以。</p>
<h3 id="6-2-不能创建参数化类型的实例"><a href="#6-2-不能创建参数化类型的实例" class="headerlink" title="6.2 不能创建参数化类型的实例"></a>6.2 不能创建参数化类型的实例</h3><p>不能创建参数化类型的实例，但是可以用反射创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; cls)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    E e1 = <span class="keyword">new</span> E(); <span class="comment">// error</span></span><br><span class="line">    E e2 = cls.newInstance(); <span class="comment">// ok</span></span><br><span class="line">    list.add(e2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-3-不能将静态属性声明为泛型类型"><a href="#6-3-不能将静态属性声明为泛型类型" class="headerlink" title="6.3 不能将静态属性声明为泛型类型"></a>6.3 不能将静态属性声明为泛型类型</h3><p>类的静态属性是类级别的属性，被该类所有实例共享，所以不允许静态属性是参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileDevice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os; <span class="comment">// compile-time error, if has MobileDevice&lt;Phone&gt; and MobileDevice&lt;Pc&gt; instance, can not confirm the type of os.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-4-不能对参数化类型使用-Casts-或-instanceof"><a href="#6-4-不能对参数化类型使用-Casts-或-instanceof" class="headerlink" title="6.4 不能对参数化类型使用 Casts 或 instanceof"></a>6.4 不能对参数化类型使用 Casts 或 instanceof</h3><p>不能 Casts 为参数化类型，除非是无界通配符类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;?&gt; list = li;</span><br><span class="line">List&lt;Number&gt; ln = (List&lt;Number&gt;) li;    <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>但是有些场景，编译器知道参数化类型是合法的，也会运行类型转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>因为类型擦除，无法确定运行时参数化类型具体是什么类型，所以无法使用 instanceof 校验类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">rtti</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123;  <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;T&gt;) &#123;  <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) &#123;  <span class="comment">// OK; instanceof requires a reifiable type</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-5-不能创建参数化类型的数组"><a href="#6-5-不能创建参数化类型的数组" class="headerlink" title="6.5 不能创建参数化类型的数组"></a>6.5 不能创建参数化类型的数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;[] arrayOfList = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">3</span>]; <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>为什么呢？擦除之后，<code>arrayOfList</code>的类型是<code>ArrayList&lt;Object&gt;[]</code>。但是在Java数组中要求数组的类型必须明确，所以这里一定报错。</p>
<p>解决方法：（曲线救国）</p>
<p>创建一个参数化类型数组的引用，并不报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt;[] arr;</span><br><span class="line">ArrayList[] ordinaryArr = <span class="keyword">new</span> ArrayList[<span class="number">3</span>];</span><br><span class="line">arr = (ArrayList&lt;String&gt;[]) ordinaryArr;   <span class="comment">// 但会存在一个警告</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">// true 说明这时已经存储了具体类型</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>以上内容参考：<a href="https://www.cnblogs.com/MrJR/p/10463479.html" target="_blank" rel="noopener">https://www.cnblogs.com/MrJR/p/10463479.html</a> </p>
<h3 id="6-6-不能创建、捕捉或抛出参数化类型的对象"><a href="#6-6-不能创建、捕捉或抛出参数化类型的对象" class="headerlink" title="6.6 不能创建、捕捉或抛出参数化类型的对象"></a>6.6 不能创建、捕捉或抛出参数化类型的对象</h3><p>泛型类不能直接或间接地继承<code>Throwable</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Extends Throwable indirectly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/* ... */</span> &#125;    <span class="comment">// compile-time error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extends Throwable directly</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueFullException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile-time error</span></span><br></pre></td></tr></table></figure>

<p>也无法捕捉参数化类型的异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Exception, J&gt; <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;J&gt; jobs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (J job : jobs)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;   <span class="comment">// compile-time error</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，可以在 throws 语句中使用参数化类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parser</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Exception</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(File file)</span> <span class="keyword">throws</span> T </span>&#123;     <span class="comment">// OK</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-7-不能重载参数类型为相同原始类型的方法"><a href="#6-7-不能重载参数类型为相同原始类型的方法" class="headerlink" title="6.7 不能重载参数类型为相同原始类型的方法"></a>6.7 不能重载参数类型为相同原始类型的方法</h3><p>不能有两个重载方法，当他们的方法签名在类型擦除后是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-4-Java基础：内部类</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-4-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="一-内部类基础"><a href="#一-内部类基础" class="headerlink" title="一.内部类基础"></a>一.内部类基础</h2><p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p>
<h3 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h3><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。<strong>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过要注意的是，<strong>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure>

<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在<strong>外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。<strong>创建成员内部类对象的一般方式</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.<span class="keyword">new</span> Inner();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，<strong>如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问</strong>。这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>
<h3 id="2-局部内部类"><a href="#2-局部内部类" class="headerlink" title="2.局部内部类"></a>2.局部内部类</h3><p><strong>局部内部类是定义在一个方法或者一个作用域里面的类</strong>，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: <strong>局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的</strong>。</p>
<h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h3><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段 Android 事件监听代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scan_bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">history_bt.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>这段代码为两个按钮设置监听器，这里面就使用了匿名内部类。这段代码中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setListener</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    scan_bt.setOnClickListener(<span class="keyword">new</span> Listener1());       </span><br><span class="line">    history_bt.setOnClickListener(<span class="keyword">new</span> Listener2());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener1</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Listener2</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，<strong>匿名内部类也是不能有访问修饰符和 static 修饰符的</strong>。</p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。<strong>静态内部类是不需要依赖于外部类的</strong>，这点和类的静态成员属性有点类似，<strong>并且它不能使用外部类的非static成员变量或者方法</strong>，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://www.runoob.com/wp-content/uploads/2018/04/021558444183591.jpg" alt></p>
<hr>
<h2 id="二-深入理解内部类"><a href="#二-深入理解内部类" class="headerlink" title="二.深入理解内部类"></a>二.深入理解内部类</h2><p><strong>1.为什么成员内部类可以无条件访问外部类的成员？</strong></p>
<p>在此之前，我们已经讨论过了成员内部类可以无条件访问外部类的成员，那具体究竟是如何实现的呢？下面通过反编译字节码文件看看究竟。事实上，编译器在进行编译的时候，会将成员内部类单独编译成一个字节码文件，下面是 Outter.java 的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译之后，出现了两个字节码文件：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/04/021630063402064.jpg" alt></p>
<p>反编译 Outter$Inner.class 文件得到下面信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E:\Workspace\Test\bin\com\cxh\test2&gt;javap -v Outter$Inner</span><br><span class="line">Compiled from &quot;Outter.java&quot;</span><br><span class="line">public class com.cxh.test2.Outter$Inner extends java.lang.Object</span><br><span class="line">  SourceFile: &quot;Outter.java&quot;</span><br><span class="line">  InnerClass:</span><br><span class="line">   #24&#x3D; #1 of #22; &#x2F;&#x2F;Inner&#x3D;class com&#x2F;cxh&#x2F;test2&#x2F;Outter$Inner of class com&#x2F;cxh&#x2F;tes</span><br><span class="line">t2&#x2F;Outter</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 50</span><br><span class="line">  Constant pool:</span><br><span class="line">const #1 &#x3D; class        #2;     &#x2F;&#x2F;  com&#x2F;cxh&#x2F;test2&#x2F;Outter$Inner</span><br><span class="line">const #2 &#x3D; Asciz        com&#x2F;cxh&#x2F;test2&#x2F;Outter$Inner;</span><br><span class="line">const #3 &#x3D; class        #4;     &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object</span><br><span class="line">const #4 &#x3D; Asciz        java&#x2F;lang&#x2F;Object;</span><br><span class="line">const #5 &#x3D; Asciz        this$0;</span><br><span class="line">const #6 &#x3D; Asciz        Lcom&#x2F;cxh&#x2F;test2&#x2F;Outter;;</span><br><span class="line">const #7 &#x3D; Asciz        &lt;init&gt;;</span><br><span class="line">const #8 &#x3D; Asciz        (Lcom&#x2F;cxh&#x2F;test2&#x2F;Outter;)V;</span><br><span class="line">const #9 &#x3D; Asciz        Code;</span><br><span class="line">const #10 &#x3D; Field       #1.#11; &#x2F;&#x2F;  com&#x2F;cxh&#x2F;test2&#x2F;Outter$Inner.this$0:Lcom&#x2F;cxh&#x2F;t</span><br><span class="line">est2&#x2F;Outter;</span><br><span class="line">const #11 &#x3D; NameAndType #5:#6;&#x2F;&#x2F;  this$0:Lcom&#x2F;cxh&#x2F;test2&#x2F;Outter;</span><br><span class="line">const #12 &#x3D; Method      #3.#13; &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">const #13 &#x3D; NameAndType #7:#14;&#x2F;&#x2F;  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">const #14 &#x3D; Asciz       ()V;</span><br><span class="line">const #15 &#x3D; Asciz       LineNumberTable;</span><br><span class="line">const #16 &#x3D; Asciz       LocalVariableTable;</span><br><span class="line">const #17 &#x3D; Asciz       this;</span><br><span class="line">const #18 &#x3D; Asciz       Lcom&#x2F;cxh&#x2F;test2&#x2F;Outter$Inner;;</span><br><span class="line">const #19 &#x3D; Asciz       SourceFile;</span><br><span class="line">const #20 &#x3D; Asciz       Outter.java;</span><br><span class="line">const #21 &#x3D; Asciz       InnerClasses;</span><br><span class="line">const #22 &#x3D; class       #23;    &#x2F;&#x2F;  com&#x2F;cxh&#x2F;test2&#x2F;Outter</span><br><span class="line">const #23 &#x3D; Asciz       com&#x2F;cxh&#x2F;test2&#x2F;Outter;</span><br><span class="line">const #24 &#x3D; Asciz       Inner;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">final com.cxh.test2.Outter this$0;</span><br><span class="line"> </span><br><span class="line">public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);</span><br><span class="line">  Code:</span><br><span class="line">   Stack&#x3D;2, Locals&#x3D;2, Args_size&#x3D;2</span><br><span class="line">   0:   aload_0</span><br><span class="line">   1:   aload_1</span><br><span class="line">   2:   putfield        #10; &#x2F;&#x2F;Field this$0:Lcom&#x2F;cxh&#x2F;test2&#x2F;Outter;</span><br><span class="line">   5:   aload_0</span><br><span class="line">   6:   invokespecial   #12; &#x2F;&#x2F;Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   9:   return</span><br><span class="line">  LineNumberTable:</span><br><span class="line">   line 16: 0</span><br><span class="line">   line 18: 9</span><br><span class="line"> </span><br><span class="line">  LocalVariableTable:</span><br><span class="line">   Start  Length  Slot  Name   Signature</span><br><span class="line">   0      10      0    this       Lcom&#x2F;cxh&#x2F;test2&#x2F;Outter$Inner;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第11行到35行是常量池的内容，下面注意第38行的内容：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> com.cxh.test2.Outter <span class="keyword">this</span>$<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这行是一个指向外部类对象的指针，看到这里想必大家豁然开朗了。也就是说<strong>编译器会默认为成员内部类添加了一个指向外部类对象的引用</strong>，那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public com.cxh.test2.<span class="constructor">Outter$Inner(<span class="params">com</span>.<span class="params">cxh</span>.<span class="params">test2</span>.Outter)</span>;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，<strong>虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数</strong>，<strong>该参数的类型为指向外部类对象的一个引用，所以成员内部类中的 Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员</strong>。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对 Outter this&amp;0 引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
<p><strong>2.为什么局部内部类和匿名内部类只能访问局部final变量？</strong></p>
<p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码会被编译成两个class文件：Test.class和Test1.class。<strong>默认情况下，编译器会为匿名内部类和局部内部类起名为Outterx.class（x为正整数）</strong>。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/04/021900556994393.jpg" alt></p>
<p>根据上图可知，test 方法中的匿名内部类的名字被起为 Test$1。</p>
<p>上段代码中，如果把变量 a 和 b 前面的任一个 final 去掉，这段代码都编译不过。我们先考虑这样一个问题：</p>
<p>当 test 方法执行完毕之后，变量a的生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束，那么在 Thread 的 run 方法中继续访问变量 a 就变成不可能了，但是又要实现这样的效果，怎么办呢？Java 采用了复制的手段来解决这个问题。将这段代码的字节码反编译可以得到下面的内容：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/04/021939271846598.jpg" alt></p>
<p>我们看到在 run 方法中有一条指令：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">bipush <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p>
<p>下面再看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>反编译得到：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/04/021950384493440.jpg" alt></p>
<p>我们看到匿名内部类 Test$1 的构造器含有两个参数，一个是指向外部类对象的引用，一个是 int 型变量，很显然，这里是将变量 test 方法中的形参 a 以参数的形式传进来对匿名内部类中的拷贝（变量 a 的拷贝）进行赋值初始化。</p>
<p>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</p>
<p>从上面可以看出，在 run 方法中访问的变量 a 根本就不是 test 方法中的局部变量 a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在 run 方法中访问的变量 a 和 test 方法中的变量 a 不是同一个变量，当在 run 方法中改变变量 a 的值的话，会出现什么情况？</p>
<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java 编译器就限定必须将变量 a 限制为 final 变量，不允许对变量 a 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>
<p>到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用 final 进行限定了。</p>
<p><strong>3.静态内部类有特殊的地方吗？</strong></p>
<p>从前面可以知道，<strong>静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象</strong>。另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译 class 文件看一下就知道了，是没有 Outter this&amp;0 引用的。</p>
<hr>
<h2 id="三-内部类的使用场景和好处"><a href="#三-内部类的使用场景和好处" class="headerlink" title="三.内部类的使用场景和好处"></a>三.内部类的使用场景和好处</h2><p>为什么在 Java 中需要内部类？总结一下主要有以下四点：</p>
<ul>
<li>1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整。</li>
<li>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</li>
<li>3.方便编写事件驱动程序。</li>
<li>4.方便编写线程代码。</li>
</ul>
<p>个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>
<p><strong>四.常见的与内部类相关的笔试面试题</strong></p>
<p>1.根据注释填写(1)，(2)，(3)处的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">           <span class="comment">// 初始化Bean1</span></span><br><span class="line">           (<span class="number">1</span>)</span><br><span class="line">           bean1.I++;</span><br><span class="line">           <span class="comment">// 初始化Bean2</span></span><br><span class="line">           (<span class="number">2</span>)</span><br><span class="line">           bean2.J++;</span><br><span class="line">           <span class="comment">//初始化Bean3</span></span><br><span class="line">           (<span class="number">3</span>)</span><br><span class="line">           bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> I = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> J = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bean</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bean3</span></span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()</p>
<p>创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</p>
<p>因此，（1），（2），（3）处的代码分别为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test test = <span class="keyword">new</span> Test();    </span><br><span class="line">Test.Bean1 bean1 = test.<span class="keyword">new</span> Bean1();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test.Bean2 b2 = <span class="keyword">new</span> Test.Bean2();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bean bean = <span class="keyword">new</span> Bean();     </span><br><span class="line">Bean.Bean3 bean3 =  bean.<span class="keyword">new</span> Bean3();</span><br></pre></td></tr></table></figure>

<p>2.下面这段代码的输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        outter.<span class="keyword">new</span> Inner().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">"局部变量："</span> + a);</span><br><span class="line">            System.out.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">"外部类变量："</span> + Outter.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<ul>
<li>1）成员内部类的引用方式必须为 Outter.Inner</li>
<li>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="keyword">super</span>(); <span class="comment">//必须有这句调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner obj = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-5-Java基础：代理</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-5-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式--代理模式，而对于代理，根据创建代理类的时间点，又可以分为静态代理和动态代理。</p>
<h2 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h2><p>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。在后面我会</p>
<p>解释这种间接性带来的好处。代理模式结构图（图片来自《大话设计模式》）：</p>
<p><img src="https://images2015.cnblogs.com/blog/1085268/201704/1085268-20170409105440082-1652546649.jpg" alt></p>
<h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2><h3 id="2-1-静态代理"><a href="#2-1-静态代理" class="headerlink" title="2.1 静态代理"></a>2.1 静态代理</h3><p>静态代理：由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p>
<h3 id="2-2-静态代理简单实现"><a href="#2-2-静态代理简单实现" class="headerlink" title="2.2 静态代理简单实现"></a>2.2 静态代理简单实现</h3><p> 根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，</p>
<p>班长就是学生的代理。</p>
<pre><code>首先，我们创建一个`Person`接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Student</code>类实现<code>Person</code>接口。<code>Student</code>可以具体实施上交班费的动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StudentsProxy</code>类，这个类也实现了<code>Person</code>接口，但是还另外持有一个学生类对象，由于实现了<code>Peson</code>接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行<code>giveMoney()</code>方法）行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面测试一下，看如何使用代理模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> StudentsProxy(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//班长代理上交班费</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/1085268/201704/1085268-20170409141805347-556037068.png" alt></p>
<p>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p>
<p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"张三最近学习有进步！"</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/1085268/201704/1085268-20170409143428488-1662654340.png" alt></p>
<p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p>
<h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2><h3 id="3-1-动态代理中的类和接口"><a href="#3-1-动态代理中的类和接口" class="headerlink" title="3.1 动态代理中的类和接口"></a>3.1 动态代理中的类和接口</h3><p>在动态代理中常常涉及到的类和接口主要有：<code>Proxy</code>类和<code>InvocationHandler</code>接口，下面首先对他们进行说明。</p>
<p><strong>1.Invocationhandler接口</strong></p>
<p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口 ，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	* proxy:代理类代理的真实代理对象com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="comment"> 	* method:我们所要调用某个对象真实的方法的Method对象</span></span><br><span class="line"><span class="comment"> 	* args:指代代理对象方法传递的参数</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.Proxy类</strong></p>
<p>用于创建一个代理类对象。其常用的方法为<code>newProxyInstance</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * loader: 一个classloader对象，定义了由哪个classloader对象对生成的代理类进行加载</span></span><br><span class="line"><span class="comment">    * interfaces: 一个interface对象数组，表示我们将要给我们的代理对象提供一组什么样的接口，如果我们提供了这样一个接口对象数组，那么也就是声明了代理类实现了这些接口，代理类就可以调用接口中声明的所有方法。 </span></span><br><span class="line"><span class="comment">    * h: 一个InvocationHandler对象，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">       Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">       <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-动态代理实现"><a href="#3-2-动态代理实现" class="headerlink" title="3.2 动态代理实现"></a>3.2 动态代理实现</h3><p> 代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， <strong>动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法</strong>。 比如说，想要在每个代理的方法前都加上一个处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">    beforeMethod();</span><br><span class="line">    stu.giveMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p>
<p><strong>2、动态代理简单实现</strong></p>
<p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p>
<p>创建一个动态代理对象步骤，具体代码见后面：</p>
<ul>
<li><p>创建一个InvocationHandler对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过构造器constructor来创建一个动态实例stuProxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person stuProxy = (Person) cons.newInstance(stuHandler);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure>

<p>到这里肯定都会很疑惑，这动态代理到底是如何执行的，是如何通过代理对象来执行被代理对象的方法的，先不急，我们先看看一个简单的完整的动态代理的例子。还是上面静态代理的例子，班长需要帮学生代交班费。首先是定义一个Person接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建需要被代理的实际类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">"方法耗时"</span> + (finishTime - tl.get()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p>
<p>再再invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理执行"</span> +method.getName() + <span class="string">"方法"</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。</p>
<p>运行结果：</p>
<p><img src="https://images2015.cnblogs.com/blog/1085268/201704/1085268-20170409164136175-1515319571.png" alt></p>
<p>上面说到，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p>
<p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p>
<h2 id="四、动态代理原理分析"><a href="#四、动态代理原理分析" class="headerlink" title="四、动态代理原理分析"></a><strong>四、动态代理原理分析</strong></h2><p><strong>1、Java动态代理创建出来的动态代理类</strong></p>
<p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy0"</span>, Student<span class="class">.<span class="keyword">class</span>.<span class="title">getInterfaces</span>())</span>;</span><br><span class="line">        String path = <span class="string">"G:/javacode/javase/Test/bin/proxy/StuProxy.class"</span>;</span><br><span class="line">        <span class="keyword">try</span>(FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path)) &#123;</span><br><span class="line">            fos.write(classFile);</span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(<span class="string">"代理类class文件写入成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.println(<span class="string">"写文件错误"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">      *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">      *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">      *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">      *Proxy构造方法：</span></span><br><span class="line"><span class="comment">      *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">      *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">      *         this.h = h;</span></span><br><span class="line"><span class="comment">      *     &#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">        <span class="keyword">throws</span> </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">       <span class="keyword">static</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">          m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span><br><span class="line">          m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">          m3 = Class.forName(<span class="string">"proxy.Person"</span>).getMethod(<span class="string">"giveMoney"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">          m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">      *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">      *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">      *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">throw</span> localError;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p>
<p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p>
<p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h2><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。<br>上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p>
<p>后面补充，知其然，还要知其所以然。</p>
<p>参考资料：</p>
<ul>
<li><p>原文：<a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">https://www.cnblogs.com/gonjan-blog/p/6685611.html</a> </p>
</li>
<li><p><a href="https://blog.csdn.net/yaomingyang/article/details/80981004" target="_blank" rel="noopener">Java动态代理InvocationHandler和Proxy学习笔记</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-1-Java基础：对象的装箱与拆箱</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>我们有时需要将int这样的基本类型转换为对象。所有的基本类型都有一个与之对应的类。这些类称为包装器。这些包装器类的名很明显：Integer,Long,Float,Double,Short,Byte,Character,Void,Boolean</p>
<p>对象包装器是不可变的，一但构造了包装器就不能改变其中的值，对象包装器还是final，因此不能定义他们的子类。</p>
<p>举例：java函数的值传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    x = x*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于值传递的对象是一个简单的基本类型<code>int</code>，函数中发生任何改变，都不会影响该基本类型参数的值，也即<code>x</code>永不变。通知我们还知道如果传递的是对象，那么对应的应该是引用类型，那么应该可以，比如下方更改为<code>Integer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span><span class="params">(Integer x)</span></span>&#123;</span><br><span class="line">    x = x*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>同样无效</strong>。因为前面说过包装器类的值是不能改变的。</p>
<p>如果想编写一个修改数值的方法，就需要使用在<code>org.omg.CORBA</code>包中定义的持有者类型（holder),包括IntHolder,BooleanHolder等。每个持有者类型都包含一个共有域值，通过它可以访问存储在其中的值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">triple</span>(<span class="params">IntHolder x</span>)</span>&#123;</span><br><span class="line">	x.<span class="keyword">value</span> = <span class="number">3</span> * x.<span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-Integer类"><a href="#2-Integer类" class="headerlink" title="2. Integer类"></a>2. Integer类</h2><p><code>Java.lang.Integer</code>包中，该类有如下方法</p>
<ul>
<li><code>int intValue()</code><br>以int的形式返回Integer对象的值（在Number类中覆盖了intValue方法。）</li>
<li><code>static String toString(int i)</code><br>以一个新String对象的形式返回给定数值i的十进制表示。</li>
<li><code>static String toString(int i, int radix)</code><br>返回数值i的基于给定radix参数进制的表示。</li>
<li><code>static int parseInt(String s)</code><br><code>static int parseInt(String s, int radix)</code><br>返回字符串s表示的整型数值，给定字符串表示的是十进制的 整数（第一种方法）或者返回radix参数进制的整数（第二种方法）</li>
<li><code>static Integer valueOf(String s)</code><br><code>static Integer valueOf(String s, int radix)</code><br>返回用s表示的整型数值进行初始化后的一个新Integer对象，给定字符串表示的是十进制的整数（第一种方法），或者是radix参数进制的整数（第二种方法）</li>
</ul>
<h2 id="3-自动装箱与拆箱"><a href="#3-自动装箱与拆箱" class="headerlink" title="3. 自动装箱与拆箱"></a>3. 自动装箱与拆箱</h2><p>自动装箱</p>
<p><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code><br><code>list.add(3);</code>将自动变换成<br><code>list.add(Integer.valueOf(3));</code></p>
<p>自动拆箱</p>
<p>将一个Integer赋值给一个int值，将会自动拆箱。<br><code>int n = list.get(i);</code><br>翻译成<br><code>int n = list.get(i).intValue();</code></p>
<h2 id="4-使用注意"><a href="#4-使用注意" class="headerlink" title="4. 使用注意"></a>4. 使用注意</h2><p>1.数据自增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">3</span>;</span><br><span class="line">n++;</span><br></pre></td></tr></table></figure>

<p>实际过程：先拆箱，自增后再装箱。</p>
<p>2.包装类引用null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer b = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="number">2</span>*b); <span class="comment">// 空指针异常</span></span><br></pre></td></tr></table></figure>

<p>3.混合使用<code>Integer</code>和<code>Double</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line">Double x = <span class="number">2.0</span>;</span><br><span class="line">System.out.println(<span class="keyword">true</span>? n:x); <span class="comment">// 输出 1.0</span></span><br></pre></td></tr></table></figure>

<p>实际过程：<code>n</code>先拆箱提升为<code>double</code>，然后装箱为<code>Double</code></p>
<p>参考资料</p>
<ul>
<li><a href="https://www.jianshu.com/p/4607677ef5e2" target="_blank" rel="noopener">对象包装器与自动装箱</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-2-Java基础：反射</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-2-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><strong>Java 反射是可以让我们在运行时获取类的方法、属性、父类、接口等类的内部信息的机制。</strong>也就是说，反射本质上是一个“反着来”的过程。我们通过new创建一个类的实例时，实际上是由Java虚拟机根据这个类的Class对象在运行时构建出来的，而反射是通过一个类的Class对象来获取它的定义信息，从而我们可以访问到它的属性、方法，知道这个类的父类、实现了哪些接口等信息。</p>
<h2 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h2><p>我们知道使用javac能够将.java文件编译为.class文件，这个.class文件包含了我们对类的原始定义信息（父类、接口、构造器、属性、方法等）。.class文件在运行时会被ClassLoader加载到Java虚拟机（JVM）中，当一个.class文件被加载后，JVM会为之生成一个Class对象，我们在程序中通过new实例化的对象实际上是在运行时根据相应的Class对象构造出来的。确切的说，这个Class对象实际上是<code>java.lang.Class&lt;T&gt;</code>泛型类的一个实例，比如<code>Class&lt;MyClass&gt;</code>对象即为一个封装了MyClass类的定义信息的<code>Class&lt;T&gt;</code>实例。由于<code>java.lang.Class&lt;T&gt;</code>类不存在公有构造器，因此我们不能直接实例化这个类，我们可以通过以下方法获取一个Class对象。</p>
<p>在下面的讲解中，我们将以People类和Student类为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">              <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> age;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">" "</span> + getAge());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age);</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(<span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">learn</span><span class="params">(String course)</span> </span>&#123;</span><br><span class="line">    System.out.println(name + <span class="string">" learn "</span> + course);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-通过类名获取Class对象"><a href="#2-1-通过类名获取Class对象" class="headerlink" title="2.1 通过类名获取Class对象"></a>2.1 通过类名获取Class对象</h3><p>若在编译期知道一个类的名字，我们可以这样获取它的Class对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;People&gt; peopleClass = People<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>

<p>还有一种根据类的完整路径名获取Class对象的方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设People类在com.test包中</span></span><br><span class="line">Class&lt;People&gt; peopleClass = Class.forName(<span class="string">"com.test.People"</span>);</span><br></pre></td></tr></table></figure>

<p>注意，Class.forName()方法的参数必须是一个类的<strong>全路径名</strong>。实际上，只要我们“import com.test.People”，就可以直接通过”People.class”获取他的Class对象，而不用写出全路径这么麻烦。 （若在调用 Class.forName()方法时，没有在classpath找到对应的类，会抛出 ClassNotFoundException。）</p>
<h3 id="2-2-通过对象本身获取其Class对象"><a href="#2-2-通过对象本身获取其Class对象" class="headerlink" title="2.2 通过对象本身获取其Class对象"></a>2.2 通过对象本身获取其Class对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">People people = <span class="keyword">new</span> People(<span class="string">"Bill"</span>， <span class="number">18</span>);</span><br><span class="line">Class&lt;People&gt; peopleClass = people.getClass();</span><br></pre></td></tr></table></figure>



<h3 id="2-3-通过反射获取类的构造器"><a href="#2-3-通过反射获取类的构造器" class="headerlink" title="2.3 通过反射获取类的构造器"></a>2.3 通过反射获取类的构造器</h3><p>一旦我们获得了People的Class 对象，我们便可以通过这个Class 对象获取到People类的原始定义信息。 首先，我们来获取People类的构造器对象，有了这个构造器对象，我们便能够构造出一个People对象出来。比如，我们可以在Student.java中添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class&lt;People&gt; pClass = People<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor&lt;People&gt; constructor = pClass.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    People people = constructor.newInstance(<span class="string">"Bill"</span>, <span class="number">18</span>);</span><br><span class="line">    people.speak();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面，我们调用getConstructor方法来获取一个People类的构造器对象，由于我们想要获取的构造器的形参类型为String和int，所以我们传入String.class和int.class。有了构造器对象，我们便可以调用newInstance方法来创建一个people对象。<br>注意，当通过反射获取到类的 Constructor、Method、Field对象后，在调用这些对象的方法之前，先将此对象的 accessible 标志设置为 true，以取消 Java 语言访问检查，可以提升反射速度。如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;People&gt; constructor = peopleClass.getConstructor(String<span class="class">.<span class="keyword">class</span>，</span></span><br><span class="line"><span class="class">    <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// 设置 constructor 的 Accessible属性为ture以取消Java的访问检查</span></span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-4-通过反射获取类中声明的方法"><a href="#2-4-通过反射获取类中声明的方法" class="headerlink" title="2.4 通过反射获取类中声明的方法"></a>2.4 通过反射获取类中声明的方法</h3><p><strong>获取当前类中声明的方法（不包括从父类继承来的）</strong></p>
<p>要获取当前类中声明的所有方法可以通过 Class 中的 getDeclaredMethods 函数，它会获取到当前类中声明的所有方法（包括private、public、static等各种方法），它会返回一个Method对象数组，其中的每个Method对象即表示了一个类中声明的方法。要想获得指定的方法，可以调用getDeclaredMethod(String name, Class…<T> parameterTypes)。如以下代码所示 :</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDeclaredMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student(<span class="string">"Bill"</span>, <span class="number">18</span>);</span><br><span class="line">  <span class="comment">//获取Student类声明的所有方法</span></span><br><span class="line">  Method[] methods = student.getClass().getDeclaredMethods();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取learnMethod对象（封装了learn方法）</span></span><br><span class="line">      Method learnMethod = student.getClass().getDeclaredMethod(<span class="string">"learn"</span>,</span><br><span class="line">          String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="comment">//获取learn方法的参数列表并打印出来</span></span><br><span class="line">      Class&lt;?&gt;[] paramClasses = learnMethod.getParameterTypes() ;</span><br><span class="line">      for (Class&lt;?&gt; class : paramClasses) &#123;</span><br><span class="line">        System.out.println(<span class="string">"learn方法的参数: "</span> + <span class="class"><span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//判断learn方法是否为private</span></span><br><span class="line">      System.out.println(learnMethod.getName() + <span class="string">" is private "</span></span><br><span class="line">          + Modifier.isPrivate(learnMethod.getModifiers()));</span><br><span class="line">      <span class="comment">//调用learn方法</span></span><br><span class="line">      learnMethod.invoke(student, <span class="string">"Java Reflection"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取当前类和父类中声明的公有方法</strong></p>
<p>要获取当前类以及父类中声明的所有 public 方法可以调用getMethods 函数，而要获取某个指定的public方法，可以调用getMethod方法。请看以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student(<span class="string">"mr.simple"</span>);</span><br><span class="line">  <span class="comment">// 获取所有public方法(包括Student本身的和从父类继承来的）</span></span><br><span class="line">  Method[] methods = student.getClass().getMethods();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//注意，通过 getMethod只能获取public方法，若尝试获取private方法则会抛出异常</span></span><br><span class="line">    Method learnMethod = student.getClass().getMethod(<span class="string">"learn"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-通过反射获取类中定义的属性"><a href="#2-5-通过反射获取类中定义的属性" class="headerlink" title="2.5 通过反射获取类中定义的属性"></a>2.5 通过反射获取类中定义的属性</h3><p>获取属性与获取方法是类似的，只不过把对getMethods() / getDeclaredMethods()方法的调用换成了对getFields() / getDeclaredFields()方法的调用。</p>
<p><strong>获取当前类中定义的属性（不包括从父类继承来的属性）</strong></p>
<p>要获取当前类中定义的所有属性（包括private、public、static等各种属性）可以调用 Class对象的getDeclaredFields函数；要想获得指定的属性，可以调用getDeclaredField。如以下代码所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDeclaredFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student(<span class="string">"Bill"</span>, <span class="number">18</span>);</span><br><span class="line">  <span class="comment">// 获取当前类中定义的所有属性</span></span><br><span class="line">  Field[] fields = student.getClass().getDeclaredFields();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取指定的属性</span></span><br><span class="line">    Field gradeField = student.getClass().getDeclaredField(<span class="string">"grade"</span>);</span><br><span class="line">    <span class="comment">// 获取属性值</span></span><br><span class="line">    System.out.println(<span class="string">"The grade is : "</span> + gradeField.getInt(student));</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    gradeField.set(student, <span class="number">10</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取当前类和父类中定义的public属性</strong></p>
<p>要获取当前类和父类中定义的所有public 属性可以调用Class对象的getFields 函数，而要获取某个指定的public属性，可以调用getField方法，如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student(<span class="string">"Bill"</span>， <span class="number">18</span>);</span><br><span class="line">  <span class="comment">// 获取当前类和父类的所有public属性</span></span><br><span class="line">  Field[] publicFields = student.getClass().getFields();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-通过反射获取类的父类及类所实现的接口"><a href="#2-6-通过反射获取类的父类及类所实现的接口" class="headerlink" title="2.6 通过反射获取类的父类及类所实现的接口"></a>2.6 通过反射获取类的父类及类所实现的接口</h3><p><strong>获取父类</strong></p>
<p>调用Class对象的getSuperClass方法即可，如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"Bill"</span>, <span class="number">18</span>);</span><br><span class="line">Class&lt;?&gt; superClass = student.getClass().getSuperclass();</span><br></pre></td></tr></table></figure>

<p><strong>获取所实现的接口</strong></p>
<p>要知道一个类实现了哪些接口，只需调用Class对象的getInterfaces方法，如以下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showInterfaces</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student(<span class="string">"Bill"</span>, <span class="number">19</span>);</span><br><span class="line">  Class&lt;?&gt;[] interfaces = student.getClass().getInterfaces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-特殊情况"><a href="#3-特殊情况" class="headerlink" title="3. 特殊情况"></a>3. 特殊情况</h2><p><strong>1.获取数组反射</strong></p>
<p>假如存在下面语句:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Double[].class.getName() //返回 [Ljava.lang.Double</span><br><span class="line">int[].class.getName() //返回 [I</span><br></pre></td></tr></table></figure>

<p>可以发现getName应用于数组会返回一个很奇怪的名字。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>Java核心技术卷1</p>
</li>
<li><p><a href="https://www.jianshu.com/p/2efb2d1cbbc8" target="_blank" rel="noopener">https://www.jianshu.com/p/2efb2d1cbbc8</a> </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2-面向对象-3-Java基础：反射常用的方法</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-3-Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<hr>
<h2 id="1-Class类"><a href="#1-Class类" class="headerlink" title="1. Class类"></a>1. Class类</h2><p>通过该类可以获取：类中的所有信息。</p>
<p>1.得到该类的方法（这项方法在Class类中）</p>
<ul>
<li><code>类名.class</code>：通过类名获取Class对象。</li>
<li><code>Class.forName(&quot;xxx&quot;)</code>：通过类名的全路径获取Class对象</li>
<li><code>类对象.getClass()</code>：可以通过对象本身获取Class对象</li>
</ul>
<p>在Class中常用的方法如下：（对于得到Method对象、Field对象、Constructors对象等后面将会介绍，这里不列出）</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>forName(String className)</code></td>
<td>返回描述类名为className的Class对象</td>
</tr>
<tr>
<td><code>newInstance()</code></td>
<td>返回这个类的一个新实例</td>
</tr>
<tr>
<td><code>getComponnetType()</code></td>
<td>用于确定数组的类型（常常使用）</td>
</tr>
<tr>
<td><code>getClassLoader()</code></td>
<td>返回类加载器（在动态代理中常使用）</td>
</tr>
</tbody></table>
<p>更多方法可以参考相关API或者<a href="http://www.51gjie.com/java/777.html" target="_blank" rel="noopener">http://www.51gjie.com/java/777.html</a> （有相关使用案例）</p>
<h2 id="2-Method类"><a href="#2-Method类" class="headerlink" title="2. Method类"></a>2. Method类</h2><p>通过该类可以获取：方法修饰符、方法名称、参数列表等</p>
<p>1.获取Method对象（这个方法位于Class类中）</p>
<ul>
<li><code>getMethod()</code>：获取类的public类型的方法</li>
<li><code>getMethod(String name, Class[] params)</code>：获得类的特定方法（前提是public类型的）,name参数指定方法的名字,params参数指定方法的参数类型 </li>
<li><code>getDeclaredMethods()</code>：获取类中的所有方法（public、protected、default、private等）</li>
<li><code>getDeclaredMethod(String name, Class[] params)</code>： 获得类的特定方法,name参数指定方法的名字,params参数指定方法的参数类型 </li>
</ul>
<p>2.常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getModifiers()</code></td>
<td>返回由此<code>Method</code>对象表示的方法的Java语言修饰符，以整数形式返回。</td>
</tr>
<tr>
<td><code>getReturnType()</code></td>
<td>返回一个<code>Class</code>对象，该对象表示此<code>Method</code>对象表示的方法的正式返回类型。</td>
</tr>
<tr>
<td><code>getName()</code></td>
<td>以字符串形式返回此方法的名称。</td>
</tr>
<tr>
<td><code>getParameterTypes()</code></td>
<td>返回一个<code>Class</code>对象数组，它们以声明顺序表示由此<code>Method</code>对象表示的构造函数的形式参数类型。</td>
</tr>
<tr>
<td><code>public Object invoke(Object obj, Object... args)</code></td>
<td>通过反射调用执行一个方法（通常这种方法是private的，或者无法得到该类的对象因而无法访问）</td>
</tr>
</tbody></table>
<p>其他的方法可以查看源码API或者参考：<a href="https://www.yiibai.com/javareflect/java_reflect_method.html" target="_blank" rel="noopener">https://www.yiibai.com/javareflect/java_reflect_method.html</a> </p>
<p>【注意】</p>
<ul>
<li><p>获取修饰符时，<code>getModifiers()</code>返回的修饰符是以整数形式表示（如<code>PRIVATE = 0x00000002</code>），需要使用<code>Modifier</code>类进行判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定的方法</span></span><br><span class="line">Method learnMethod = Student.class.getDeclaredMethod("learn", String.class);</span><br><span class="line"><span class="comment">// 获取该方法的修饰符</span></span><br><span class="line">System.out.println(<span class="string">"该方法的修饰符为："</span>:Modifier.isPrivate(learnMethod.getModifiers());</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行invoke方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">learnMethod.invoke(studentClass, <span class="string">"Java Reflection"</span>);</span><br><span class="line"><span class="comment">// 其中learn方法为： private void learn(String course)&#123;...&#125;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="3-Construtor类"><a href="#3-Construtor类" class="headerlink" title="3. Construtor类"></a>3. Construtor类</h2><p>通过该类可以管理所有构造方法</p>
<p>1.获取Constructor对象（该方法位于Class类中）</p>
<ul>
<li><code>getConstructors()</code>：获取类中public构造方法 </li>
<li><code>getConstructor(Class[] params)</code>：获取类的public特定构造方法,params参数指定构造方法的参数类型 </li>
<li><code>getDeclaredConstructors()</code>：获取类中所有的构造方法(public、protected、default、private) </li>
<li><code>getDeclaredConstructor(Class[] params)</code>：获取类的特定构造方法(public、protected、default、private) ,params参数指定构造方法的参数类型 </li>
</ul>
<p>2.常用方法和Method类似（但是没有<code>invok</code>和<code>getReturnType()</code>方法，至于为什么，自己想明白。）下面列举一个特殊点</p>
<ul>
<li><p><code>newInstance(Object ... initargs)</code>创建实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到构造器对象</span></span><br><span class="line">Constructor&lt;People&gt; constructor = peopleClass.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// 使用newInstance创建实例</span></span><br><span class="line">People people = constructor.newInstance(<span class="string">"Bill"</span>, <span class="string">"18"</span>);</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h2 id="4-Field类"><a href="#4-Field类" class="headerlink" title="4. Field类"></a>4. Field类</h2><p>通过该类可以获取：某个类的属性或该属性的值</p>
<p>1.获取Field类对象（这些方法在Class类中）</p>
<ul>
<li><code>getDeclaredField(String name)</code>：返回一个Field对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段 （包括私有）</li>
<li><code>getDeclaredFields()</code>：返回 Field 对象的一个数组，该数组包含此 Class 对象所表示的类或接口所声明的所有字段（包括私有成员） </li>
<li><code>getField(String name)</code>：返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定<strong>公共成员字段</strong>。 </li>
<li><code>getFields()</code> ：返回一个包含某些 Field 对象的数组，该数组包含此 Class 对象所表示的类或接口的所有可访问<strong>公共字段</strong>。</li>
</ul>
<p>2.主要使用方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>getType()</code></td>
<td>获取属性声明时类型对象（返回class对象）</td>
</tr>
<tr>
<td><code>getGenericType()</code></td>
<td>返回属性声名的Type类型</td>
</tr>
<tr>
<td><code>get(Object obj)</code></td>
<td>取得obj对象这个Field上的值</td>
</tr>
<tr>
<td><code>getXXX(Object obj)</code></td>
<td>对于一个常规的数值类型，获取obj上的Field上的值</td>
</tr>
<tr>
<td><code>set(Object obj, Object value)</code></td>
<td>向obj对象的这个Field设置新值value</td>
</tr>
<tr>
<td><code>setXXX(Object obj, XXX value)</code></td>
<td>向obj对象的这个Field设置新值value(常规数值)</td>
</tr>
<tr>
<td><code>getName()</code></td>
<td>获取属性声明时名字</td>
</tr>
<tr>
<td><code>getAnnotations()</code></td>
<td>获得这个属性上所有的注解</td>
</tr>
<tr>
<td><code>isEnumConstant()</code></td>
<td>判断这个属性是否是枚举类</td>
</tr>
<tr>
<td><code>isSynthetic()</code></td>
<td>判断这个属性是否是 复合类</td>
</tr>
</tbody></table>
<p>【注意】:</p>
<ul>
<li><p><code>getType()</code>和<code>getGenericType()</code>的区别（参考<a href="http://www.51gjie.com/java/793.html" target="_blank" rel="noopener">http://www.51gjie.com/java/793.html</a> ）</p>
<p>（1）首先是返回的类型不一样，一个是Class对象一个是Type接口 </p>
<p>（2）如果属性是一个泛型，则<code>getType()</code>只能得到这个属性的接口类型。但是<code>getGenericType()</code>可以得到泛型的参数类型</p>
<p>（3）<code>getGenericType()</code>如果当前属性有签名属性类型就返回，否则就返回 <code>Field.getType()</code>。</p>
</li>
<li><p><code>get()</code>和<code>set()</code>方法使用注意：</p>
<p>由于通常我们无法直接访问到private修饰的变量并操作，但是我们可以通过反射实现，前提必须是<code>setAccessible(true)</code>，否则将报<code>IllegalAccessException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field grade = Student.class.getDeclaredField("grade");</span><br><span class="line">grade.setAccessible(<span class="keyword">true</span>); <span class="comment">// 解除限制</span></span><br><span class="line">grade.set(grade,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="5-Array类"><a href="#5-Array类" class="headerlink" title="5. Array类"></a>5. Array类</h2><p>该类位于<code>java.lang.reflect</code>包中，是一个工具类。该类的通常作用：得到数组的类型、判断该数据是否是数组、set/get修改或获取数组的内容。</p>
<p>1.由于该类中的方法全部是<code>static</code>的，所以可以直接通过Array类调用相关方法。</p>
<p>2.该类的主要方法如下</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>newInstance(Class&lt;?&gt; componentType, int... dimensions)</code></td>
<td>创建具有指定组件类型和维度的新数组</td>
</tr>
<tr>
<td><code>newInstance(Class&lt;?&gt; componentType, int length)</code></td>
<td>创建具有指定组件类型和长度的新数组</td>
</tr>
<tr>
<td><code>set(Object array, int index, Object value)</code></td>
<td>将指定数组对象的索引组件的值设置为指定的新值。</td>
</tr>
<tr>
<td><code>get(Object array, int index)</code></td>
<td>以对象形式返回指定数组对象中的索引组件的值。</td>
</tr>
<tr>
<td><code>getLength(Object array)</code></td>
<td>以整数形式返回指定数组对象的长度</td>
</tr>
</tbody></table>
<p>应用：</p>
<ul>
<li><p>判断数组类型，获取数组长度以及获取数组值、修改数组的值、创建数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 得到数组代表的类的Class</span></span><br><span class="line">Class&lt;?&gt; c = arr.getClass().getComponentType();</span><br><span class="line"><span class="comment">// 得到数组长度</span></span><br><span class="line">System.out.println(<span class="string">"数组长度： "</span> + Array.getLength(arr));</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    System.out.print(Array.get(arr, i) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改数组</span></span><br><span class="line">Array.set(arr, <span class="number">0</span>, <span class="number">3</span>);  <span class="comment">// 修改数组第一个元素为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用newInstance创建数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 得到String类对应的Class对象</span></span><br><span class="line">Class &lt;?&gt; classType = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">// 创建指定类型为String的数组，长度为10</span></span><br><span class="line">Object object = Array.newInstance(classType, <span class="number">10</span>); <span class="comment">//数组0,9 </span></span><br><span class="line"><span class="comment">// 设置数组的第6个元素为“123”</span></span><br><span class="line">Array.set(object, <span class="number">5</span>, <span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现任意类型的扩展</p>
<p>首先我们知道该类能够实现动态创建数组，所以存在下面方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object[] badCopyOf(Object[] a, <span class="keyword">int</span> newLength)&#123;</span><br><span class="line">    Object[] newArray = <span class="keyword">new</span> Object[newLength];</span><br><span class="line">    <span class="comment">// 这是个参数分别是：原始数组，从原始数组开始的位置，目标数组，目标数组开始的位置，要复制的长度</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(a.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面虽然能够实现，但是存在严重问题：返回的类型时<code>Object[]</code>数组，如果我传入的是<code>Employee[]</code>，那么返回的结果明显不符合要求，所以这里可以使用反射解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Obect <span class="title">goodCopyOf</span><span class="params">(Object a, <span class="keyword">int</span> newLength)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取数组类对象</span></span><br><span class="line">    Class c1 = a.getClass;</span><br><span class="line">    <span class="keyword">if</span>(!c1.isArray())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.确定数组类型</span></span><br><span class="line">    Class componentType = c1.getComponentType();</span><br><span class="line">	<span class="comment">// 3.获取数组长度</span></span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(a);</span><br><span class="line">    <span class="comment">// 4. 创建一个实例</span></span><br><span class="line">    Object newArray = Array.newInstance(componentType, newLength);</span><br><span class="line">    <span class="comment">// 5.复制</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, newArray, <span class="number">0</span>, Math.min(a.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便实现了对任意类型的数组动态扩容的需求。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.51gjie.com/java/793.html" target="_blank" rel="noopener">http://www.51gjie.com/java/793.html</a></li>
<li><a href="https://www.yiibai.com/javareflect/java_reflect_method.html" target="_blank" rel="noopener">https://www.yiibai.com/javareflect/java_reflect_method.html</a> </li>
<li>Java核心技术卷1（第十版）</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-1-关键字-1-Java基础：final关键字</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-1-%E5%85%B3%E9%94%AE%E5%AD%97-1-Java%E5%9F%BA%E7%A1%80%EF%BC%9Afinal%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="1-final关键字的基本用法"><a href="#1-final关键字的基本用法" class="headerlink" title="1. final关键字的基本用法"></a>1. final关键字的基本用法</h2><p>　　*   final类不能被继承，没有子类，final类中的方法默认是final的。</p>
<ul>
<li>final方法不能被子类的方法覆盖，但可以被继承。</li>
<li>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</li>
<li>final不能用于修饰构造方法。</li>
</ul>
<p>注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</p>
<h3 id="1-1-final属性"><a href="#1-1-final属性" class="headerlink" title="1.1 final属性"></a>1.1 final属性</h3><ul>
<li>一个永不改变的编译时常量。</li>
<li>一个在运行时被初始化的值，而之后无法被改变；</li>
<li>一个既是static又是final的域：是一段不能改变的存储空间；</li>
</ul>
<p><strong>final类型运用于数据：</strong></p>
<ul>
<li>基本数据类型（int、double、char…）运用final时，使数值恒定不变；</li>
<li>对象引用运用final时，final使得引用恒定不变，引用内部的数据若不是final型，可以进行修改。</li>
<li>数组类型运用final时，final使得数组引用恒定不变，数组内部的数据若不是final型，可以进行修改。</li>
</ul>
<p><strong>final与static</strong></p>
<ul>
<li>final指明数据为一个常量，恒定无法修改；</li>
<li>static指明数据只占用一份存储区域；</li>
</ul>
<p><strong>测试案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalData</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> valueOne = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> valueTwo = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Value v1 = <span class="keyword">new</span> Value(<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">private</span> Value v2 = <span class="keyword">new</span> Value(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VAL_TWO = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FinalData finalData = <span class="keyword">new</span> FinalData();</span><br><span class="line">		<span class="comment">/*-----------基本类型测试------------------------------------*/</span></span><br><span class="line"><span class="comment">//		finalData.valueOne = 4;//valueOne是常量，无法修改</span></span><br><span class="line">		finalData.valueTwo = <span class="number">14</span>;<span class="comment">//valueTwo不是常量，可以修改</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*-----------对象类型测试------------------------------------*/</span></span><br><span class="line"><span class="comment">//		finalData.v1 = new Value(5);//v1对象是final型常量，其引用是无法修改的。</span></span><br><span class="line">		finalData.v2 = <span class="keyword">new</span> Value(<span class="number">20</span>);<span class="comment">//v2对象final型常量，其引用可以修改。</span></span><br><span class="line">		finalData.v1.i = <span class="number">5</span>;<span class="comment">//v1对象的成员变量不是final型，可以修改</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*-----------数组类型测试------------------------------------*/</span></span><br><span class="line"><span class="comment">//		finalData.a = new int[3];//数组a是final型，无法修改a的引用</span></span><br><span class="line">		finalData.b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">13</span>];<span class="comment">//数组b不是final型，可以对其引用进行修改</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;finalData.a.length;i++) </span><br><span class="line">			finalData.a[i]++;<span class="comment">//数组a内部数据是int型，不是final型，可以修改</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*-----------static final类型测试------------------------------------*/</span></span><br><span class="line"><span class="comment">//		finalData.VAL_TWO = 4;</span></span><br><span class="line">		<span class="comment">//定义为private，只能被本类的方法调用；定义为static，则强调只有一份，且只被执行一次；定义为final，则说明它是一个常量，无法被修改。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-final方法"><a href="#1-2-final方法" class="headerlink" title="1.2 final方法"></a>1.2 final方法</h3><p>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。</p>
<ul>
<li>把方法锁定，防止任何继承类修改它的意义和实现。</li>
<li>高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</li>
</ul>
<p><strong>测试案例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"FianlDemo.f()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"FianlDemo.g()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalOverriding</span> <span class="keyword">extends</span> <span class="title">FinalDemo</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"FinalOverriding.f()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void g()&#123;//无法覆盖父类的final方法g（）</span></span><br><span class="line"><span class="comment">//		System.out.println("FinalOverriding.g()");</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-final类"><a href="#1-3-final类" class="headerlink" title="1.3 final类"></a>1.3 final类</h3><p>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</p>
<h2 id="2-String类为什是final的？"><a href="#2-String类为什是final的？" class="headerlink" title="2. String类为什是final的？"></a>2. String类为什是final的？</h2><p>首先我们通过前面的内容知道，被final修饰的类不能被继承，即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。</p>
<p>而String类被设计为final的目的：</p>
<ul>
<li><strong>为了实现字符串池</strong></li>
<li><strong>为了线程安全</strong></li>
<li><strong>为了实现String可以创建HashCode不可变性</strong></li>
</ul>
<p><strong>问题1（扩展的）：String的不可变性是如何保证的？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>final修饰的String，代表了String的不可继承性，final修饰的char[]代表了被存储的数据不可更改性。但是：虽然final代表了不可变，但仅仅是引用地址不可变，并不代表了数组本身不会变，请看下面图片。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11805791-9c6c533a20d89665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt></p>
<p>final也可以将数组本身改变的，这个时候，起作用的还有<strong>private</strong>，正是因为两者保证了String的不可变性。</p>
<p><strong>问题2：为了实现字符串池</strong></p>
<p>首先，前面之所以需要讨论字符串的不可变，是因为<strong>只有当字符串是不可变的，字符串池才有可能实现</strong>。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，那么String interning将不能实现，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变。</p>
<p>如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</p>
<p><strong>问题3：为了线程安全</strong></p>
<p>因为字符串是不可变的，所以<strong>是多线程安全的</strong>，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p>
<p><strong>问题4：为了实现String可以创建HashCode不可变性</strong></p>
<p> 因为字符串是不可变的，所以在它创建的时候<strong>HashCode</strong>就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>
<p>参考资料：</p>
<ul>
<li><p>《Java编程思想》</p>
</li>
<li><p><a href="https://blog.csdn.net/andie_guo/article/details/12885885" target="_blank" rel="noopener">【Java编程】Java关键字final使用详解</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/9c7f5daac283" target="_blank" rel="noopener">Java String类为什么是final的？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-1-关键字-4-Java基础：super关键字</title>
    <url>/2019/Java%E5%9F%BA%E7%A1%80-1-%E5%85%B3%E9%94%AE%E5%AD%97-4-Java%E5%9F%BA%E7%A1%80%EF%BC%9Asuper%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>（1）super关键字</p>
<p><strong>它是一个指代变量，用于在子类中指代父类对象。</strong></p>
<p>（2）应用范围</p>
<ul>
<li><strong>访问父类的方法。</strong></li>
<li><strong>调用父类构造方法。</strong></li>
<li><strong>访问父类中的隐藏成员变量。</strong></li>
</ul>
<h2 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2. 使用说明"></a>2. 使用说明</h2><h3 id="2-1-访问父类中的方法"><a href="#2-1-访问父类中的方法" class="headerlink" title="2.1 访问父类中的方法"></a>2.1 访问父类中的方法</h3><p>第一步：定义father类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String father_a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        father_a=<span class="string">"父亲：曹操"</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是，"</span>+father_a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"曹操：挟天子以令诸侯"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：定义son类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String son_a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        son_a=<span class="string">"儿子：曹冲"</span>;</span><br><span class="line">        System.out.println(<span class="string">"我是，"</span>+son_a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//访问父类中的方法</span></span><br><span class="line">        <span class="keyword">super</span>.dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">        son.dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output：</span></span><br><span class="line"><span class="comment">//我是，父亲：曹操</span></span><br><span class="line"><span class="comment">//我是，儿子：曹冲</span></span><br><span class="line"><span class="comment">//曹操：挟天子以令诸侯</span></span><br></pre></td></tr></table></figure>

<p>我们会发现调用了super.dosomething();就会执行父类的dosomething方法。</p>
<h3 id="2-2-重写父类变量"><a href="#2-2-重写父类变量" class="headerlink" title="2.2 重写父类变量"></a>2.2 重写父类变量</h3><p>我们还拿上面的例子来说明一下：</p>
<p>第一步：定义父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String father_a=<span class="string">"我是父亲曹操的变量"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"曹操：挟天子以令诸侯"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：定义子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  String son_a=<span class="string">"我是儿子曹冲的变量"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super.father_a可以调用父类的变量（public和protected）</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.father_a);</span><br><span class="line">        System.out.println(son_a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">        son.dosomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//我是父亲曹操的变量</span></span><br><span class="line"><span class="comment">//我是儿子曹冲的变量</span></span><br></pre></td></tr></table></figure>



<h3 id="2-3-子类构造方法调用"><a href="#2-3-子类构造方法调用" class="headerlink" title="2.3 子类构造方法调用"></a>2.3 子类构造方法调用</h3><p>第一步：定义父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String father_a=<span class="string">"我是父亲曹操的变量"</span>;</span><br><span class="line">    <span class="comment">//无参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无参构造器:"</span>+father_a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String father_a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.father_a = father_a;</span><br><span class="line">        System.out.println(<span class="string">"有参构造器:"</span>+father_a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：定义子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在子类中调用父类构造器</span></span><br><span class="line">        <span class="comment">//第一种：super（执行父类中的无参构造器，默认可以不写）</span></span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        <span class="comment">//第二种：执行父类中的有参构造器，参数写到super中就可以了</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"子类传给父类的"</span>);</span><br><span class="line">        System.out.println(<span class="string">"子类的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son=<span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//有参构造器:子类传给父类的</span></span><br><span class="line"><span class="comment">//子类的构造方法</span></span><br></pre></td></tr></table></figure>

<p>从上面我们可以看到，其实是有两种情况</p>
<p>第一种：直接调用super()会执行父类的无参构造方法，可以默认不写。</p>
<p>第二种：使用super(“父类参数”),调用父类有参构造方法，把参数传递进来就好。</p>
<p>这两种情况还是比较简单的，不过还有几种比较特殊的情况需要我们去注意，网上的大神也都提到了，你可以试着去了解一下。</p>
<p><strong>注意问题一：父类只有带参构造器（无参构造器没有），子类必须有相同参数的构造方法</strong></p>
<p>我们还是使用代码去测试一下</p>
<p>首先我们定义一个父类：只有一个带参构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String father_a=<span class="string">"我是父亲曹操的变量"</span>;</span><br><span class="line">    <span class="comment">//有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String father_a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.father_a = father_a;</span><br><span class="line">        System.out.println(<span class="string">"有参构造器:"</span>+father_a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们看看在子类中，如果什么都没有会出现什么</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4153190-239b3a5a7ce0ed61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/765/format/webp" alt></p>
<p>意思已经很明确了，我们的子类必须要有一个显示的构造方法去匹配父类。</p>
<p><strong>注意问题二：子类必须有相同参数的构造方法，并且还需要调用super(参数)</strong></p>
<p>在注意问题一种我们知道，在子类中需要定义一个构造方法去匹配父类构造方法，现在我们在子类中去定义一下不就解决了嘛，但随之而来由出来了个问题，我们看看。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4153190-eacfd445ad15ecc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/699/format/webp" alt></p>
<p>为什么会出现犯错误呢？其实我们只是定义了Son类的无参构造器，其默认调用super(),他只是调用了父类的无参构造器，并没有调用有参构造器，因此需要我们再去调用一下有参的。我们把son类中的构造方法中加上一句话就好了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4153190-9c709ce4209806ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/370/format/webp" alt></p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>super关键字我们只需要知道在三种情况下的使用就好，在构造方法中，还要注意两个问题。面试的时候游刃有余。OK，今天的文章就先讲到这。如有问题，还请批评指正。</p>
<p>参考原文：</p>
<ul>
<li><a href="https://www.jianshu.com/p/ae9c1a16fa98" target="_blank" rel="noopener">https://www.jianshu.com/p/ae9c1a16fa98</a></li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
